var Pl=Object.create;var Eo=Object.defineProperty;var Ll=Object.getOwnPropertyDescriptor;var Rl=Object.getOwnPropertyNames;var Cl=Object.getPrototypeOf,vl=Object.prototype.hasOwnProperty;var Ks=(R,L)=>()=>(L||R((L={exports:{}}).exports,L),L.exports);var Ul=(R,L,U,$)=>{if(L&&typeof L=="object"||typeof L=="function")for(let z of Rl(L))!vl.call(R,z)&&z!==U&&Eo(R,z,{get:()=>L[z],enumerable:!($=Ll(L,z))||$.enumerable});return R};var _o=(R,L,U)=>(U=R!=null?Pl(Cl(R)):{},Ul(L||!R||!R.__esModule?Eo(U,"default",{value:R,enumerable:!0}):U,R));var bo=Ks((mo,po)=>{(function(R){var L=Object.hasOwnProperty,U=Array.isArray?Array.isArray:function(m){return Object.prototype.toString.call(m)==="[object Array]"},$=10,z=typeof process=="object"&&typeof process.nextTick=="function",se=typeof Symbol=="function",ae=typeof Reflect=="object",fe=typeof setImmediate=="function",Ae=fe?setImmediate:setTimeout,le=se?ae&&typeof Reflect.ownKeys=="function"?Reflect.ownKeys:function(i){var m=Object.getOwnPropertyNames(i);return m.push.apply(m,Object.getOwnPropertySymbols(i)),m}:Object.keys;function pe(){this._events={},this._conf&&Ce.call(this,this._conf)}function Ce(i){i&&(this._conf=i,i.delimiter&&(this.delimiter=i.delimiter),i.maxListeners!==R&&(this._maxListeners=i.maxListeners),i.wildcard&&(this.wildcard=i.wildcard),i.newListener&&(this._newListener=i.newListener),i.removeListener&&(this._removeListener=i.removeListener),i.verboseMemoryLeak&&(this.verboseMemoryLeak=i.verboseMemoryLeak),i.ignoreErrors&&(this.ignoreErrors=i.ignoreErrors),this.wildcard&&(this.listenerTree={}))}function De(i,m){var I="(node) warning: possible EventEmitter memory leak detected. "+i+" listeners added. Use emitter.setMaxListeners() to increase limit.";if(this.verboseMemoryLeak&&(I+=" Event name: "+m+"."),typeof process<"u"&&process.emitWarning){var h=new Error(I);h.name="MaxListenersExceededWarning",h.emitter=this,h.count=i,process.emitWarning(h)}else console.error(I),console.trace&&console.trace()}var Je=function(i,m,I){var h=arguments.length;switch(h){case 0:return[];case 1:return[i];case 2:return[i,m];case 3:return[i,m,I];default:for(var l=new Array(h);h--;)l[h]=arguments[h];return l}};function We(i,m){for(var I={},h,l=i.length,C=m?m.length:0,y=0;y<l;y++)h=i[y],I[h]=y<C?m[y]:R;return I}function Ze(i,m,I){this._emitter=i,this._target=m,this._listeners={},this._listenersCount=0;var h,l;if((I.on||I.off)&&(h=I.on,l=I.off),m.addEventListener?(h=m.addEventListener,l=m.removeEventListener):m.addListener?(h=m.addListener,l=m.removeListener):m.on&&(h=m.on,l=m.off),!h&&!l)throw Error("target does not implement any known event API");if(typeof h!="function")throw TypeError("on method must be a function");if(typeof l!="function")throw TypeError("off method must be a function");this._on=h,this._off=l;var C=i._observers;C?C.push(this):i._observers=[this]}Object.assign(Ze.prototype,{subscribe:function(i,m,I){var h=this,l=this._target,C=this._emitter,y=this._listeners,G=function(){var F=Je.apply(null,arguments),Y={data:F,name:m,original:i};if(I){var P=I.call(l,Y);P!==!1&&C.emit.apply(C,[Y.name].concat(F));return}C.emit.apply(C,[m].concat(F))};if(y[i])throw Error("Event '"+i+"' is already listening");this._listenersCount++,C._newListener&&C._removeListener&&!h._onNewListener?(this._onNewListener=function(F){F===m&&y[i]===null&&(y[i]=G,h._on.call(l,i,G))},C.on("newListener",this._onNewListener),this._onRemoveListener=function(F){F===m&&!C.hasListeners(F)&&y[i]&&(y[i]=null,h._off.call(l,i,G))},y[i]=null,C.on("removeListener",this._onRemoveListener)):(y[i]=G,h._on.call(l,i,G))},unsubscribe:function(i){var m=this,I=this._listeners,h=this._emitter,l,C,y=this._off,G=this._target,F;if(i&&typeof i!="string")throw TypeError("event must be a string");function Y(){m._onNewListener&&(h.off("newListener",m._onNewListener),h.off("removeListener",m._onRemoveListener),m._onNewListener=null,m._onRemoveListener=null);var P=j.call(h,m);h._observers.splice(P,1)}if(i){if(l=I[i],!l)return;y.call(G,i,l),delete I[i],--this._listenersCount||Y()}else{for(C=le(I),F=C.length;F-- >0;)i=C[F],y.call(G,i,I[i]);this._listeners={},this._listenersCount=0,Y()}}});function _t(i,m,I,h){var l=Object.assign({},m);if(!i)return l;if(typeof i!="object")throw TypeError("options must be an object");var C=Object.keys(i),y=C.length,G,F,Y;function P(r){throw Error('Invalid "'+G+'" option value'+(r?". Reason: "+r:""))}for(var a=0;a<y;a++){if(G=C[a],!h&&!L.call(m,G))throw Error('Unknown "'+G+'" option');F=i[G],F!==R&&(Y=I[G],l[G]=Y?Y(F,P):F)}return l}function ue(i,m){return(typeof i!="function"||!i.hasOwnProperty("prototype"))&&m("value must be a constructor"),i}function je(i){var m="value must be type of "+i.join("|"),I=i.length,h=i[0],l=i[1];return I===1?function(C,y){if(typeof C===h)return C;y(m)}:I===2?function(C,y){var G=typeof C;if(G===h||G===l)return C;y(m)}:function(C,y){for(var G=typeof C,F=I;F-- >0;)if(G===i[F])return C;y(m)}}var Qe=je(["function"]),lt=je(["object","function"]);function Ot(i,m,I){var h,l,C=0,y,G=new i(function(F,Y,P){I=_t(I,{timeout:0,overload:!1},{timeout:function(Ne,Te){return Ne*=1,(typeof Ne!="number"||Ne<0||!Number.isFinite(Ne))&&Te("timeout must be a positive number"),Ne}}),h=!I.overload&&typeof i.prototype.cancel=="function"&&typeof P=="function";function a(){l&&(l=null),C&&(clearTimeout(C),C=0)}var r=function(Ne){a(),F(Ne)},Ee=function(Ne){a(),Y(Ne)};h?m(r,Ee,P):(l=[function(Ne){Ee(Ne||Error("canceled"))}],m(r,Ee,function(Ne){if(y)throw Error("Unable to subscribe on cancel event asynchronously");if(typeof Ne!="function")throw TypeError("onCancel callback must be a function");l.push(Ne)}),y=!0),I.timeout>0&&(C=setTimeout(function(){var Ne=Error("timeout");Ne.code="ETIMEDOUT",C=0,G.cancel(Ne),Y(Ne)},I.timeout))});return h||(G.cancel=function(F){if(l){for(var Y=l.length,P=1;P<Y;P++)l[P](F);l[0](F),l=null}}),G}function j(i){var m=this._observers;if(!m)return-1;for(var I=m.length,h=0;h<I;h++)if(m[h]._target===i)return h;return-1}function D(i,m,I,h,l){if(!I)return null;if(h===0){var C=typeof m;if(C==="string"){var y,G,F=0,Y=0,P=this.delimiter,a=P.length;if((G=m.indexOf(P))!==-1){y=new Array(5);do y[F++]=m.slice(Y,G),Y=G+a;while((G=m.indexOf(P,Y))!==-1);y[F++]=m.slice(Y),m=y,l=F}else m=[m],l=1}else C==="object"?l=m.length:(m=[m],l=1)}var r=null,Ee,Ne,Te,A,T,_e=m[h],At=m[h+1],b,p;if(h===l)I._listeners&&(typeof I._listeners=="function"?(i&&i.push(I._listeners),r=[I]):(i&&i.push.apply(i,I._listeners),r=[I]));else if(_e==="*"){for(b=le(I),G=b.length;G-- >0;)Ee=b[G],Ee!=="_listeners"&&(p=D(i,m,I[Ee],h+1,l),p&&(r?r.push.apply(r,p):r=p));return r}else if(_e==="**"){for(T=h+1===l||h+2===l&&At==="*",T&&I._listeners&&(r=D(i,m,I,l,l)),b=le(I),G=b.length;G-- >0;)Ee=b[G],Ee!=="_listeners"&&(Ee==="*"||Ee==="**"?(I[Ee]._listeners&&!T&&(p=D(i,m,I[Ee],l,l),p&&(r?r.push.apply(r,p):r=p)),p=D(i,m,I[Ee],h,l)):Ee===At?p=D(i,m,I[Ee],h+2,l):p=D(i,m,I[Ee],h,l),p&&(r?r.push.apply(r,p):r=p));return r}else I[_e]&&(r=D(i,m,I[_e],h+1,l));if(Ne=I["*"],Ne&&D(i,m,Ne,h+1,l),Te=I["**"],Te)if(h<l)for(Te._listeners&&D(i,m,Te,l,l),b=le(Te),G=b.length;G-- >0;)Ee=b[G],Ee!=="_listeners"&&(Ee===At?D(i,m,Te[Ee],h+2,l):Ee===_e?D(i,m,Te[Ee],h+1,l):(A={},A[Ee]=Te[Ee],D(i,m,{"**":A},h+1,l)));else Te._listeners?D(i,m,Te,l,l):Te["*"]&&Te["*"]._listeners&&D(i,m,Te["*"],l,l);return r}function v(i,m,I){var h=0,l=0,C,y=this.delimiter,G=y.length,F;if(typeof i=="string")if((C=i.indexOf(y))!==-1){F=new Array(5);do F[h++]=i.slice(l,C),l=C+G;while((C=i.indexOf(y,l))!==-1);F[h++]=i.slice(l)}else F=[i],h=1;else F=i,h=i.length;if(h>1){for(C=0;C+1<h;C++)if(F[C]==="**"&&F[C+1]==="**")return}var Y=this.listenerTree,P;for(C=0;C<h;C++)if(P=F[C],Y=Y[P]||(Y[P]={}),C===h-1)return Y._listeners?(typeof Y._listeners=="function"&&(Y._listeners=[Y._listeners]),I?Y._listeners.unshift(m):Y._listeners.push(m),!Y._listeners.warned&&this._maxListeners>0&&Y._listeners.length>this._maxListeners&&(Y._listeners.warned=!0,De.call(this,Y._listeners.length,P))):Y._listeners=m,!0;return!0}function J(i,m,I,h){for(var l=le(i),C=l.length,y,G,F,Y=i._listeners,P;C-- >0;)G=l[C],y=i[G],G==="_listeners"?F=I:F=I?I.concat(G):[G],P=h||typeof G=="symbol",Y&&m.push(P?F:F.join(this.delimiter)),typeof y=="object"&&J.call(this,y,m,F,P);return m}function W(i){for(var m=le(i),I=m.length,h,l,C;I-- >0;)l=m[I],h=i[l],h&&(C=!0,l!=="_listeners"&&!W(h)&&delete i[l]);return C}function oe(i,m,I){this.emitter=i,this.event=m,this.listener=I}oe.prototype.off=function(){return this.emitter.off(this.event,this.listener),this};function ne(i,m,I){if(I===!0)l=!0;else if(I===!1)h=!0;else{if(!I||typeof I!="object")throw TypeError("options should be an object or true");var h=I.async,l=I.promisify,C=I.nextTick,y=I.objectify}if(h||C||l){var G=m,F=m._origin||m;if(C&&!z)throw Error("process.nextTick is not supported");l===R&&(l=m.constructor.name==="AsyncFunction"),m=function(){var Y=arguments,P=this,a=this.event;return l?C?Promise.resolve():new Promise(function(r){Ae(r)}).then(function(){return P.event=a,G.apply(P,Y)}):(C?process.nextTick:Ae)(function(){P.event=a,G.apply(P,Y)})},m._async=!0,m._origin=F}return[m,y?new oe(this,i,m):this]}function ee(i){this._events={},this._newListener=!1,this._removeListener=!1,this.verboseMemoryLeak=!1,Ce.call(this,i)}ee.EventEmitter2=ee,ee.prototype.listenTo=function(i,m,I){if(typeof i!="object")throw TypeError("target musts be an object");var h=this;I=_t(I,{on:R,off:R,reducers:R},{on:Qe,off:Qe,reducers:lt});function l(C){if(typeof C!="object")throw TypeError("events must be an object");var y=I.reducers,G=j.call(h,i),F;G===-1?F=new Ze(h,i,I):F=h._observers[G];for(var Y=le(C),P=Y.length,a,r=typeof y=="function",Ee=0;Ee<P;Ee++)a=Y[Ee],F.subscribe(a,C[a]||a,r?y:y&&y[a])}return U(m)?l(We(m)):l(typeof m=="string"?We(m.split(/\s+/)):m),this},ee.prototype.stopListeningTo=function(i,m){var I=this._observers;if(!I)return!1;var h=I.length,l,C=!1;if(i&&typeof i!="object")throw TypeError("target should be an object");for(;h-- >0;)l=I[h],(!i||l._target===i)&&(l.unsubscribe(m),C=!0);return C},ee.prototype.delimiter=".",ee.prototype.setMaxListeners=function(i){i!==R&&(this._maxListeners=i,this._conf||(this._conf={}),this._conf.maxListeners=i)},ee.prototype.getMaxListeners=function(){return this._maxListeners},ee.prototype.event="",ee.prototype.once=function(i,m,I){return this._once(i,m,!1,I)},ee.prototype.prependOnceListener=function(i,m,I){return this._once(i,m,!0,I)},ee.prototype._once=function(i,m,I,h){return this._many(i,1,m,I,h)},ee.prototype.many=function(i,m,I,h){return this._many(i,m,I,!1,h)},ee.prototype.prependMany=function(i,m,I,h){return this._many(i,m,I,!0,h)},ee.prototype._many=function(i,m,I,h,l){var C=this;if(typeof I!="function")throw new Error("many only accepts instances of Function");function y(){return--m===0&&C.off(i,y),I.apply(this,arguments)}return y._origin=I,this._on(i,y,h,l)},ee.prototype.emit=function(){if(!this._events&&!this._all)return!1;this._events||pe.call(this);var i=arguments[0],m,I=this.wildcard,h,l,C,y,G;if(i==="newListener"&&!this._newListener&&!this._events.newListener)return!1;if(I&&(m=i,i!=="newListener"&&i!=="removeListener"&&typeof i=="object")){if(l=i.length,se){for(C=0;C<l;C++)if(typeof i[C]=="symbol"){G=!0;break}}G||(i=i.join(this.delimiter))}var F=arguments.length,Y;if(this._all&&this._all.length)for(Y=this._all.slice(),C=0,l=Y.length;C<l;C++)switch(this.event=i,F){case 1:Y[C].call(this,i);break;case 2:Y[C].call(this,i,arguments[1]);break;case 3:Y[C].call(this,i,arguments[1],arguments[2]);break;default:Y[C].apply(this,arguments)}if(I)Y=[],D.call(this,Y,m,this.listenerTree,0,l);else if(Y=this._events[i],typeof Y=="function"){switch(this.event=i,F){case 1:Y.call(this);break;case 2:Y.call(this,arguments[1]);break;case 3:Y.call(this,arguments[1],arguments[2]);break;default:for(h=new Array(F-1),y=1;y<F;y++)h[y-1]=arguments[y];Y.apply(this,h)}return!0}else Y&&(Y=Y.slice());if(Y&&Y.length){if(F>3)for(h=new Array(F-1),y=1;y<F;y++)h[y-1]=arguments[y];for(C=0,l=Y.length;C<l;C++)switch(this.event=i,F){case 1:Y[C].call(this);break;case 2:Y[C].call(this,arguments[1]);break;case 3:Y[C].call(this,arguments[1],arguments[2]);break;default:Y[C].apply(this,h)}return!0}else if(!this.ignoreErrors&&!this._all&&i==="error")throw arguments[1]instanceof Error?arguments[1]:new Error("Uncaught, unspecified 'error' event.");return!!this._all},ee.prototype.emitAsync=function(){if(!this._events&&!this._all)return!1;this._events||pe.call(this);var i=arguments[0],m=this.wildcard,I,h,l,C,y,G;if(i==="newListener"&&!this._newListener&&!this._events.newListener)return Promise.resolve([!1]);if(m&&(I=i,i!=="newListener"&&i!=="removeListener"&&typeof i=="object")){if(C=i.length,se){for(y=0;y<C;y++)if(typeof i[y]=="symbol"){h=!0;break}}h||(i=i.join(this.delimiter))}var F=[],Y=arguments.length,P;if(this._all)for(y=0,C=this._all.length;y<C;y++)switch(this.event=i,Y){case 1:F.push(this._all[y].call(this,i));break;case 2:F.push(this._all[y].call(this,i,arguments[1]));break;case 3:F.push(this._all[y].call(this,i,arguments[1],arguments[2]));break;default:F.push(this._all[y].apply(this,arguments))}if(m?(P=[],D.call(this,P,I,this.listenerTree,0)):P=this._events[i],typeof P=="function")switch(this.event=i,Y){case 1:F.push(P.call(this));break;case 2:F.push(P.call(this,arguments[1]));break;case 3:F.push(P.call(this,arguments[1],arguments[2]));break;default:for(l=new Array(Y-1),G=1;G<Y;G++)l[G-1]=arguments[G];F.push(P.apply(this,l))}else if(P&&P.length){if(P=P.slice(),Y>3)for(l=new Array(Y-1),G=1;G<Y;G++)l[G-1]=arguments[G];for(y=0,C=P.length;y<C;y++)switch(this.event=i,Y){case 1:F.push(P[y].call(this));break;case 2:F.push(P[y].call(this,arguments[1]));break;case 3:F.push(P[y].call(this,arguments[1],arguments[2]));break;default:F.push(P[y].apply(this,l))}}else if(!this.ignoreErrors&&!this._all&&i==="error")return arguments[1]instanceof Error?Promise.reject(arguments[1]):Promise.reject("Uncaught, unspecified 'error' event.");return Promise.all(F)},ee.prototype.on=function(i,m,I){return this._on(i,m,!1,I)},ee.prototype.prependListener=function(i,m,I){return this._on(i,m,!0,I)},ee.prototype.onAny=function(i){return this._onAny(i,!1)},ee.prototype.prependAny=function(i){return this._onAny(i,!0)},ee.prototype.addListener=ee.prototype.on,ee.prototype._onAny=function(i,m){if(typeof i!="function")throw new Error("onAny only accepts instances of Function");return this._all||(this._all=[]),m?this._all.unshift(i):this._all.push(i),this},ee.prototype._on=function(i,m,I,h){if(typeof i=="function")return this._onAny(i,m),this;if(typeof m!="function")throw new Error("on only accepts instances of Function");this._events||pe.call(this);var l=this,C;return h!==R&&(C=ne.call(this,i,m,h),m=C[0],l=C[1]),this._newListener&&this.emit("newListener",i,m),this.wildcard?(v.call(this,i,m,I),l):(this._events[i]?(typeof this._events[i]=="function"&&(this._events[i]=[this._events[i]]),I?this._events[i].unshift(m):this._events[i].push(m),!this._events[i].warned&&this._maxListeners>0&&this._events[i].length>this._maxListeners&&(this._events[i].warned=!0,De.call(this,this._events[i].length,i))):this._events[i]=m,l)},ee.prototype.off=function(i,m){if(typeof m!="function")throw new Error("removeListener only takes instances of Function");var I,h=[];if(this.wildcard){var l=typeof i=="string"?i.split(this.delimiter):i.slice();if(h=D.call(this,null,l,this.listenerTree,0),!h)return this}else{if(!this._events[i])return this;I=this._events[i],h.push({_listeners:I})}for(var C=0;C<h.length;C++){var y=h[C];if(I=y._listeners,U(I)){for(var G=-1,F=0,Y=I.length;F<Y;F++)if(I[F]===m||I[F].listener&&I[F].listener===m||I[F]._origin&&I[F]._origin===m){G=F;break}if(G<0)continue;return this.wildcard?y._listeners.splice(G,1):this._events[i].splice(G,1),I.length===0&&(this.wildcard?delete y._listeners:delete this._events[i]),this._removeListener&&this.emit("removeListener",i,m),this}else(I===m||I.listener&&I.listener===m||I._origin&&I._origin===m)&&(this.wildcard?delete y._listeners:delete this._events[i],this._removeListener&&this.emit("removeListener",i,m))}return this.listenerTree&&W(this.listenerTree),this},ee.prototype.offAny=function(i){var m=0,I=0,h;if(i&&this._all&&this._all.length>0){for(h=this._all,m=0,I=h.length;m<I;m++)if(i===h[m])return h.splice(m,1),this._removeListener&&this.emit("removeListenerAny",i),this}else{if(h=this._all,this._removeListener)for(m=0,I=h.length;m<I;m++)this.emit("removeListenerAny",h[m]);this._all=[]}return this},ee.prototype.removeListener=ee.prototype.off,ee.prototype.removeAllListeners=function(i){if(i===R)return!this._events||pe.call(this),this;if(this.wildcard){var m=D.call(this,null,i,this.listenerTree,0),I,h;if(!m)return this;for(h=0;h<m.length;h++)I=m[h],I._listeners=null;this.listenerTree&&W(this.listenerTree)}else this._events&&(this._events[i]=null);return this},ee.prototype.listeners=function(i){var m=this._events,I,h,l,C,y;if(i===R){if(this.wildcard)throw Error("event name required for wildcard emitter");if(!m)return[];for(I=le(m),C=I.length,l=[];C-- >0;)h=m[I[C]],typeof h=="function"?l.push(h):l.push.apply(l,h);return l}else{if(this.wildcard){if(y=this.listenerTree,!y)return[];var G=[],F=typeof i=="string"?i.split(this.delimiter):i.slice();return D.call(this,G,F,y,0),G}return m?(h=m[i],h?typeof h=="function"?[h]:h:[]):[]}},ee.prototype.eventNames=function(i){var m=this._events;return this.wildcard?J.call(this,this.listenerTree,[],null,i):m?le(m):[]},ee.prototype.listenerCount=function(i){return this.listeners(i).length},ee.prototype.hasListeners=function(i){if(this.wildcard){var m=[],I=typeof i=="string"?i.split(this.delimiter):i.slice();return D.call(this,m,I,this.listenerTree,0),m.length>0}var h=this._events,l=this._all;return!!(l&&l.length||h&&(i===R?le(h).length:h[i]))},ee.prototype.listenersAny=function(){return this._all?this._all:[]},ee.prototype.waitFor=function(i,m){var I=this,h=typeof m;return h==="number"?m={timeout:m}:h==="function"&&(m={filter:m}),m=_t(m,{timeout:0,filter:R,handleError:!1,Promise,overload:!1},{filter:Qe,Promise:ue}),Ot(m.Promise,function(l,C,y){function G(){var F=m.filter;if(!(F&&!F.apply(I,arguments)))if(I.off(i,G),m.handleError){var Y=arguments[0];Y?C(Y):l(Je.apply(null,arguments).slice(1))}else l(Je.apply(null,arguments))}y(function(){I.off(i,G)}),I._on(i,G,!1)},{timeout:m.timeout,overload:m.overload})};function de(i,m,I){I=_t(I,{Promise,timeout:0,overload:!1},{Promise:ue});var h=I.Promise;return Ot(h,function(l,C,y){var G;if(typeof i.addEventListener=="function"){G=function(){l(Je.apply(null,arguments))},y(function(){i.removeEventListener(m,G)}),i.addEventListener(m,G,{once:!0});return}var F=function(){Y&&i.removeListener("error",Y),l(Je.apply(null,arguments))},Y;m!=="error"&&(Y=function(P){i.removeListener(m,F),C(P)},i.once("error",Y)),y(function(){Y&&i.removeListener("error",Y),i.removeListener(m,F)}),i.once(m,F)},{timeout:I.timeout,overload:I.overload})}var it=ee.prototype;if(Object.defineProperties(ee,{defaultMaxListeners:{get:function(){return it._maxListeners},set:function(i){if(typeof i!="number"||i<0||Number.isNaN(i))throw TypeError("n must be a non-negative number");it._maxListeners=i},enumerable:!0},once:{value:de,writable:!0,configurable:!0}}),Object.defineProperties(it,{_maxListeners:{value:$,writable:!0,configurable:!0},_observers:{value:null,writable:!0,configurable:!0}}),typeof define=="function"&&define.amd)define(function(){return ee});else if(typeof mo=="object")po.exports=ee;else{var xe=new Function("","return this")();xe.EventEmitter2=ee}})()});var Ao=Ks((yE,Oo)=>{Oo.exports=bo()});var No=Ks((Hs,To)=>{(function(R,L){var U=L(R);if(typeof define=="function"&&define.amd)define("DeepDiff",function(){return U});else if(typeof Hs=="object"||typeof navigator=="object"&&navigator.product.match(/ReactNative/i))To.exports=U;else{var $=R.DeepDiff;U.noConflict=function(){return R.DeepDiff===U&&(R.DeepDiff=$),U},R.DeepDiff=U}})(Hs,function(R){var L=["N","E","A","D"];function U(j,D){j.super_=D,j.prototype=Object.create(D.prototype,{constructor:{value:j,enumerable:!1,writable:!0,configurable:!0}})}function $(j,D){Object.defineProperty(this,"kind",{value:j,enumerable:!0}),D&&D.length&&Object.defineProperty(this,"path",{value:D,enumerable:!0})}function z(j,D,v){z.super_.call(this,"E",j),Object.defineProperty(this,"lhs",{value:D,enumerable:!0}),Object.defineProperty(this,"rhs",{value:v,enumerable:!0})}U(z,$);function se(j,D){se.super_.call(this,"N",j),Object.defineProperty(this,"rhs",{value:D,enumerable:!0})}U(se,$);function ae(j,D){ae.super_.call(this,"D",j),Object.defineProperty(this,"lhs",{value:D,enumerable:!0})}U(ae,$);function fe(j,D,v){fe.super_.call(this,"A",j),Object.defineProperty(this,"index",{value:D,enumerable:!0}),Object.defineProperty(this,"item",{value:v,enumerable:!0})}U(fe,$);function Ae(j,D,v){var J=j.slice((v||D)+1||j.length);return j.length=D<0?j.length+D:D,j.push.apply(j,J),j}function le(j){var D=typeof j;return D!=="object"?D:j===Math?"math":j===null?"null":Array.isArray(j)?"array":Object.prototype.toString.call(j)==="[object Date]"?"date":typeof j.toString=="function"&&/^\/.*\//.test(j.toString())?"regexp":"object"}function pe(j){var D=0;if(j.length===0)return D;for(var v=0;v<j.length;v++){var J=j.charCodeAt(v);D=(D<<5)-D+J,D=D&D}return D}function Ce(j){var D=0,v=le(j);if(v==="array"){j.forEach(function(ee){D+=Ce(ee)});var J="[type: array, hash: "+D+"]";return D+pe(J)}if(v==="object"){for(var W in j)if(j.hasOwnProperty(W)){var oe="[ type: object, key: "+W+", value hash: "+Ce(j[W])+"]";D+=pe(oe)}return D}var ne="[ type: "+v+" ; value: "+j+"]";return D+pe(ne)}function De(j,D,v,J,W,oe,ne,ee){v=v||[],W=W||[],ne=ne||[];var de=W.slice(0);if(typeof oe<"u"&&oe!==null){if(J){if(typeof J=="function"&&J(de,oe))return;if(typeof J=="object"){if(J.prefilter&&J.prefilter(de,oe))return;if(J.normalize){var it=J.normalize(de,oe,j,D);it&&(j=it[0],D=it[1])}}}de.push(oe)}le(j)==="regexp"&&le(D)==="regexp"&&(j=j.toString(),D=D.toString());var xe=typeof j,i=typeof D,m,I,h,l,C=xe!=="undefined"||ne&&ne.length>0&&ne[ne.length-1].lhs&&Object.getOwnPropertyDescriptor(ne[ne.length-1].lhs,oe),y=i!=="undefined"||ne&&ne.length>0&&ne[ne.length-1].rhs&&Object.getOwnPropertyDescriptor(ne[ne.length-1].rhs,oe);if(!C&&y)v.push(new se(de,D));else if(!y&&C)v.push(new ae(de,j));else if(le(j)!==le(D))v.push(new z(de,j,D));else if(le(j)==="date"&&j-D!==0)v.push(new z(de,j,D));else if(xe==="object"&&j!==null&&D!==null){for(m=ne.length-1;m>-1;--m)if(ne[m].lhs===j){l=!0;break}if(l)j!==D&&v.push(new z(de,j,D));else{if(ne.push({lhs:j,rhs:D}),Array.isArray(j)){for(ee&&(j.sort(function(Y,P){return Ce(Y)-Ce(P)}),D.sort(function(Y,P){return Ce(Y)-Ce(P)})),m=D.length-1,I=j.length-1;m>I;)v.push(new fe(de,m,new se(void 0,D[m--])));for(;I>m;)v.push(new fe(de,I,new ae(void 0,j[I--])));for(;m>=0;--m)De(j[m],D[m],v,J,de,m,ne,ee)}else{var G=Object.keys(j),F=Object.keys(D);for(m=0;m<G.length;++m)h=G[m],l=F.indexOf(h),l>=0?(De(j[h],D[h],v,J,de,h,ne,ee),F[l]=null):De(j[h],void 0,v,J,de,h,ne,ee);for(m=0;m<F.length;++m)h=F[m],h&&De(void 0,D[h],v,J,de,h,ne,ee)}ne.length=ne.length-1}}else j!==D&&(xe==="number"&&isNaN(j)&&isNaN(D)||v.push(new z(de,j,D)))}function Je(j,D,v,J,W){var oe=[];if(De(j,D,oe,J,null,null,null,W),v)for(var ne=0;ne<oe.length;++ne)v(oe[ne]);return oe}function We(j,D,v,J,W,oe,ne){return De(j,D,v,J,W,oe,ne,!0)}function Ze(j,D,v,J){var W=J?function(ne){ne&&J.push(ne)}:void 0,oe=Je(j,D,W,v);return J||(oe.length?oe:void 0)}function _t(j,D,v,J){var W=J?function(ne){ne&&J.push(ne)}:void 0,oe=Je(j,D,W,v,!0);return J||(oe.length?oe:void 0)}function ue(j,D,v){if(v.path&&v.path.length){var J=j[D],W,oe=v.path.length-1;for(W=0;W<oe;W++)J=J[v.path[W]];switch(v.kind){case"A":ue(J[v.path[W]],v.index,v.item);break;case"D":delete J[v.path[W]];break;case"E":case"N":J[v.path[W]]=v.rhs;break}}else switch(v.kind){case"A":ue(j[D],v.index,v.item);break;case"D":j=Ae(j,D);break;case"E":case"N":j[D]=v.rhs;break}return j}function je(j,D,v){if(typeof v>"u"&&D&&~L.indexOf(D.kind)&&(v=D),j&&v&&v.kind){for(var J=j,W=-1,oe=v.path?v.path.length-1:0;++W<oe;)typeof J[v.path[W]]>"u"&&(J[v.path[W]]=typeof v.path[W+1]<"u"&&typeof v.path[W+1]=="number"?[]:{}),J=J[v.path[W]];switch(v.kind){case"A":v.path&&typeof J[v.path[W]]>"u"&&(J[v.path[W]]=[]),ue(v.path?J[v.path[W]]:J,v.index,v.item);break;case"D":delete J[v.path[W]];break;case"E":case"N":J[v.path[W]]=v.rhs;break}}}function Qe(j,D,v){if(v.path&&v.path.length){var J=j[D],W,oe=v.path.length-1;for(W=0;W<oe;W++)J=J[v.path[W]];switch(v.kind){case"A":Qe(J[v.path[W]],v.index,v.item);break;case"D":J[v.path[W]]=v.lhs;break;case"E":J[v.path[W]]=v.lhs;break;case"N":delete J[v.path[W]];break}}else switch(v.kind){case"A":Qe(j[D],v.index,v.item);break;case"D":j[D]=v.lhs;break;case"E":j[D]=v.lhs;break;case"N":j=Ae(j,D);break}return j}function lt(j,D,v){if(j&&D&&v&&v.kind){var J=j,W,oe;for(oe=v.path.length-1,W=0;W<oe;W++)typeof J[v.path[W]]>"u"&&(J[v.path[W]]={}),J=J[v.path[W]];switch(v.kind){case"A":Qe(J[v.path[W]],v.index,v.item);break;case"D":J[v.path[W]]=v.lhs;break;case"E":J[v.path[W]]=v.lhs;break;case"N":delete J[v.path[W]];break}}}function Ot(j,D,v){if(j&&D){var J=function(W){(!v||v(j,D,W))&&je(j,D,W)};Je(j,D,J)}}return Object.defineProperties(Ze,{diff:{value:Ze,enumerable:!0},orderIndependentDiff:{value:_t,enumerable:!0},observableDiff:{value:Je,enumerable:!0},orderIndependentObservableDiff:{value:We,enumerable:!0},orderIndepHash:{value:Ce,enumerable:!0},applyDiff:{value:Ot,enumerable:!0},applyChange:{value:je,enumerable:!0},revertChange:{value:lt,enumerable:!0},isConflict:{value:function(){return typeof $conflict<"u"},enumerable:!0}}),Ze.DeepDiff=Ze,R&&(R.DeepDiff=Ze),Ze})});var yu=_o(Ao(),1),Mu=_o(No(),1);var Bl="as",Dl="=",yl="break",Ml="else",jl="enum",Fl="export",wl="if",Yl="import",gl="->",Gl="is",Vl="loop",Kl="mut",Hl="native",$l="object",zl="fn",Xl="return",Jl="self",Wl="template",Zl=Object.freeze({ALIAS:Bl,ASSIGN:Dl,BREAK:yl,ELSE:Ml,ENUMERATION:jl,EXPORT:Fl,IF:wl,IMPORT:Yl,INTO:gl,IS:Gl,LOOP:Vl,MUTABLE:Kl,NATIVE:Hl,OBJECT:$l,PROCEDURE:zl,RETURN:Xl,SELF:Jl,TEMPLATE:Wl}),Io=Zl;var Ql="assign",ql="array_assignment",xl="branch-match",ei="branch-default",ti="condition",si="loop",ni="data",oi="generics",ri="enumeration",ci="expression",ai="instance",ui="Link",li="local",ii="object",fi="procedure",Ei="return",_i="select",mi="member",pi="store",bi="break",Oi="literal",Ai="array_access",Ti="valueLink",Ni="linkValue",di="self",Ii="procedure-call",hi="Maybe",Si="native",ki="move",Pi="String",Li="Array",Ri="import",Ci="library",vi="constructor",Ui="destructor",Bi="free",Di="block-end",yi="default-block",Mi="continue",ji="branch",Fi="statement",wi="draw",Yi="size",gi="concatenation",Gi="foreach",Vi="while",Ki="while-condition",Hi="foreach-condition",$i="foreach-end",zi="I32",Xi=Object.freeze({TYPES_ASSIGN:Ql,TYPES_ARRAY:Li,TYPES_ARRAY_ASSIGNMENT:ql,TYPES_BRANCH_MATCH:xl,TYPES_BRANCH_DEFAULT:ei,TYPES_CONDITION:ti,TYPES_LOOP:si,TYPES_FOREACH_END:$i,TYPES_WHILE_CONDITION:Ki,TYPES_FOREACH_CONDITION:Hi,TYPES_DATA:ni,TYPES_GENERICS:oi,TYPES_ENUMERATION:ri,TYPES_EXPRESSION:ci,TYPES_INSTANCE:ai,TYPES_LINK:ui,TYPES_IMPORT:Ri,TYPES_LOCAL:li,TYPES_OBJECT:ii,TYPES_PROCEDURE:fi,TYPES_RETURN:Ei,TYPES_SELECT:_i,TYPES_MEMBER:mi,TYPES_STORE:pi,TYPES_BREAK:bi,TYPES_LITERAL:Oi,TYPES_ARRAY_ACCESS:Ai,TYPES_LINK_TO:Ti,TYPES_VALUE_AT:Ni,TYPES_SELF:di,TYPES_LIBRARY:Ci,TYPES_DROP:Ii,TYPES_MAYBE:hi,TYPES_NATIVE:Si,TYPES_MOVE:ki,TYPES_STRING:Pi,TYPES_CONSTRUCTOR:vi,TYPES_FREE:Bi,TYPES_DEFAULT_BLOCK:yi,TYPES_BLOCK_END:Di,TYPES_CONTINUE:Mi,TYPES_BRANCH:ji,TYPES_STATEMENT:Fi,TYPES_DESTRUCTOR:Ui,TYPES_DRAW:wi,TYPES_SIZE:Yi,TYPES_CONCAT:gi,TYPES_FOREACH:Gi,TYPES_WHILE:Vi,TYPES_I32:zi}),$s=Xi;var Ji=Object.freeze({COLON:58,COMMA:44,DIGIT_ZERO:48,DIGIT_NINE:57,DOT:46,HASHTAG:35,HORIZONTAL_TAB:9,HYPHEN_MINUS:45,LEFT_CURLY_BRACKET:123,LEFT_PARENTHESIS:40,LEFT_SQUARE_BRACKET:91,LINE_BREAK:10,NULL:0,PLUS_SIGN:43,RIGHT_CURLY_BRACKET:125,RIGHT_PARENTHESIS:41,RIGHT_SQUARE_BRACKET:93,SEMICOLON:59,SPACE:32}),ho=Ji;var Wi=Object.freeze([]),Zi=Object.freeze({}),tt="",Qi="	",qi=`
`,xi="UTF-8",So=$s,ef=Object.freeze({EMPTY_ARRAY:Wi,EMPTY_OBJECT:Zi,EMPTY_STRING:tt,HORIZONTAL_TAB:Qi,LINE_BREAK:qi,UNICODE_TEXT:xi,Codes:ho,Keys:Io,Types:$s}),ko=ef;function O(R,L=[],U=""){let $=L.map((se,ae)=>({name:`operand${ae+1}`,data:{type:"data",name:se,path:"Flogram"}})),z={type:"native",name:R,path:"Flogram",description:{inputs:$,outputs:U&&L.length<=0?null:[{name:"result",data:{type:"data",name:U||(L.length>0?L[0]:""),path:"Flogram"}}]}};return Object.freeze(z)}var tf=Object.freeze({"+":[O("+",["FP64","FP64"]),O("+",["U64","U64"]),O("+",["I64","I64"]),O("+",["FP32","FP32"]),O("+",["U32","U32"]),O("+",["I32","I32"]),O("+",["U16","U16"]),O("+",["I16","I16"]),O("+",["U8","U8"]),O("+",["I8","I8"]),O("+",["any","any"])],"-":[O("-",["FP64","FP64"]),O("-",["U64","U64"]),O("-",["I64","I64"]),O("-",["FP32","FP32"]),O("-",["U32","U32"]),O("-",["I32","I32"]),O("-",["U16","U16"]),O("-",["I16","I16"]),O("-",["U8","U8"]),O("-",["I8","I8"]),O("-",["any","any"]),O("-",["FP64"]),O("-",["I64"]),O("-",["FP32"]),O("-",["I32"]),O("-",["I16"]),O("-",["I8"]),O("-",["any"])],"*":[O("*",["FP64","FP64"]),O("*",["U64","U64"]),O("*",["I64","I64"]),O("*",["FP32","FP32"]),O("*",["U32","U32"]),O("*",["I32","I32"]),O("*",["U16","U16"]),O("*",["I16","I16"]),O("*",["U8","U8"]),O("*",["I8","I8"]),O("*",["any","any"])],"/":[O("/",["FP64","FP64"]),O("/",["U64","U64"]),O("/",["I64","I64"]),O("/",["FP32","FP32"]),O("/",["U32","U32"]),O("/",["I32","I32"]),O("/",["U16","U16"]),O("/",["I16","I16"]),O("/",["U8","U8"]),O("/",["I8","I8"]),O("/",["any","any"])],"%":[O("%",["I64","I64"]),O("%",["U64","U64"]),O("%",["I32","I32"]),O("%",["U32","U32"]),O("%",["I16","I16"]),O("%",["U16","U16"]),O("%",["I8","I8"]),O("%",["U8","U8"]),O("%",["any","any"])],"!=":[O("!=",["FP64","FP64"],"Bool"),O("!=",["U64","U64"],"Bool"),O("!=",["I64","I64"],"Bool"),O("!=",["FP32","FP32"],"Bool"),O("!=",["U32","U32"],"Bool"),O("!=",["I32","I32"],"Bool"),O("!=",["U16","U16"],"Bool"),O("!=",["I16","I16"],"Bool"),O("!=",["U8","U8"],"Bool"),O("!=",["I8","I8"],"Bool"),O("!=",["any","any"],"any")],"==":[O("==",["FP64","FP64"],"Bool"),O("==",["U64","U64"],"Bool"),O("==",["I64","I64"],"Bool"),O("==",["FP32","FP32"],"Bool"),O("==",["U32","U32"],"Bool"),O("==",["I32","I32"],"Bool"),O("==",["U16","U16"],"Bool"),O("==",["I16","I16"],"Bool"),O("==",["U8","U8"],"Bool"),O("==",["I8","I8"],"Bool"),O("==",["any","any"],"any")],">":[O(">",["FP64","FP64"],"Bool"),O(">",["U64","U64"],"Bool"),O(">",["I64","I64"],"Bool"),O(">",["FP32","FP32"],"Bool"),O(">",["U32","U32"],"Bool"),O(">",["I32","I32"],"Bool"),O(">",["U16","U16"],"Bool"),O(">",["I16","I16"],"Bool"),O(">",["U8","U8"],"Bool"),O(">",["I8","I8"],"Bool"),O(">",["any","any"],"any")],"<":[O("<",["FP64","FP64"],"Bool"),O("<",["U64","U64"],"Bool"),O("<",["I64","I64"],"Bool"),O("<",["FP32","FP32"],"Bool"),O("<",["U32","U32"],"Bool"),O("<",["I32","I32"],"Bool"),O("<",["U16","U16"],"Bool"),O("<",["I16","I16"],"Bool"),O("<",["U8","U8"],"Bool"),O("<",["I8","I8"],"Bool"),O("<",["any","any"],"any")],">=":[O(">=",["FP64","FP64"],"Bool"),O(">=",["U64","U64"],"Bool"),O(">=",["I64","I64"],"Bool"),O(">=",["FP32","FP32"],"Bool"),O(">=",["U32","U32"],"Bool"),O(">=",["I32","I32"],"Bool"),O(">=",["U16","U16"],"Bool"),O(">=",["I16","I16"],"Bool"),O(">=",["U8","U8"],"Bool"),O(">=",["I8","I8"],"Bool"),O(">=",["any","any"],"any")],"<=":[O("<=",["FP64","FP64"],"Bool"),O("<=",["U64","U64"],"Bool"),O("<=",["I64","I64"],"Bool"),O("<=",["FP32","FP32"],"Bool"),O("<=",["U32","U32"],"Bool"),O("<=",["I32","I32"],"Bool"),O("<=",["U16","U16"],"Bool"),O("<=",["I16","I16"],"Bool"),O("<=",["U8","U8"],"Bool"),O("<=",["I8","I8"],"Bool"),O("<=",["any","any"],"any")],"&":[O("&",["Bool","Bool"],"Bool"),O("&",["any","any"],"any")],"^":[O("^",["Bool","Bool"],"Bool"),O("^",["any","any"],"any")],"|":[O("|",["Bool","Bool"],"Bool"),O("|",["any","any"],"any")],not:[O("not",["Bool"],"Bool"),O("not",["any"],"any")],I32:[O("I32",["FP64"],"I32"),O("I32",["U64"],"I32"),O("I32",["I64"],"I32"),O("I32",["FP32"],"I32"),O("I32",["U32"],"I32"),O("I32",["I32"],"I32"),O("I32",["U16"],"I32"),O("I32",["I16"],"I32"),O("I32",["U8"],"I32"),O("I32",["I8"],"I32"),O("I32",["any"],"any")],U32:[O("U32",["FP64"],"U32"),O("U32",["U64"],"U32"),O("U32",["I64"],"U32"),O("U32",["FP32"],"U32"),O("U32",["U32"],"U32"),O("U32",["I32"],"U32"),O("U32",["U16"],"U32"),O("U32",["I16"],"U32"),O("U32",["U8"],"U32"),O("U32",["I8"],"U32"),O("U32",["any"],"any")],I64:[O("I64",["FP64"],"I64"),O("I64",["U64"],"I64"),O("I64",["I64"],"I64"),O("I64",["FP32"],"I64"),O("I64",["U32"],"I64"),O("I64",["I32"],"I64"),O("I64",["U16"],"I64"),O("I64",["I16"],"I64"),O("I64",["U8"],"I64"),O("I64",["I8"],"I64"),O("I64",["any"],"any")],U64:[O("U64",["FP64"],"U64"),O("U64",["U64"],"U64"),O("U64",["I64"],"U64"),O("U64",["FP32"],"U64"),O("U64",["U32"],"U64"),O("U64",["I32"],"U64"),O("U64",["U16"],"U64"),O("U64",["I16"],"U64"),O("U64",["U8"],"U64"),O("U64",["I8"],"U64"),O("U64",["any"],"any")],FP32:[O("FP32",["FP64"],"FP32"),O("FP32",["U64"],"FP32"),O("FP32",["I64"],"FP32"),O("FP32",["FP32"],"FP32"),O("FP32",["U32"],"FP32"),O("FP32",["I32"],"FP32"),O("FP32",["U16"],"FP32"),O("FP32",["I16"],"FP32"),O("FP32",["U8"],"FP32"),O("FP32",["I8"],"FP32"),O("FP32",["any"],"any")],FP64:[O("FP64",["FP64"],"FP64"),O("FP64",["U64"],"FP64"),O("FP64",["I64"],"FP64"),O("FP64",["FP32"],"FP64"),O("FP64",["U32"],"FP64"),O("FP64",["I32"],"FP64"),O("FP64",["U16"],"FP64"),O("FP64",["I16"],"FP64"),O("FP64",["U8"],"FP64"),O("FP64",["I8"],"FP64"),O("FP64",["any"],"any")]}),rs=tf;var Po=Object.freeze(["+","-","*","/","%",">",">=","<","<=","!=","&","|","^","not","I32","U32","I64","U64","FP64","FP32"]);var sf=Object.freeze(["FP64","U64","I64","FP32","U32","I32","U16","I16","U8","I8","Bool","Char","Array","String","Link","Maybe"]),Nt=sf;var{EMPTY_STRING:nf,UNICODE_TEXT:Ws}=ko,of=44,rf=48,cf=57,af=46,uf=45,lf=43,ff=65,Ef=90,_f=-1,mf=1,pf=new TextDecoder(Ws),bf=new TextEncoder,Of=(R,L,U=0,$=R.length|0,z=0,se=L.length|0)=>{for(z=z|0,U=U|0,se=se|0,$=$|0;;){let ae=U>=$,fe=z>=se;if(ae||fe)break;let le=R[U],pe=L[z];if(U=U+1|0,z=z+1|0,le<pe)return _f;if(le>pe)return mf}return 0},Zs=(R,L,U=0,$=R.length|0,z=0,se=L.length|0)=>{for(z=z|0,U=U|0,se=se|0,$=$|0;;){let ae=z>=se,fe=U>=$;if(ae||fe)break;L[z]=R[U],z=z+1|0,U=U+1|0}},Qs=(R,L,U=0,$=R.length|0,z=0,se=L.length|0)=>{U=U|0,z=z|0,$=$|0,se=se|0;let ae=$-U|0,fe=se-z|0;if(ae!==fe)return!1;for(;;){let Ae=U>=$,le=z>=se;if(Ae||le)break;let Ce=R[U],De=L[z];if(U=U+1|0,z=z+1|0,Ce!==De)return!1}return!0},Af=R=>{R=R>>>0;let L=0,U=0;for(;U=(U<<1|1)>>>0,!(U>R);)L=L+1|0;return L},Co=Object.freeze([48,49,50,51,52,53,54,55,56,57,97,98,99,100,101,102]),Js=(R,L,U,$)=>{for(R=R>>>0,$=$??L.length|0,U=U|0,$=$|0;R>0&&$>U;)$=$-1|0,L[$]=Co[R&15],R=R>>>4},qs=(R,L,U,$)=>{let z=U|0,se=U+$|0;if($===0)return!1;let ae=L[z];for((ae===lf||ae===uf)&&(z=z+1|0);z<se;){let fe=L[z];if(z=z+1|0,!(rf<=fe&&fe<=cf||(af===fe||of===fe)))return!1}return!0},xs=R=>{let L=R>=ff,U=R<=Ef;return L&&U},as=128,us=127,vo=-1,Dt=64,en=R=>{R=R|0;let L=[];for(;;){let U=R&us;R=R>>7;let $=R===0,z=(U&Dt)===0,se=$&&z,ae=R===-1,fe=(U&Dt)!==0;if(se||ae&&fe){L.push(U);break}U=U|as,L.push(U)}return L},Tf=R=>{let L=[],U=!0;for(;U;){let $=R&us;R>>=7,R===0&&!($&Dt)||R===-1&&$&Dt?U=!1:$|=as,L.push($)}return L},Uo=(R,L)=>{L=L|0;let U=0,$=0;for(;;){let z=R[L]|0;L=L+1|0;let se=(z&us)<<$;if($=$+7|0,U=U|se,(z&as)===0){let fe=(z&Dt)!==0,Ae=$<32;if(fe&&Ae){let pe=vo<<$;U=U|pe}break}}return U},Nf=(R,L)=>{L=L|0;let U=0,$=0;for(;;){let z=R[L]|0;L=L+1|0;let se=(z&us)<<$;if($=$+7|0,U=U|se,!(z&as)){if(z&Dt){let ae=vo<<$;U=U|ae}break}}return U},d=R=>pf.decode(R),ce=R=>bf.encode(R),df=(R=nf)=>{let L=R.length|0,U=en(L),$=Buffer.from(R,Ws);return Object.freeze([...U,...$])},If=(R,L)=>{L=L|0;let U=Uo(R,L),$=en(U).length;return L=L+$|0,R.subarray(L,L+U|0).toString(Ws)},hf=58,Sf=46,Wt=32,zs=48,kf=67,dt=new Uint8Array(kf),Lo=dt.subarray(0,8),cs=dt.subarray(10,49),Ro=dt.subarray(51,68),Xs=16,Pf=2;dt[8]=hf;dt[9]=Wt;dt[49]=Wt;dt[50]=Wt;var Lf=(R,L)=>{L=L??console.log;let U=32,$=126,z=R.length|0,se=0;for(;z>0;){Lo.fill(zs),Js(se,Lo),cs.fill(Wt),Ro.fill(Wt);let ae=z>=Xs?Xs:z;z=z-Xs|0;let fe=0,Ae=0;for(let pe=1;pe<=ae;pe=pe+1|0){let Ce=R[se]&255;cs[fe+0|0]=zs,cs[fe+1|0]=zs,Js(Ce,cs,fe,fe+2|0);let De=Sf;U<=Ce&&Ce<=$&&(De=Ce),Ro[Ae]=De,se=se+1|0,fe=fe+2|0,Ae=Ae+1|0,pe%Pf===0&&(fe=fe+1|0)}let le=String.fromCodePoint(...dt);L(le)}},Rf=function*(R,L){let U=R.length|0,$=L.length|0,z=0;for(;z<U&&z<$;){let se=R[z],ae=L[z];yield[se,ae],z=z+1|0}},Cf=function*(R,L,U){let $=R.length|0,z=L.length|0,se=U.length|0,ae=0;for(;ae<$&&ae<z&&ae<se;){let fe=R[ae],Ae=L[ae],le=U[ae];yield[fe,Ae,le],ae=ae+1|0}},zE=Object.freeze({ARRAY_COMPARE:Of,ARRAY_COPY:Zs,ARRAY_EQUAL:Qs,BIT_DEPTH:Af,HEX_DIGITS:Co,HEX_ENCODE:Js,IS_NUMBER:qs,IS_UPPERCASE:xs,LEB128_DECODE:Uo,LEB128_DECODE_SIGNED:Nf,LEB128_ENCODE:en,LEB128_ENCODE_SIGNED:Tf,UTF8_DECODE:d,UTF8_ENCODE:ce,WASM_STRING_ENCODE:df,WASM_STRING_DECODE:If,XXD_DUMP_HEX:Lf,ZIP2:Rf,ZIP3:Cf});var{TYPES_ASSIGN:ls,TYPES_ARRAY:Me,TYPES_ARRAY_ASSIGNMENT:vf,TYPES_BRANCH_MATCH:Bo,TYPES_BRANCH_DEFAULT:Uf,TYPES_CONDITION:Do,TYPES_LOOP:yo,TYPES_DATA:ve,TYPES_GENERICS:is,TYPES_ENUMERATION:yt,TYPES_EXPRESSION:Mt,TYPES_IMPORT:Bf,TYPES_INSTANCE:WE,TYPES_LIBRARY:Df,TYPES_LINK:Mo,TYPES_LOCAL:ot,TYPES_OBJECT:Ve,TYPES_PROCEDURE:st,TYPES_RETURN:fs,TYPES_SELECT:tn,TYPES_MEMBER:sn,TYPES_NATIVE:yf,TYPES_STORE:jo,TYPES_BREAK:Mf,TYPES_LITERAL:Ue,TYPES_ARRAY_ACCESS:Es,TYPES_LINK_TO:kt,TYPES_VALUE_AT:Et,TYPES_SELF:rt,TYPES_DROP:Fo,TYPES_MAYBE:wo,TYPES_MOVE:nn,TYPES_STRING:Pt,TYPES_CONSTRUCTOR:_s,TYPES_DESTRUCTOR:Yo,TYPES_FREE:jf,TYPES_BLOCK_END:ZE,TYPES_STATEMENT:QE,TYPES_DRAW:Ff,TYPES_SIZE:on,TYPES_CONCAT:jt,TYPES_FOREACH:go,TYPES_WHILE:Go,TYPES_I32:ct}=So,X=Qs,rn=ce("="),wf=ce("enum"),Yf=ce("loop"),gf=ce("break"),Gf=ce("if"),Vf=ce("else"),Vo=ce("is"),Ko=ce("->"),Ft=ce(`
`),Ho=ce("object"),wt=ce("pass"),$o=ce("fn"),Kf=ce("return"),zo=ce("size"),Xo=ce("at"),ms=ce(Me),It=ce("Link!!"),Lt=ce("Link"),ps=ce("LinkSmart"),Rt=ce("mut"),Jo=ce("self"),Wo=ce("nocopy"),Hf=ce("move"),$f=ce("size"),zf=ce("import"),Xf=ce("export"),bs=ce("Maybe"),Jf=ce("NONE"),Wf=ce("SOME"),Zo=ce("free"),Zf=ce("free!!"),Qf=ce("foreach"),s_=ce("for"),qf=ce("while"),xf=ce("in"),eE=ce("at"),we=58,Os=61,ge=44,qe=46,Ke=123,he=40,Oe=10,tE=35,nt=125,Se=41,at=91,Zt=93,sE=39,Yt=34,nE=64,cn=47,an=1,Qo=2,un=3,zt="done",Re="fail",oE={EVENT_DONE:zt,EVENT_FAIL:Re},ju=1,Fu=2,wu=3,Yu=4,gu=5,Gu=6,Vu=7,Ku=8,Hu=9,$u=10,zu=11,Xu=12,rE=13,cE=14,aE=15,Ju=16,uE=99,He={FAIL_UNRESOLVED_NAME:R=>`Unresolved name '${R}'. The name '${R}' does not exist in the current context. Please check the spelling and scope of your identifiers.`,FAIL_UNEXPECTED_TOKEN:(R,L)=>`Unexpected token '${R}' at position ${L}. Please check the syntax.`,FAIL_INDENTATION_MISMATCH:R=>`Indentation mismatch on line ${R}. The code on this line does not align with the expected indentation. Check your indentation for inconsistencies.`,FAIL_INDENTATION_NO_INCREASE:R=>`Indentation error on line ${R}. Expected an increase in indentation but found none. Check your indentation.`,FAIL_DUPLICATE_DATA:R=>`Duplicate data '${R}' found. Ensure each piece of data is unique.`,FAIL_DUPLICATE_OBJECT_MEMBER:(R,L)=>`Duplicate member '${R}' in object '${L}'. Each member in an object must have a unique name.`,FAIL_INVALID_IDENTIFIER:R=>`Invalid identifier '${R}'. The name '${R}' is not a valid identifier. Ensure your identifiers adhere to the language's naming rules.`,FAIL_RETURN_LENGTH_MISMATCH:(R,L)=>`Return length mismatch. Expected '${R}' value(s) but received '${L}'. Ensure the number of return values matches the expected count.`,FAIL_UNRESOLVED_OBJECT_MEMBER:(R,L)=>`Unresolved member '${R}' of object '${L}'. The member '${R}' does not exist on the object '${L}'`,FAIL_UNKNOWN_PROCEDURE_NAME:R=>`Call to undefined procedure '${R}'. Please ensure that the procedure is defined before calling it.`,FAIL_IMMUTABLE_ASSIGNMENT:R=>`Assignment to an immutable variable '${R}'. You are attempting to assign a new value to a variable which was declared as immutable and cannot be changed.`,FAIL_RESERVED_KEYWORD_USAGE:R=>`Reserved keyword '${R}' used as an identifier. The keyword '${R}' is reserved by the language and cannot be used as an identifier. Please choose a different name.`,FAIL_INPUT_TYPE_MISMATCH:(R,L)=>`Type Mismatch at line ${R}. Nature procedures expect all parameters to be of same type. Provided: ${L}.`,FAIL_UNSUPPORTED_TYPE:R=>`Unsupported type found. Type '${R}' was not defined in this context and isn't a native to Flogram. Please check your code and language supported types.`,FAIL_UNALLOWED_COPY:R=>`Copy operation not allowed. The object '${R}' has been defined as uncopyable in your code, and therefore, the copy operation you're attempting is not allowed.`,FAIL_ASSIGNMENT_TYPE_MISMATCH:(R,L)=>`Assignment type mismatch. Type '${L}' assigned to '${R}'.`},lE=Object.freeze({FAIL_UNRESOLVED_NAME:ju,FAIL_UNEXPECTED_TOKEN:Fu,FAIL_INDENTATION_MISMATCH:wu,FAIL_INDENTATION_NO_INCREASE:Yu,FAIL_DUPLICATE_DATA:gu,FAIL_DUPLICATE_OBJECT_MEMBER:Gu,FAIL_INVALID_IDENTIFIER:Vu,FAIL_RETURN_LENGTH_MISMATCH:Ku,FAIL_UNRESOLVED_OBJECT_MEMBER:Hu,FAIL_UNKNOWN_PROCEDURE_NAME:$u,FAIL_IMMUTABLE_ASSIGNMENT:zu,FAIL_RESERVED_KEYWORD_USAGE:Xu,FAIL_ASSIGNMENT_TYPE_MISMATCH:Ju}),iE=new Set(["fn","object","pass","enum"]),qo=new Set(["==","!=",">",">=","<","<=","!","&","|"]),Ye=(R,L,U,$)=>{if($===1){let ue=L[U],je=ue&191,Qe=ue&223,lt=Qe^93,Ot=Qe^91,j=ue&254,v=ue&254^40,W=ue&253^44,ne=ue&254^58;return je===0||(lt===0||Ot===0)||v===0||W===0||ne===0||ue===Oe}let Ze=L.subarray(U,U+$|0),_t=d(Ze);return!1},fE=(R,L,U,$)=>{let z=L.subarray(U,U+$|0),se=d(z);return iE.has(se)||Nt.includes(se)},EE=512,co=1,Wu=2,Ys=3,ao=4,Zu=5,Qu=6,qu=7,xu=8,el=9,_E=10,mE=11,pE=12,bE=13,OE=14,AE=15,TE=16,NE=17,dE=18,ut=Object.freeze([co]),gt=Object.freeze([Wu]),Ct=Object.freeze([Ys]),ln=Object.freeze([Ys,ao]),xo=Object.freeze([Zu]),IE=Object.freeze([co,Qu]),hE=Object.freeze([qu]),$e=Object.freeze([ao,xu]),Ge=Object.freeze([el]),SE=Object.freeze([_E]),Gt=Object.freeze([mE]),kE=Object.freeze([Ys,el]),Qt=Object.freeze([pE]),Vt=Object.freeze([bE]),fn=Object.freeze([OE]),er=Object.freeze([AE]),tr=Object.freeze([TE]),As=Object.freeze([NE]),En=Object.freeze([dE]),PE=Object.freeze({REASON_COLON_OPENS_SCOPE:co,REASON_LINE_BREAK_BEFORE_OPEN_SCOPE:Wu,REASON_CLOSING_LINE_BREAK:Ys,REASON_SEQUENCE_SEPARATOR_COMMA:ao,REASON_INTO_BETWEEN_INPUTS_OUTPUTS:Zu,REASON_IS_OPENS_CONDITION_BRANCH_MATCH:Qu,REASON_OPEN_STATEMENT_WITH_KEYWORD:qu,REASON_RIGHT_PARENTHESIS_CLOSES_LIST:xu}),ke=1,sr=2,qt=3,nr=4,_n=5,or=6,ye=7,vt=8,Be=9,xt=10,Kt=11,rr=12,cr=13,es=1,ar=2,Le=3,mn=4,ur=5,lr=6,ir=7,fr=1,Er=2,_r=3,mr=4,pr=5,pn=6,br=7,Or=8,Ar=9,Tr=10,Nr=11,dr=12,Ir=13,bn=14,ts=1,hr=2,Ts=3,Sr=4,On=5,kr=6,Pr=7,ss=1,Lr=2,Ns=3,Rr=4,Cr=6,vr=1,Ur=2,Br=3,Dr=4,yr=5,Mr=6,An=7,jr=8,Fr=9,ds=10,wr=11,Yr=12,gr=13,Gr=14,Vr=15,Kr=16,Hr=17,$r=1,zr=2,Xr=1,Jr=2,LE=3;var Wr=7,Tn=8,Zr=9,Is=1,hs=2,Ss=3,ks=4,Ht=5,Ps=6,Ls=7,$t=8,Rs=9,Cs=10,vs=11,ht=1,Qr=2,qr=3,Nn=4,xr=5,ec=6,tc=7,dn=8,sc=9,nc=10,oc=11,rc=12,cc=13,ac=14,In=15;var uc=17,hn=18,Sn=19,lc=20,ic=21,kn=22,fc=23,Ec=24,Ut=25,Us=26,_c=27,mc=28,pc=29,bc=30,Oc=31,Ac=32,Tc=33,Nc=34,dc=35,Ic=36,hc=37,Sc=38,kc=39,Pn=40,Ln=41,Pc=42,Lc=43,Rc=44,Rn=45,Cc=46,vc=47,Uc=48,Bc=49,Cn=50,Dc=51,yc=52,vn=53,Un=54,Mc=55,jc=56,Fc=57,wc=58,Bn=59,Yc=60,gc=61,Gc=62,Vc=63,Kc=64,Hc=65,$c=66,zc=67,Xc=68,Jc=69,Dn=70,Wc=71,Zc=72,Qc=73,yn=74,qc=75,xc=76,ea=77,ta=78,bt=1,sa=2,na=3,oa=4,Mn=5,ra=6,Bs=1,ca=2,aa=3,ua=4,la=5,St=6,ia=7,jn=8,Ds=9,Fn=10,ys=11,fa=12,Ea=13,wn=14,Yn=15,gn=16,_a=17,ma=18,pa=19,Gn=20,Vn=21,ba=22,Kn=23,Oa=24,Aa=25,Ta=26,Hn=27,Na=28,da=29,$n=30,Ia=31,zn=32,ha=33,Sa=34,ka=35,Pa=36,La=37,Xn=38,Jn=39,Ra=40,Ca=41,va=42,Ua=43,Ba=44,Wn=45,Zn=46,Da=47,Ms=48,ya=49,Ma=50,ja=51,Fa=52,wa=53,Ya=54,ga=55,Ga=56,Va=57,Ka=58,Ha=59,$a=60,za=61,Xa=62,Ja=63,Qn=64,Wa=65,qn=66,Za=67,js=68,Fs=69,xn=70,Qa=71,qa=72,xa=73,eu=74,tu=75,su=76,nu=77,ou=78,ru=79,cu=80,au=81,uu=82,lu=83,iu=84,eo=85,fu=86,Eu=87,_u=88;var to=1,mu=2,pu=3,bu=4,Ou=5,Au=6,Tu=7,Nu=8,du=9,Iu=10,so=11,hu=12,Su=13,ku=14,Pu=15,no=16,Lu=17,Ru=18,Cu=19,vu=20,Ie="Flogram",Uu="0",Bu="any",oo="data",Du="code",ro=R=>["TRUE","FALSE"].includes(R),ws=!1,tl=R=>{let L=[],U=[],$=[],z={name:"draw",type:"procedure",description:{inputs:[{name:"a",data:{type:"data",name:ct,path:"Flogram"}}],locals:[],outputs:[]}},se=Object.freeze({data:L,code:U,exports:$}),ae=new Uint8Array(EE),fe=[],Ae=0,le=(c,n,e,f)=>{let t=Object.freeze({position:c,length:f});Zs(n,ae,e,e+f|0,Ae,Ae+f|0),fe.push(t),Ae=Ae+f|0},pe=()=>{Ae=0;let c=ae,n=fe,e=0;for(;n.length>0;){let f=n.shift(),{length:t,position:s}=f;Jt(s,c,e,t),e=e+t|0}},Ce=()=>{let c=new Date,n=c.getHours().toString().padStart(2,"0"),e=c.getMinutes().toString().padStart(2,"0"),f=c.getSeconds().toString().padStart(2,"0"),t=c.getMilliseconds().toString().padStart(3,"0");return`${n}_${e}_${f}_${t}`},De=(c,n,e,f)=>{let{description:t}=c,{members:s}=t,o=s.find(E=>E.name===n[e]),u=L.find(E=>E.name===o.data.name);return u.type===Ve&&e<n.length-1?De(u,n,e+1,f):o},Je=c=>{let n=Number(c);if(isNaN(n))return"";if(Number.isInteger(n)){if(n>=-Math.pow(2,31)&&n<Math.pow(2,31))return ct;if(n>=-Math.pow(2,63)&&n<Math.pow(2,63))return"I64"}else if(typeof n=="number")return c.replace(".","").length<=7?"FP32":"FP64"},We=c=>{switch(c.type){case"select":return c.value.name;case"store":case"linkValue":return We(c.link);case"valueLink":return We(c.value)}return c.name},Ze=(c,n)=>{let e=rs[c];if(e){let f=e.find(t=>t.description&&Array.isArray(t.description.inputs)?t.description.inputs.length!==n.length?!1:t.description.inputs.every((s,o)=>s.data.name===n[o].data.name):!1);if(f)return f;b=A|0,p=position-T|0,Xt(c);return}else{b=A|0,p=position-T|0,io(c);return}},_t=c=>{let n=r.procedure.description.inputs.find(e=>e.name===c)||r.procedure.description.locals.find(e=>e.name===c);if(n){let e=L.find(f=>f.type===is&&f.name===n.data.name);if(e)return{data:e}}return n},ue=(c,n=!1)=>{let e;switch(c.type){case tn:{let f=r.stack.get(c.value.name||c.value.link,c.value.value);if(f){let t=L.find(N=>N.name===f.name),{description:s}=t,{members:o}=s,u=0,E=o.find(N=>N.name===c.trail[u]),_=L.find(N=>N.name===E.data.name);if(_.type===Ve&&u<c.trail.length-1)e={data:De(_,c.trail,u+1,n)?.data};else{if(E.data.freed){b=A|0,p=position-T|0,re(`Attempted to use '${c.trail.join(".")}', which has been freed. Ensure links are valid before use.`);return}if(n){let N=L.indexOf(t),S=JSON.parse(JSON.stringify(t)),k=t.description.members.indexOf(E);k>=0&&(S.description.members[k].data.freed=!0,L.splice(N,1,S))}e=E}}break}case Et:{e=ue(c.link);break}case nn:case kt:{e=ue(c.value);break}case jt:{e={data:{type:ve,name:Pt,path:Ie}};break}case on:{e={data:{type:ve,name:ct,path:Ie}};break}case Es:{e={data:r.stack.get(c.array.name)};break}case sn:{if(c.trail.length>0){let f=L.find(t=>{if(t.description&&t.description.members)return t.description.members.find(s=>s.name===c.trail[0])});if(f){let{description:t}=f,{members:s}=t,o=0,u=s.find(_=>_.name===c.trail[o]),E=L.find(_=>_.name===u.data.name);E.type===Ve&&o<c.trail.length-1?e={data:De(E,c.trail,o+1,n).data}:e={data:u.data}}else b=A|0,p=0,mt(c.trail[0],`${rt}(current object in definition)`)}else e=r.stack.get(c.trail[0]);break}case Mt:{let f=s=>U.find(o=>o.type===st&&o.name===s.name)?.description.outputs[0],t=(s,o)=>{let u;for(let E=0;o&&E<=s.name.length-2;E++)o=r.stack.get(s.name[E]),o&&(u=L.find(_=>_.type===Ve&&_.name===o.name));return u?.description.members?.find(E=>E.name===s.name[s.name.length-1])?.description.outputs[0]};if(c.path!==Ie){if(e=f(c),typeof c.name=="object"){let s=r.stack.get(c.name[0]);e=t(c,s);let o=c.name.length;c.name[o-1]===_s&&(e={data:s})}}else if(qo.has(c.name))e={data:{type:ve,name:"Bool",path:Ie}},Fe(e.data.name);else{let s=c.inputs.map(u=>ue(u)),o=U.find(u=>u.description&&Array.isArray(u.description.inputs)?u.description.inputs.length!==s.length||u.name!==c.name||u.path!==c.path?!1:u.description.inputs.every((E,_)=>E.data.name===s[_].data.name):!1);if(o){let{description:u}=o,{outputs:E}=u;e=E[0]}else{b=A|0,p=position-T|0,re(`Unable to find expression matching: ${s.map(u=>u.data.name)}`);return}}break}default:{e=_t(c.name);break}}if(!e)if(Po.includes(c.name)&&c.type===Mt){let f=c.inputs.map(s=>ue(s)),t=Ze(c.name,f);e={data:{name:t.description.outputs[0].data.name,path:t.description.outputs[0].data.path}}}else c.type===Ue&&(e={data:{type:Ue,name:c.name,literal:c.literal,path:c.path}});return e},je=c=>{let n=ue(c);return n&&n.data.path===Ie&&n.data.type!==Me&&n.data.mutable?Object.seal({type:Et,link:c}):c},Qe=(c,n)=>{let e=JSON.parse(JSON.stringify(c)),f=c.description.generics.map(s=>s.name);function t(s){for(let o in s)if(s[o]&&typeof s[o]=="object")t(s[o]);else if(o==="name"&&f.includes(s[o])){let u=f.indexOf(s[o]);s[o]=n[u].name,s.path=n[u].path}else if(o==="path"&&s[o].split(".").includes(e.name)){let u=s[o].split("."),E=u.indexOf(e.name),_=lt(e.name,n);u[E]=_,s[o]=u.join(".")}}t(e);for(let s of U){let{description:o}=s,{inputs:u,outputs:E}=o,_=[...u,...E];if(s.type==="native"&&_.some(N=>f.includes(N.data.name))){let N=JSON.parse(JSON.stringify(s));t(N),U.push(N)}}return e},lt=(c,n)=>{let f=n.map(t=>`${t.name}${t.segment?`_${t.segment}`:""}`).join("__");return`${c}___${f}`},Ot=c=>c.type===kt&&c.value!==rt||c.type===Et&&c.link!==rt,{path:j,imports:D,files:v,Tokenizer:J}=R,W=new Map,oe=new Map,ne=new Map,ee=new Map,de=(c,n="")=>{let{name:e,path:f}=c,t=n||e,s=`${f}.${t}`;ne.set(s,c);let o=ee.get(t)||[];o.push(c),ee.set(t,o)},{data:it}=D;for(let c of it)de(c);let xe=[j],i=new yu.default,m=[],I=[],h=[],l=!1,C=!1,y=!1,G=!0,F=!1,Y=!1,P=ke,a=es,r=null,Ee=null,Ne=[],Te=0,A=1,T=0,_e=1,At=null,b=0,p=0,et=(c,n,e,f)=>{let t=n.subarray(e,e+f|0),s=d(t);return fE(c,n,e,f)?(b=A|0,p=c-T|0,rl(s),!0):Ye(c,n,e,f)?(b=A|0,p=c-T|0,Pe(s),!0):!1};i.on(zt,c=>{for(let n of I)n(c)}),i.on(Re,c=>{for(let n of h)n(c)});let ns=c=>{let n=Object.freeze({type:gu,message:He.FAIL_DUPLICATE_DATA(c),failureRow:b,failureColumn:p,name:c});C=!0,y=!0,i.emit(Re,n)},uo=(c,n)=>{let e=Object.freeze({type:Gu,message:He.FAIL_DUPLICATE_OBJECT_MEMBER(c,n),failureRow:b,failureColumn:p,property:c,object:n});C=!0,y=!0,i.emit(Re,e)},sl=c=>{let n=_e,e=Tt(c),f=Object.freeze({type:wu,message:He.FAIL_INDENTATION_MISMATCH(b),failureRow:b,failureColumn:p,expected:n,actual:e});C=!0,y=!0,i.emit(Re,f)},lo=c=>{let n=Object.freeze({type:Yu,message:He.FAIL_INDENTATION_NO_INCREASE(b),failureRow:b,failureColumn:p,indentation:_e});C=!0,y=!0,i.emit(Re,n)},Pe=c=>{let n=Object.freeze({type:Vu,message:He.FAIL_INVALID_IDENTIFIER(c),failureRow:b,failureColumn:p,identifier:c});C=!0,y=!0,i.emit(Re,n)},nl=(c,n)=>{let e=Object.freeze({type:Ku,message:He.FAIL_RETURN_LENGTH_MISMATCH(c,n),failureRow:b,failureColumn:p});y=!0,i.emit(Re,e)},ol=c=>{let n=Object.freeze({type:zu,message:He.FAIL_IMMUTABLE_ASSIGNMENT(c),failureRow:b,failureColumn:p,variable:c});C=!0,y=!0,i.emit(Re,n)},rl=c=>{let n=Object.freeze({type:Xu,message:He.FAIL_RESERVED_KEYWORD_USAGE(c),failureRow:b,failureColumn:p,keyword:c});C=!0,y=!0,i.emit(Re,n)},w=(c,n)=>{let e=Object.freeze({type:Fu,message:He.FAIL_UNEXPECTED_TOKEN(c,p),failureRow:b,failureColumn:p,reasons:n,token:c});C=!0,y=!0,i.emit(Re,e)},os=c=>{let n=Object.freeze({type:ju,message:He.FAIL_UNRESOLVED_NAME(c),failureRow:b,failureColumn:p,name:c});C=!0,y=!0,i.emit(Re,n)},mt=(c,n)=>{let e=Object.freeze({type:Hu,message:He.FAIL_UNRESOLVED_OBJECT_MEMBER(c,n),failureRow:b,failureColumn:p,name:c});C=!0,y=!0,i.emit(Re,e)},io=c=>{let n=Object.freeze({type:$u,message:He.FAIL_UNKNOWN_PROCEDURE_NAME(c),failureRow:b,failureColumn:p,name:c});C=!0,y=!0,i.emit(Re,n)},cl=c=>{let n=Object.freeze({type:aE,message:He.FAIL_UNALLOWED_COPY(c),failureRow:b,failureColumn:p,name:c});C=!0,y=!0,i.emit(Re,n)},al=(c,n)=>{let e=Object.freeze({type:Ju,message:He.FAIL_ASSIGNMENT_TYPE_MISMATCH(c,n),failureRow:b,failureColumn:p});C=!0,y=!0,i.emit(Re,e)},re=c=>{let n=Object.freeze({type:uE,message:c,failureRow:b,failureColumn:p});C=!0,y=!0,i.emit(Re,n)},ul=c=>{let n=Object.freeze({type:rE,message:He.FAIL_INPUT_TYPE_MISMATCH(b,c),failureRow:b,failureColumn:p,inputs:c});C=!0,y=!0,i.emit(Re,n)},Xt=c=>{let n=Object.freeze({type:cE,message:He.FAIL_UNSUPPORTED_TYPE(c),failureRow:b,failureColumn:p,inputs});C=!0,y=!0,i.emit(Re,n)},Tt=c=>c-T|0,gs=c=>{let n=_e|0;return Tt(c)<n},Gs=(c,n)=>{let e=_e|0,f=Tt(c);switch(n){case an:return f<=e;case Qo:return f!==e}throw un},CE=c=>{U.push(c)},Vs=(c,n=!0)=>{let{name:e,path:f}=c,t=`${f}.${e}`;if(!W.has(t)){n?L.unshift(c):L.push(c),W.set(t,c),ne.has(t)||de(c);return}},Fe=c=>{let n=ee.get(c);if(!n)return null;if(n.length===1){let[e]=n;return Vs(e),e}throw un},vE=(c,n)=>{let{description:e}=c,{inputs:f,locals:t}=e,{name:s}=n;for(let o of f)if(o.name===s)return o.data;for(let o of t)if(o.name===s)return o.data;return null},ll=(c,n,e,f)=>{switch(a){case es:{let t=n.subarray(e,e+f|0);if(r&&r.export&&(_e=Tt(c),At&&At!==_e&&(M(),r=null,B(),At=null,_e=1),At=_e),X(t,zf)){B(),P=cr,a=Xr,l=!0;return}if(X(t,Xf)){B(),_e=Tt(c),r=Object.freeze({export:!0,indentation:_e}),a=lr;return}if(X(t,wf)){B(),P=sr,a=fr,l=!0;return}if(X(t,Ho)||X(t,Wo)){B(),P=nr,a=vr,l=!0;return}if(X(t,wt)){B(),P=_n,a=$r,l=!0;return}if(X(t,$o)){B(),P=or,a=Is,l=!0;return}break}case lr:{if(n[e]===we){a=es,B(),a=ir;return}l=!0,a=es;break}case ir:{if(n[e]===Oe){a=es;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,gt);break}case ar:{Y=!1;let t=n.subarray(e,e+f|0);if(X(t,Gf)){P=ye,a=qr,l=!0;return}if(X(t,Vf)){P=ye,a=Rc,l=!0;return}if(X(t,Yf)){P=ye,a=Oc,l=!0;return}if(X(t,Qf)){P=ye,a=$c,l=!0;return}if(X(t,qf)){P=ye,a=qc,l=!0;return}if(X(t,gf)){P=ye,a=dc;return}if(X(t,Xo)){P=ye,a=lc,l=!0;return}if(X(t,Lt)||X(t,It)||X(t,ps)){b=A|0,p=c-T|0;let u=d(t);w(u,En);return}if(X(t,wt)){P=ye,a=rc,l=!0;return}if(X(t,Kf)){P=ye,a=ac,l=!0;return}if(X(t,Zo)||X(t,Zf)){P=ye,a=gc,l=!0;return}if(!et(c,n,e,f)){P=ye,a=Uc,l=!0;return}b=A|0,p=c-T|0;let s=d(t);w(s,hE);break}case Le:{let t=n[e],s=n.subarray(e,e+f|0),o=d(s);if(L.find(E=>E.type===yt&&E.description.labels.find(_=>_.name===o))){P=Be,a=zn,l=!0;return}if(xs(t)&&!ro(d(s))){if(L.find(N=>N.name===o&&N.type===Ve)){P=Be,a=Ea,l=!0;return}if(L.find(N=>N.type===yt&&N.name===o)){P=Be,a=zn,l=!0;return}}if(X(s,bs)){P=Be,a=ka,l=!0;return}if(X(s,Jo)){P=Be,a=Ta,l=!0;return}if(X(s,Xo)){P=Be,a=aa,l=!0;return}if(X(s,Lt)){P=Be,a=Bs,l=!0;return}if(X(s,It)){P=Be,a=Bs,l=!0;return}if(X(s,ps)){P=Be,a=Bs,l=!0;return}if(X(s,ms)){P=Be,a=xn,l=!0;return}if(X(s,Hf)){P=Be,a=Ya,l=!0;return}if(X(s,$f)){P=Be,a=ru,l=!0;return}if(t===at){P=Be,a=Vn,l=!0;return}a=mn,l=!0;break}case mn:{le(c,n,e,f),B(),r=n[e],a=ur;break}case ur:{le(c,n,e,f);let t=r;M();let s=n[e];if(s===he){P=Be,a=Ds,pe();return}if(s===at){P=Be,a=ba,pe();return}if(s===Ke&&t!==Yt){P=Be,a=Ds,pe();return}if(s===qe){a=mn;return}P=Be,a=la,pe();break}}},il=(c,n,e,f)=>{switch(a){case fr:{let t=xe.join("."),s=Object.seal({labels:[],generics:[]}),o=Object.seal({type:yt,name:tt,path:t,description:s});r=Object.seal({enumeration:o}),a=Er;break}case Er:{let{enumeration:t}=r,s=n.subarray(e,e+f|0),o=d(s);if(et(c,n,e,f))return;t.name=o,a=_r;break}case _r:{let t=n[e];if(t===we){a=mr;return}if(t===Ke){let{enumeration:E}=r,{description:_}=E,{generics:N}=_;B(),r=N,P=xt,a=ss,l=!0;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,ut);break}case mr:{if(n[e]===Oe){a=pr;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,gt);break}case pr:{_e=Tt(c),a=pn,l=!0;break}case pn:{let{enumeration:t}=r;if(gs(c)){if(Vs(t),M(),r&&r.export){let s=Object.freeze({name:t.name,type:t.type,path:oo});$.push(s);let o=_e;M(),_e===o&&M(),_e<o&&B()}l=!0;return}a=br,l=!0;break}case br:{let{enumeration:t}=r,{description:s}=t,{labels:o}=s,u=n.subarray(e,e+f|0),E=d(u);if(et(c,n,e,f))return;let _={name:E};o.push(_),a=pn,B(),a=Or;break}case Or:{let t=n[e];if(l=!0,t===he){a=Ar;return}let{enumeration:s}=r,{description:o}=s,{labels:u}=o,E=u.length-1;r=Object.seal({label:u[E]}),a=bn;break}case Ar:{if(n[e]===he){a=Tr;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,Ge);break}case Tr:{let{enumeration:t}=r,{description:s}=t,{labels:o}=s;if(Ye(c,n,e,f)){b=A|0,p=c-T|0,Pe(E);return}let u=n.subarray(e,e+f|0),E=d(u),_=o.pop();_.data={name:E,path:j},o.push(_),a=Nr;break}case Nr:{if(n[e]===we){a=dr;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,ut);break}case dr:{let{enumeration:t}=r,{description:s}=t,{labels:o}=s,u=n.subarray(e,e+f|0),E=d(u);if(et(c,n,e,f))return;let _=o.pop();_.data.type=E,o.push(_),r=Object.seal({label:_}),a=Ir;break}case Ir:{if(n[e]===Se){a=bn;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,$e);break}case bn:{if(n[e]===Oe){M();return}break}}},fl=(c,n,e,f)=>{switch(a){case ss:{a=Lr,l=!0;break}case Lr:{if(n[e]===Ke){a=Ns;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,Ge);break}case Ns:{let t=n[e];if(t===Oe)return;if(t===nt){M();return}a=Rr,l=!0;break}case Rr:{let t=n.subarray(e,e+f|0),s=d(t);if(et(c,n,e,f))return;B();let o=Object.seal({type:is,name:s,path:j});r=Object.seal({name:s,data:o}),de(r.data,r.name),a=Cr;break}case Cr:{let t=r;M(),r.push(t);let o=n[e];if(o===nt){a=Ns,l=!0;return}if(o===ge){a=Ns;return}b=A|0,p=c-T|0;let u=n.subarray(e,e+f|0),E=d(u);w(E,$e);break}}},El=(c,n,e,f)=>{switch(a){case ts:{a=hr,l=!0;break}case hr:{if(n[e]===he){a=Ts;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,Ge);break}case Ts:{let t=n[e];if(t===Oe)return;if(t===Se){M();return}a=Sr,l=!0;break}case Sr:{let t=n.subarray(e,e+f|0);if(B(),X(Rt,t)){r=Object.seal({name:null,mutable:!0,data:null}),a=On;return}r=Object.seal({name:null,data:null}),a=On,l=!0;break}case On:{let t=n.subarray(e,e+f|0),s=d(t);if(et(c,n,e,f))return;r.name=s,a=kr;break}case kr:{if(n[e]===we){a=Pr,B(),P=vt,a=bt;return}break}case Pr:{let t=r;M();let s=r,{mutable:o,...u}=t;s.push(u);let E=n[e];if(E===Se){a=Ts,l=!0;return}if(E===ge){a=Ts;return}b=A|0,p=c-T|0;let _=n.subarray(e,e+f|0),N=d(_);w(N,$e);break}}},_l=(c,n,e,f)=>{switch(a){case vr:{let t=xe.join("."),s=Object.seal({members:[],generics:[]}),o=Object.seal({type:Ve,name:tt,copy:!0,path:t,description:s});r=Object.seal({mapNameMember:new Map,object:o}),a=Ur,l=!0;break}case Ur:{let t=n.subarray(e,e+f|0);if(a=Br,X(t,Wo)){r.object.copy=!1;return}l=!0;break}case Br:{let t=n.subarray(e,e+f|0);if(X(t,Ho)){a=Dr;return}b=A|0,p=c-T|0;let s=d(t);w(s,ut);break}case Dr:{let{object:t}=r,s=n.subarray(e,e+f|0),o=d(s);if(et(c,n,e,f))return;let u=Fe(o);if(u&&xe.join(".")===u.path&&(b=A|0,p=c-T|0,ns(o)),X(s,Rt)){b=A|0,p=c-T|0,failReservedKeyword(o);return}t.name=o,Vs(t,!1),a=yr;break}case yr:{if(n[e]===Ke)a=Mr,l=!0;else if(n[e]===we)a=An,l=!0;else{let t=n.subarray(e,e+f|0),s=d(t);b=A|0,p=c-T|0,Pe(s);return}break}case Mr:{let{object:t}=r,{description:s}=t,{generics:o}=s;a=An,B(),r=o,P=xt,a=ss,l=!0;break}case An:{if(n[e]===we){a=jr;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,ut);break}case jr:{if(n[e]===Oe){a=Fr;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,gt);break}case Fr:{if(Gs(c,an)){let t=m.length;if(m.length<1||m[t-1].item.indentation>=_e){b=A|0,p=c-T|0,lo(c);return}}_e=Tt(c),a=ds,l=!0;break}case ds:{let{object:t}=r;if(gs(c)){if(M(),r&&r.export){let s=Object.freeze({name:t.name,type:t.type,path:oo});$.push(s);let o=_e;M(),_e===o&&M(),_e<o&&B()}l=!0;return}if(Gs(c,Qo)){b=A|0,p=c-T|0,sl(c);return}a=wr,l=!0;break}case wr:{let{object:t,mapNameMember:s}=r,{description:o}=t,{members:u}=o,E=n.subarray(e,e+f|0),_=d(E);if(a=Yr,X(E,Rt)){B(),r=Object.freeze({mutable:!0});return}l=!0;break}case Yr:{let t;r.mutable&&(t=r.mutable,M());let{object:s,mapNameMember:o}=r,{description:u}=s,{members:E}=u,_=n.subarray(e,e+f|0),N=d(_);if(X($o,_)){a=ds,B(),P=rr,a=Is,l=!0;return}if(et(c,n,e,f))return;o.has(N)&&(b=A|0,p=c-T|0,uo(N,s.name));let S={name:N,data:null};t&&(S.mutable=t),E.push(S),o.set(N,S),a=ds,B(),r=Object.seal({member:S}),a=gr;break}case gr:{if(n[e]===we){a=Gr;return}break}case Gr:{a=Hr,B(),r=Object.seal({data:null}),B(),P=vt,a=bt,l=!0;break}case Hr:{let t=n[e],{data:s}=r;M();let{member:o}=r;if(o.data=s,o.mutable&&(o.data={...s,mutable:o.mutable}),t===Oe){M();return}if(t===Os){a=Vr;return}b=A|0,p=c-T|0;let u=n.subarray(e,e+f|0),E=d(u);w(E,Ct);break}case Vr:{let{stack:t}=r;a=Kr,B(),r={stack:new Map,procedure:null,value:null},B(),a=Le,P=ke,l=!0;break}case Kr:{let{value:t}=r;M();let{member:s}=r;s.value=t,M();break}}},ml=(c,n,e,f)=>{switch(a){case Is:{let{mapNameMember:t,object:s}=r,{name:o}=s,u=new Map(t),E=`${xe.join(".")}.${o}`,_=Object.seal({generics:[],inputs:[],locals:[],outputs:[],statements:[]}),N=Object.seal({type:st,name:tt,path:E,description:_});r=Object.seal({procedure:N,stack:u}),a=hs;break}case hs:{let{procedure:t}=r,s=n.subarray(e,e+f|0),o=d(s);if(et(c,n,e,f))return;if(X(s,Rt)){b=A|0,p=c-T|0,failReservedKeyword(o);return}t.name=o,a=Ss;break}case Ss:{if(n[e]===Ke)a=ks,l=!0;else if(n[e]===he)a=Ht,l=!0;else{let t=n.subarray(e,e+f|0),s=d(t);b=A|0,p=c-T|0,Pe(s);return}break}case ks:{let{procedure:t}=r,{description:s}=t,{generics:o}=s;a=Ht,B(),r=o,P=xt,a=ss,l=!0;break}case Ht:{let{procedure:t}=r,{description:s}=t,{inputs:o}=s;a=Ps,B(),r=o,P=qt,a=ts,l=!0;break}case Ps:{let{procedure:t,stack:s}=r,{description:o}=t,{inputs:u}=o;for(let k of u){let{name:V,data:g}=k;s.set(V,g)}u.length>0&&r.procedure.name===Yo&&(b=A|0,p=c-T|0,re("Destructors should not return any values. Your destructor appears to return a number. Please adhere to Flogram's conventions and correct your code."));let E=n.subarray(e,e+f|0),_=n[e];if(X(E,Ko)){a=Ls;return}if(_===we){a=$t,l=!0;return}b=A|0,p=c-T|0;let N=d(E);w(N,xo);break}case Ls:{let{procedure:t}=r,{description:s}=t,{outputs:o}=s;a=$t,B(),r=o,P=qt,a=ts,l=!0;break}case $t:{let t=n[e],{outputs:s}=r.procedure.description;if(s.length>0&&r.procedure.name===_s&&(b=A|0,p=c-T|0,re(`Constructors in Flogram should not return any values. Your constructor seems to return ${s.length} outputs. Please correct your code according to Flogram rules.`)),s.length>0&&r.procedure.name===Yo&&(b=A|0,p=c-T|0,re(`Destructors in Flogram should not return any values. Your destructor seems to return ${s.length} outputs. Please correct your code according to Flogram rules.`)),t===we){a=Rs;return}b=A|0,p=c-T|0;let o=n.subarray(e,e+f|0),u=d(o);w(u,ut);break}case Rs:{if(n[e]===Oe){a=Cs;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,gt);break}case Cs:{let{procedure:t,stack:s}=r,{description:o}=t,{statements:u}=o;a=vs,B(),r=Object.seal({procedure:t,stack:s,statements:u}),P=ye,a=ht,l=!0;break}case vs:{let{procedure:t}=r,{name:s}=t;M();let{object:o,mapNameMember:u}=r,{description:E}=o,{members:_}=E;u.has(s)&&(b=A|0,p=c-T|0,uo(s,o.name));let N=Object.seal({name:t.name,data:{name:t.name,type:t.type,path:t.path}});_.push(t),u.set(s,N),l=!0;break}}},pl=(c,n,e,f)=>{switch(a){case $r:{let t=n.subarray(e,e+f|0);if(X(t,wt)){B(),P=_n,a=zr,l=!0;return}break}case zr:{if(n[e]===Oe){M();return}break}}},bl=(c,n,e,f)=>{switch(a){case Is:{let t=new Map,s=xe.join("."),o=Object.seal({generics:[],inputs:[],locals:[],outputs:[],statements:[]}),u=Object.seal({type:st,name:tt,path:s,description:o});r=Object.seal({procedure:u,stack:t}),a=hs;break}case hs:{let{procedure:t}=r,s=n.subarray(e,e+f|0),o=d(s);if(et(c,n,e,f))return;if(X(s,Rt)){b=A|0,p=c-T|0,failReservedKeyword(o);return}t.name=o,a=Ss;break}case Ss:{if(n[e]===Ke)a=ks,l=!0;else if(n[e]===he)a=Ht,l=!0;else{let t=n.subarray(e,e+f|0),s=d(t);b=A|0,p=c-T|0,Pe(s);return}break}case ks:{let{procedure:t}=r,{description:s}=t,{generics:o}=s;a=Ht,B(),r=o,P=xt,a=ss,l=!0;break}case Ht:{let{procedure:t}=r,{description:s}=t,{inputs:o}=s;a=Ps,B(),r=o,P=qt,a=ts,l=!0;break}case Ps:{let{procedure:t,stack:s}=r,{description:o}=t,{inputs:u}=o;for(let k of u){let{name:V,data:g}=k;s.set(V,g)}let E=n.subarray(e,e+f|0),_=n[e];if(X(E,Ko)){a=Ls;return}if(_===we){a=$t,l=!0;return}b=A|0,p=c-T|0;let N=d(E);w(N,xo);break}case Ls:{let{procedure:t}=r,{description:s}=t,{outputs:o}=s;a=$t,B(),r=o,P=qt,a=ts,l=!0;break}case $t:{let t=n[e],{procedure:s}=r;if(U.push(s),t===we){a=Rs;return}b=A|0,p=c-T|0;let o=n.subarray(e,e+f|0),u=d(o);w(u,ut);break}case Rs:{if(n[e]===Oe){a=Cs;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,gt);break}case Cs:{let{procedure:t,stack:s}=r,{description:o}=t,{statements:u}=o;a=vs,B(),r=Object.seal({procedure:t,stack:s,statements:u}),P=ye,a=ht,l=!0;break}case vs:{let E=function(_,N=!0){let S=[Go,go,yo],k=!1;if(_.find(g=>g.type===fs))return!0;for(let g=_.length-1;g>=0;g--){let K=_[g];if(S.includes(K.type)&&K.statements)E(K.statements,!1)&&(k=!0);else if(K.type===Do)if(K.branches&&K.branches.length>0){let H=_.some(Z=>Z.type===fs);if(N&&!H&&K.branches.length<2)return console.error("Error: If the condition is not met, the procedure will not return."),b=A|0,p=c-T|0,re("Procedure does not return on a specific condition; it will not return if conditions are not met."),!1;if(!H){for(let Z of K.branches)if(!Z.statements||!E(Z.statements,!1))return b=A|0,p=c-T|0,re(`Procedure ${t.name} does not have a return statement. Please make sure your return values are marked as defined in the procedure definition.`),!1;g!==_.length-1&&(console.log("Code will not be executed after return in block"),b=A|0,p=c-T|0,re(`Code after return statement will not be executed. Procedure ${t.name} has defined statements after a return statements which makes them unreachable.`))}k=!0}else return console.error("Error: Condition does not have branches"),!1;else K.type===fs&&(g!==_.length-1&&(console.log("Code will not be executed after return in block"),b=A|0,p=c-T|0,re(`Code after return statement will not be executed. Procedure ${t.name} has defined statements after a return statements which makes them unreachable.`)),k=!0);if(k==!0)break}return N&&!k&&(b=A|0,p=c-T|0,re(`Procedure ${t.name} does not have a return statement. Please make sure your return values are marked as defined in the procedure definition.`)),k},{procedure:t}=r,{description:s}=t,{statements:o,outputs:u}=s;if(u.length!==0&&E(o),M(),r&&r.export){let _=Object.freeze({name:t.name,type:t.type,path:Du});$.push(_);let N=_e;M(),_e===N&&M(),_e<N&&B()}l=!0;break}}},Ol=(c,n,e,f)=>{switch(a){case ht:{if(Gs(c,an)){b=A|0,p=c-T|0,lo(c);return}_e=Tt(c),a=Qr,l=!0;break}case Qr:{let t=n.subarray(e,e+f|0);if(gs(c)){M(),l=!0;return}B(),P=ke,a=ar,l=!0;break}case dc:{let{statements:t}=r,s={type:Mf};t.push(s),M();break}case qc:{let{procedure:t,stack:s,statements:o}=r,u=Object.seal({type:Go,condition:null,statements:[]});o.push(u),B(),r=Object.seal({blockWhile:u,procedure:t,stack:s}),a=xc;break}case xc:{let{stack:t,procedure:s}=r;a=ea,B(),r={stack:t,procedure:s,value:null},B(),a=Le,P=ke,l=!0;break}case ea:{if(n[e]===we){let{value:E}=r;M();let{blockWhile:_}=r;_.condition=E,a=ta;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,ut);break}case ta:{let{blockWhile:t,procedure:s,stack:o}=r,{statements:u}=t;if(n[e]===Oe){a=yn,B(),r=Object.seal({procedure:s,stack:o,statements:u}),P=ye,a=ht;return}b=A|0,p=c-T|0;let _=n.subarray(e,e+f|0),N=d(_);w(N,Ct);break}case $c:{let{procedure:t,stack:s,statements:o}=r,u=Object.seal({type:go,iterator:null,index:`{j_${Ce()}}`,collection:null,statements:[]}),E={name:u.index,data:{type:ve,name:ct,path:Ie}};s.set(E.name,E.data),o.push(u),B(),r=Object.seal({blockForeach:u,procedure:t,stack:new Map(JSON.parse(JSON.stringify(Array.from(s))))}),a=zc;break}case zc:{let t=n.subarray(e,e+f|0),{blockForeach:s,stack:o}=r,u=d(t);if(o.has(u)){ns(u),b=A|0,p=c-T|0;return}s.iterator=u,a=Xc;break}case Xc:{let{blockForeach:t,stack:s,procedure:o}=r,{description:u}=o,{locals:E}=u,_=n.subarray(e,e+f|0);if(X(eE,_)){s.delete(t.index),a=Jc;return}l=!0,a=Dn;break}case Jc:{let{blockForeach:t,stack:s,procedure:o}=r,{description:u}=o,{locals:E}=u,_=n.subarray(e,e+f|0),N=d(_);if(s.has(N)){ns(N),b=A|0,p=c-T|0;return}let S={name:N,data:{type:ve,name:ct,path:Ie}};s.set(N,S.data),E.push(S),t.index=N,a=Dn;break}case Dn:{let{blockForeach:t,stack:s,procedure:o}=r,{description:u}=o,{locals:E}=u,_=n.subarray(e,e+f|0);if(X(xf,_)){s.has(t.index)&&!E.find(k=>k.name===t.index)&&E.push({name:t.index,data:s.get(t.index)}),a=Wc;return}b=A|0,p=c-T|0;let N=d(_);w(N,ut);break}case Wc:{let{stack:t,procedure:s}=r;a=Zc,B(),r={stack:t,procedure:s,value:null},B(),a=Le,P=ke,l=!0;break}case Zc:{if(n[e]===we){let{value:E,stack:_,procedure:N}=r,{description:S}=N,{locals:k}=S;M();let{blockForeach:V}=r;V.collection=E;let{data:g}=ue(E),K={name:V.iterator,data:{type:g.contains||ve,name:g?.name,path:g?.path,layout:g.contains}};_.set(K.name,K.data),k.push(K),a=Qc;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,ut);break}case Qc:{let{blockForeach:t,procedure:s,stack:o}=r,{statements:u}=t;if(n[e]===Oe){a=yn,B(),r=Object.seal({procedure:s,stack:o,statements:u}),P=ye,a=ht;return}b=A|0,p=c-T|0;let _=n.subarray(e,e+f|0),N=d(_);w(N,Ct);break}case yn:{M(),M(),l=!0;break}case Oc:{let{procedure:t,stack:s,statements:o}=r,u=Object.freeze({type:yo,statements:[]});o.push(u),B(),r=Object.seal({blockLoop:u,procedure:t,stack:new Map(JSON.parse(JSON.stringify(Array.from(s)))),value:0}),a=Ac;break}case Ac:{if(n[e]===we){a=Tc;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,ut);break}case Tc:{let{blockLoop:t,procedure:s,stack:o}=r,{statements:u}=t;if(n[e]===Oe){a=Nc,B(),r=Object.seal({procedure:s,stack:o,statements:u}),P=ye,a=ht;return}b=A|0,p=c-T|0;let _=n.subarray(e,e+f|0),N=d(_);w(N,Ct);break}case Nc:{M(),M(),l=!0;break}case qr:{let{procedure:t,stack:s,statements:o}=r,u=Object.freeze({type:Do,branches:[],values:[]});o.push(u),B(),r=Object.seal({blockCondition:u,procedure:t,stack:new Map(JSON.parse(JSON.stringify(Array.from(s)))),value:0}),a=Ic;break}case Ic:{le(c,n,e,f),a=hc;break}case hc:{le(c,n,e,f);let t=n[e],s=n.subarray(e,e+f|0);if(t===he){a=Sc,pe();return}if(X(s,Vo)){a=Nn,pe();return}break}case Rc:{let{stack:t,branches:s,procedure:o}=r,u={type:Uf,statements:[],values:[]};s.push(u),r=Object.seal({branch:u,stack:t,procedure:o}),a=Ln;break}case Sc:{let t=n.subarray(e,e+f|0),{blockCondition:s,stack:o,procedure:u}=r,{branches:E}=s,_={type:Bo,statements:[],values:[]};E.push(_);let N=d(t),S={type:Mt,name:N,path:Ie,inputs:[]},k=U.find(V=>V.type===st&&V.name===N);k&&(S.path,k.path),r=Object.seal({blockCondition:s,branch:_,stack:o,value:S,procedure:u}),a=kc;break}case kc:{if(n[e]===he){a=Bn;return}b=A|0,p=c-T|0;let t=n.subarray(e,e+f|0),s=d(t);w(s,Ge);break}case Bn:{let{stack:t,procedure:s}=r;if(n[e]===Se){a=Pn,l=!0;return}a=Yc,B(),r={stack:t,procedure:s,value:null},B(),a=Le,P=ke,l=!0;break}case Yc:{let{value:t}=r;M();let{value:s,stack:o,procedure:u}=r,{inputs:E}=s;E.push(je(t));let _=n[e];if(_===Se){a=Pn,l=!0;return}if(_===ge){a=Bn;return}b=A|0,p=c-T|0;let N=n.subarray(e,e+f|0),S=d(N);w(S,ln);break}case Pn:{let{value:t,branch:s,stack:o}=r,{values:u}=s,{name:E}=t,_=rs[E];if(_){let V=t.inputs.map(K=>ue(K))||[],g=_.find(K=>K.description&&Array.isArray(K.description.inputs)?K.description.inputs.length!==V.length?!1:K.description.inputs.every((H,Z)=>H.data.name===V[Z].data.name):!1);g&&U.push(g)}if(u.push(t),Fe("Bool"),n[e]===Se){a=Ln;return}b=A|0,p=c-T|0;let N=n.subarray(e,e+f|0),S=d(N);w(S,$e);break}case Ln:{let t=n.subarray(e,e+f|0);if(n[e]===we){a=Pc;return}b=A|0,p=c-T|0;let s=d(t);w(s,Gt);break}case Pc:{let{branch:t,procedure:s,stack:o}=r,{statements:u}=t;if(n[e]===Oe){a=Lc,B(),r=Object.seal({procedure:s,stack:o,statements:u}),P=ye,a=ht;return}b=A|0,p=c-T|0;let _=n.subarray(e,e+f|0),N=d(_);w(N,Ct);break}case Lc:{let{branch:t}=r;if(r.blockCondition){let{blockCondition:s}=r,{branches:o}=s;M(),M(),r=Object.seal({...r,branches:o})}else{M();let{branches:s,...o}=r;r=Object.seal(o)}l=!0;break}case Nn:{let{blockCondition:t,stack:s}=r,{values:o}=t,u=n.subarray(e,e+f|0),E=d(u);if(et(c,n,e,f))return;if(s.has(E)){let _=Object.freeze({type:ot,name:E});o.push(_)}a=xr;break}case xr:{if(n[e]===ge){a=Nn;return}let s=n.subarray(e,e+f|0);if(X(s,Vo)){a=ec,B(),a=tc,l=!0;return}b=A|0,p=c-T|0;let o=d(s);w(o,IE);break}case ec:{M(),M(),l=!0;break}case tc:{let{blockCondition:t,procedure:s,stack:o}=r,{branches:u}=t,E=Object.seal({type:Bo,statements:[],values:[]});u.push(E),r=Object.seal({blockCondition:t,branchMatch:E,procedure:s,stack:o}),a=dn;break}case dn:{let{blockCondition:t,branchMatch:s,stack:o}=r,{values:u}=t,{values:E}=s,_=n.subarray(e,e+f|0),N=d(_);if(et(c,n,e,f))return;if(o.has(N)){let S=Object.freeze({type:ot,name:N});E.push(S)}else if(ro(N)){let S=Object.freeze({type:Ue,literal:N,name:"Bool",path:Ie});E.push(S),Fe(S.name)}else{let{procedure:S}=r,{description:k}=S,{outputs:V}=k,g=N,{name:K,path:H}=V[0].data,Z=Object.freeze({type:Ue,literal:g,name:K,path:H});E.push(Z)}a=sc;break}case sc:{let t=n[e];if(t===ge){a=dn;return}if(t===we){a=nc;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,ut);break}case nc:{let{branchMatch:t,procedure:s,stack:o}=r,{statements:u}=t;if(n[e]===Oe){a=oc,B(),r=Object.seal({procedure:s,stack:o,statements:u}),P=ye,a=ht;return}b=A|0,p=c-T|0;let _=n.subarray(e,e+f|0),N=d(_);w(N,Ct);break}case oc:{M();let t=n.subarray(e,e+f|0),s=d(t);l=!0;break}case rc:{a=cc;break}case cc:{if(n[e]===Oe){M();return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,Ct);break}case ac:{let{procedure:t,stack:s,statements:o}=r,u=Object.seal({type:fs,values:[]});o.push(u),B();let E=A|0,_=c-T|0,N=Object.freeze({row:E,column:_});r=Object.seal({commandReturn:u,coordinates:N,procedure:t,stack:s}),a=In;break}case In:{let{stack:t,procedure:s}=r;if(n[e]===Oe){a=hn,l=!0;return}a=uc,B(),r={stack:t,procedure:s,value:null},B(),a=Le,P=ke,l=!0;break}case uc:{let{value:t}=r;M();let{commandReturn:s,stack:o,procedure:u}=r,{values:E}=s;E.push(je(t));let _=n[e];if(_===Oe){a=hn,l=!0;return}if(_===ge){a=In;return}b=A|0,p=c-T|0;let N=n.subarray(e,e+f|0),S=d(N);w(S,ln);break}case hn:{let{commandReturn:t,coordinates:s,procedure:o}=r,{values:u}=t,{description:E}=o,{outputs:_}=E;u.length!==_.length&&(b=s.row|0,p=s.column|0,nl(_.length,u.length));for(let N of _){let S=_.indexOf(N),k=ue(u[S]);k&&k.data.name!=N.data.name&&(b=s.row|0,p=s.column|0,re(`Mismatching types provided on procedure's return. Procedure expected ${N.data.name} at index ${S} but was provided with a rather ${k.data.name}. Please review to provide matching types.`))}M(),M();break}case Uc:{let t=n.subarray(e,e+f|0),{procedure:s,stack:o,statements:u}=r,E={type:ot,name:null},_=Object.seal({type:ls,target:E,source:null});r=Object.freeze({declarationValue:_,procedure:s,stack:o,statements:u,target:E}),X(Rt,t)?(E.mutable=!0,a=Sn):(l=!0,a=Un);break}case Un:{le(c,n,e,f),a=Mc;break}case Mc:{if(le(c,n,e,f),n[e]===he){let{procedure:t,stack:s,statements:o}=r;a=jc;let u=Object.seal({type:Fo,expression:null});r=Object.seal({stack:s,procedure:t,drop:u,value:null,statements:o}),B(),P=Be,a=Ds,pe();return}if(n[e]===qe){a=Un;return}a=Sn,pe();break}case jc:{let{statements:t,drop:s,value:o}=r;s.expression=o,t.push(s),M();break}case Sn:{let{stack:t}=r,s=n.subarray(e,e+f|0),o=d(s),u=t.get(o);if(t.has(o)&&!u.mutable&&(Y=!0),X(Jo,s)){l=!0,a=Bc;return}let{target:E}=r;E.name=o,a=kn;break}case kn:{let t=n[e],{procedure:s,stack:o,statements:u,target:E}=r;if(t===at){let k=r.declarationValue,V={type:ls,target:{type:vf,array:{type:ot,name:k.target.name},index:null},source:null};r=Object.seal({declarationValue:V,procedure:s,stack:o,statements:u}),l=!0,a=mc;return}if(t===qe){let k=r.declarationValue,V=[],g=k.target;r=Object.seal({declarationValue:{type:ls,target:{type:tn,value:g,trail:V},source:null},procedure:s,stack:o,statements:u}),B(),r=Object.seal({stack:o,trail:V,value:g}),a=Rn;return}if(t===we){l=!0,a=fc;return}if(t===Se){let{declarationValue:k}=r;M(),r.declarationValue.target=k.target,l=!0;return}if(t===Os){let k=r.declarationValue?.target&&We(r.declarationValue?.target);if(k&&k!==rt&&!o.get(k)){b=A|0,p=c-T|0,os(k);return}a=Us;return}b=A|0,p=c-T|0;let _=n.subarray(e,e+f|0),N=d(_);w(N,Gt);break}case Bc:{r.target.type=sn,r.target.trail=[],delete r.target.name,a=Cn;break}case Cn:{if(n[e]===qe){a=Dc;return}a=vn,l=!0;break}case Dc:{let t=n.subarray(e,e+f|0),s=d(t);r.target.trail.push(s),a=yc;break}case yc:{if(n[e]===qe){a=Cn,l=!0;return}a=vn,l=!0;break}case vn:{a=Ut,l=!0;break}case mc:{if(n[e]===at){a=pc;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,fn);break}case pc:{let{stack:t,procedure:s}=r;a=bc,B(),r={stack:t,procedure:s,value:null},B(),a=Le,P=ke,l=!0;break}case bc:{if(n[e]===Zt){let{value:E}=r;M();let _=ue(E);if(_.data.mutable?r.declarationValue.target.index=Object.seal({type:Et,link:E}):r.declarationValue.target.index=E,!_||![ct,"U32","I16","U16","U8","I8"].includes(_.data.name)){b=A|0,p=c-T|0,re("Invalid index. Array index should be a valid I32 variable");return}a=Ut;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,er);break}case lc:{let{procedure:t,stack:s,statements:o}=r,u=Object.seal({type:jo,link:null}),E=Object.seal({type:ls,target:u,source:null});r=Object.freeze({declarationValue:E,procedure:t,stack:s,statements:o}),a=Fc;break}case Fc:{if(n[e]===he){a=ic;return}b=A|0,p=c-T|0;let t=n.subarray(e,e+f|0),s=d(t);w(s,Ge);break}case ic:{let{stack:t,procedure:s}=r;a=wc,B(),r={stack:t,procedure:s,value:null},B(),a=Le,P=ke,l=!0;break}case wc:{if(n[e]===Se){let{value:u}=r;M(),r.declarationValue.target.link=u,a=kn;return}b=A|0,p=c-T|0;let t=n.subarray(e,e+f|0),s=d(t);w(s,$e);break}case Cc:{if(n[e]!==qe){M(),l=!0;return}a=Rn;break}case Rn:{let{stack:t,value:s,trail:o}=r,u=n.subarray(e,e+f|0),E=d(u),_,N,S=!1;if(s.type===ot){let{name:k}=s;_=t.get(k)}if(_){let{name:k,path:V}=_,g=`${V}.${k}`,K=ne.get(g);K.type===Ve&&(N=K)}if(N){let{description:k}=N,{members:V}=k;for(let g of V)if(g.name===E){S=!0;break}if(!S){b=A|0,p=c-T|0,mt(E,s.name);return}}if(s.value===rt||s.link===rt){if(!t.get(E)){b=A|0,p=c-T|0,mt(E,`${rt}(current object in definition)`);return}S=!0}if(!S){b=A|0,p=c-T|0,mt(E,s.name);return}o.push(E),a=Cc;break}case fc:{let t=n.subarray(e,e+f|0),s=d(t);if(n[e]===we){let{target:E,stack:_}=r,{name:N}=E;if(_.has(N)){b=A|0,p=c-T|0,ns(N);return}if(n[e+1]===Os&&f>1){a=vc,l=!0;return}a=Ec;return}b=A|0,p=c-T|0,w(s,SE);break}case Ec:{let{declarationValue:t,procedure:s,stack:o}=r,{target:u}=t,{description:E}=s,{locals:_}=E,N=n.subarray(e,e+f|0),S=d(N);if(Ye(c,n,e,f)){b=A|0,p=c-T|0,Pe(S);return}if(X(ms,N)){a=Ut,B(),P=Kt,a=to,l=!0;return}if(X(N,It)||X(N,Lt)){a=Ut,B(),P=Kt,a=so,l=!0;return}if(X(N,bs)){a=Ut,B(),P=Kt,a=Lu,l=!0;return}let k=Fe(S);if(k){let V=Object.seal({type:ve,name:k.name,path:k.path}),g;u.mutable?g=Object.freeze({name:u.name,data:{...V,mutable:u.mutable}}):g=Object.freeze({name:u.name,data:V}),o.set(u.name,g.data),_.push(g)}a=Ut;break}case vc:{let{declarationValue:t,procedure:s,stack:o,statements:u}=r,{target:E}=t,{description:_}=s,{locals:N}=_,S;E.mutable?(S={name:E.name,mutable:E.mutable,data:null},delete E.mutable):S=Object.seal({name:E.name,data:null}),o.set(E.name,S.data),N.push(S),r=Object.seal({declarationValue:t,procedure:s,stack:o,statements:u,inferenceValue:S}),a=Us;break}case Ut:{let t=n.subarray(e,e+f|0);if(X(t,rn)){a=Us;return}b=A|0,p=c-T|0;let s=d(t);w(s,Gt);break}case Us:{let{procedure:t,stack:s,target:o}=r,u=n[e];if(Ye(c,n,e,f)&&u!==at){let E=n.subarray(e,e+f|0),_=d(E);b=A|0,p=c-T|0,Pe(_);return}a=_c,B(),r=Object.seal({procedure:t,stack:s,value:null}),B(),P=ke,a=Le,l=!0;break}case _c:{if(n[e]===Oe){let{value:E}=r;M();let{declarationValue:_,statements:N,stack:S}=r;if(r.inferenceValue){let Q=function(q){let te;switch(q.type){case ot:{let ie=S.get(q.name);ie.type===ve?te=ie:ie.type===Ue?(te={type:ve,name:ie.name,path:ie.path},q.mutable&&(te.mutable=q.mutable),q.contains&&(te.contains=q.contains)):(ie.type===Me||ie.type==="Link")&&(te=ie);let{moved:fo,...ze}=te;te=ze;break}case jt:{te={type:ve,name:Pt,path:Ie};break}case Ue:{te={type:ve,name:q.name,path:q.path},q.layout===Me&&(te.type=Me,te.length=q.literal.length),q.contains&&(te.contains=q.contains);break}case on:{te={type:ve,name:ct,path:Ie};break}case wo:{te={type:q.type,name:q.data.name,path:q.data.path},q.data.contains&&(te.contains=q.data.contains);break}case nn:{te=Q(q.value);break}case Mt:{let ie=ze=>U.find(ft=>ft.type===st&&ft.name===ze.name)?.description.outputs[0]?.data,fo=(ze,ft)=>{let Xe;for(let pt=0;ft&&pt<=ze.name.length-2;pt++)ft=S.get(ze.name[pt]),ft&&(Xe=L.find(Bt=>Bt.type===Ve&&Bt.name===ft.name));return Xe?.description.members?.find(pt=>pt.name===ze.name[ze.name.length-1])?.description.outputs[0]?.data};if(q.path!==Ie){if(te=ie(q),typeof q.name=="object"){let ze=S.get(q.name[0]);te=fo(q,ze)}}else if(qo.has(q.name))te={type:ve,name:"Bool",path:Ie},Fe(te.name);else{let ze=q.inputs.map(Xe=>ue(Xe)),ft=U.find(Xe=>Xe.description&&Array.isArray(Xe.description.inputs)?Xe.description.inputs.length!==ze.length||Xe.name!=q.name?!1:Xe.description.inputs.every((pt,Bt)=>pt.data.name===ze[Bt].data.name):!1);if(ft){let{description:Xe}=ft,{outputs:pt}=Xe,Bt=pt[0],{data:hl}=Bt,{name:Sl,path:kl}=hl;te={type:ve,name:Sl,path:kl}}else{b=A|0,p=c-T|0,re(`Unable to find expression matching: ${ze.map(Xe=>Xe.data.name)}`);return}}break}case kt:{te={...Q(q.value),type:Mo},q.unsafe&&(te.unsafe=q.unsafe),q.smart&&(te.smart=q.smart);break}case Et:{let ie=S.get(q.link);te={type:ve,name:ie.name,path:ie.path},ie.contains&&(te.contains=ie.contains);break}case Es:{let ie=S.get(q.array.name);te={type:ve,name:ie.name,path:ie.path},ie.contains&&(te.contains=ie.contains);break}default:{console.log("Unhandled: ",q.type);break}}return te},{inferenceValue:x}=r;x.data=Q(E),x.mutable&&(x.data.mutable=x.mutable,delete x.mutable),S.set(x.name,x.data)}let{target:k}=_,V=We(k),g=We(E);if(S.has(g)){let x=L.find(Q=>Q.name===S.get(g).name&&Q.type===Ve);x&&!x.copy&&(b=A|0,p=c-T|0,cl(g))}V&&V!==rt&&(x=>{if(!S.get(x)?.mutable&&Y){b=A|0,p=c-T|0,ol(x);return}})(V),_.source=E;let H=ue(k),Z=ue(E),me=(x,Q)=>{if(x===Q)return!0;if(typeof x!="object"||x===null||typeof Q!="object"||Q===null)return!1;if(x.type==="local"&&Q.type==="local")return x.name===Q.name;let q=Object.keys(x).filter(ie=>ie!=="mutable"),te=Object.keys(Q).filter(ie=>ie!=="mutable");if(q.length!==te.length)return!1;for(let ie of q)if(!te.includes(ie)||!me(x[ie],Q[ie]))return!1;return!0},be=(x,Q)=>x.some(q=>me(q,Q));if(H&&Z){H.data?.mutable&&H.data.path===Ie&&H.data.type!==Me&&(be(Ne,k)||r.procedure.description.inputs.some(Q=>Q.name===H.name||Q.name===We(k))?_.target=Object.seal({type:jo,link:k}):Z.data.path===Ie&&Z.data.type!==Me&&(_.source=Object.seal({type:kt,value:E}),Ne.push(k))),Z.data?.mutable&&Z.data.path===Ie&&Z.data.type!==Me&&(_.source=Object.seal({type:Et,link:E}));let x=(Q,q)=>Q.slice(1)===Q.slice(1)||Q.charAt(0)===Q.charAt(0)||(Q==="FP64"||Q==="FP32"||Q==="I64"||Q==="U64"||Q===ct||Q==="U32"||Q==="I16"||Q==="U16"||Q==="I8"||Q==="U8")&&q===ct||Q==="FP64"&&q=="FP32";if(H.data.name!==Z.data.name&&!(H.data.type===Z.data.name||H.data.name===Z.data.type)&&!(Z.data.type===Ue&&x(H.data.name,Z.data.name))){b=A|0,p=c-T|0,al(H.data.name,Z.data.name);return}}N.push(_),M();return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,kE);break}case gc:{let{stack:t,procedure:s}=r,o=Object.seal({type:jf,unsafe:!0,value:null}),u=n.subarray(e,e+f|0);X(u,Zo)&&(o.unsafe=!1),B(),r=Object.seal({free:o,stack:t,procedure:s}),a=Gc;break}case Gc:{if(n[e]===he){let{stack:E,procedure:_}=r;a=Vc,B(),r={stack:E,procedure:_,value:null},B(),a=Le,P=ke;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,Ge);break}case Vc:{let{value:t,stack:s}=r;M();let{free:o}=r;o.value=je(t);let u=!0,{name:E,data:_}=ue(t,u);if(b=A|0,p=c-T|0,_.type!==Mo){re(`Variable '${E}' is not a link and cannot be freed. Only 'unsafe' links are freeable.`);return}if(_.unsafe!==o.unsafe){re(`Improper free method used for link '${E}'. Unsafe links are unsafely freed with 'free!!' while safe ones are freed with 'free'. Your link(${E}) is ${_.unsafe?"un":""}safe.`);return}let N=s.get(E);N&&s.set(E,{...N,freed:!0}),a=Kc,l=!0;break}case Kc:{if(n[e]===Se){let{free:E}=r;M();let{statements:_}=r;_.push(E),a=Hc;break}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,$e);break}case Hc:{M();break}}},Al=(c,n,e,f)=>{switch(a){case bt:{let t=n.subarray(e,e+f|0),s=d(t);if(Ye(c,n,e,f)&&!Nt.includes(s)){b=A|0,p=c-T|0,Pe(s);return}if(a=sa,X(It,t)){r.data=Object.seal({type:s,unsafe:!0});return}if(X(Lt,t)){r.data=Object.seal({type:s});return}if(X(bs,t)){r.data=Object.seal({type:s});return}if(X(ms,t)){r.data={type:s};let u=m.length;if(m[u-1].situationGeneral===4){B();let{data:_}=r;r={isEnum:!0,type:_},l=!0,a=to,P=Kt;return}return}let o=Fe(s);if(o){o.type===is?r.data=Object.seal({type:ve,name:s,path:o.path}):r.data=Object.seal({type:ve,name:o.name,path:o.path}),r.mutable&&(r.data=Object.seal({...r.data,type:d(Lt),unsafe:!0,mutable:r.mutable}));return}console.log("Failed to find type",s),b=A|0,p=c-T|0,os(s),M();break}case sa:{let t=n.subarray(e,e+f|0);if(n[e]===Ke){l=!0,a=na;return}M(),l=!0;break}case na:{if(n[e]===Ke){a=oa;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,Qt);break}case oa:{let t=n.subarray(e,e+f|0),s=d(t),o=Fe(s);if(o){let{data:E}=r,{unsafe:_,type:N,smart:S}=E,k=ce(N);if(X(k,It))r.data=Object.seal({type:N.replace(/!!$/,""),name:o.name,path:o.path,segment:tt,unsafe:_});else if(X(k,Lt))r.data=Object.seal({type:N,name:o.name,path:o.path,segment:tt});else if(X(k,ps))r.data=Object.seal({type:N,name:o.name,path:o.path,segment:tt,smart:S});else{if(L.find(g=>g.type===Ve&&g.name===E.name)){a=ra,B(),r=[],B(),r={data:null},B(),l=!0,a=bt;return}r.data=Object.seal({type:N,name:o.name,path:o.path})}r.mutable&&(r.data=Object.seal({...r.data,mutable:r.mutable}));return}let u=n[e];if(u===ge)return;if(u===nt){l=!0,a=Mn;return}r.data.segment!==void 0&&(r.data.segment=s),a=Mn;break}case ra:{let t=n[e],{data:s}=r;if(M(),r.push(s),t===ge){B(),r={data:null},B(),a=bt;return}if(t===nt){let _=r;M();let N=L.find(k=>k.type===Ve&&k.name===r.data.name);if(!(N.description?.generics?.length===_.length)){b=A|0,p=c-T|0,re(`Generic object '${name}' was provided with fewer or more than expect number of types. Expected: ${N.description.generics.length}. Got: ${_.length}`);return}r.data.name=lt(r.data.name,_),M();return}b=A|0,p=c-T|0;let o=n.subarray(e,e+f|0),u=d(o);w(u,Vt);break}case Mn:{if(n[e]===nt){M();return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,Vt);break}}},Tl=(c,n,e,f)=>{switch(a){case to:{let t=n.subarray(e,e+f|0),s=d(t),o=Object.seal({type:s,name:null,length:null,path:Ie});r=Object.seal({...r,type:o}),a=mu;break}case mu:{let t=n.subarray(e,e+f|0);if(n[e]===Ke){a=pu;return}b=A|0,p=c-T|0;let s=d(t);w(s,Qt);break}case pu:{let t=n.subarray(e,e+f|0),s=d(t);if(Ye(c,n,e,f)&&!Nt.includes(s)){let u=n.subarray(e,e+f|0),E=d(u);b=A|0,p=c-T|0,Pe(E);return}let o=Fe(s);r.type.name=o.name,r.type.path=o.path,a=bu;break}case bu:{let t=n.subarray(e,e+f|0);if(n[e]===nt){a=Ou;return}b=A|0,p=c-T|0;let s=d(t);w(s,Vt);break}case Ou:{let t=n.subarray(e,e+f|0);if(n[e]===he){a=Au;return}b=A|0,p=c-T|0;let s=d(t);w(s,Ge);break}case Au:{let t=n.subarray(e,e+f|0);if(X(zo,t)){a=Tu;return}b=A|0,p=c-T|0;let s=d(t);w(s,As);break}case Tu:{let t=n.subarray(e,e+f|0);if(X(rn,t)){a=Nu;return}b=A|0,p=c-T|0;let s=d(t);w(s,Gt);break}case Nu:{if(Ye(c,n,e,f)){let o=n.subarray(e,e+f|0),u=d(o);b=A|0,p=c-T|0,Pe(u);return}let t=n.subarray(e,e+f|0),s=d(t);r.type.length=s,a=du;break}case du:{let t=n.subarray(e,e+f|0);if(n[e]===Se){a=Iu,l=!0;return}b=A|0,p=c-T|0;let s=d(t);w(s,$e);break}case Iu:{if(r.isEnum){let{type:S}=r;M(),r.data=S;return}let{declarationValue:t,procedure:s,stack:o}=r,{target:u}=t,{description:E}=s,{locals:_}=E,N;u.mutable?N=Object.freeze({name:u.name,data:{...r.type,mutable:u.mutable}}):N=Object.freeze({name:u.name,data:r.type}),o.set(u.name,N.data),_.push(N),M();break}case so:{let t=n.subarray(e,e+f|0),o={type:d(t).replace(/!!$/,""),path:Ie};X(t,It)&&(o.unsafe=!0),o=Object.seal({...o,name:null,segment:null});let{declarationValue:u,stack:E,procedure:_}=r;r=Object.seal({declarationValue:u,stack:E,procedure:_,type:o}),a=hu;break}case hu:{let t=n.subarray(e,e+f|0);if(n[e]===Ke){a=Su;return}b=A|0,p=c-T|0;let s=d(t);w(s,Qt);break}case Su:{let t=n.subarray(e,e+f|0),s=d(t);if(Ye(c,n,e,f)&&!Nt.includes(s)){b=A|0,p=c-T|0,Pe(s);return}Fe(s),r.type.name=s,a=ku;break}case ku:{let t=n.subarray(e,e+f|0);if(n[e]===ge){a=Pu;return}if(n[e]===nt){a=no,l=!0;return}b=A|0,p=c-T|0;let s=d(t);w(s,$e);break}case Pu:{if(Ye(c,n,e,f)){let o=n.subarray(e,e+f|0),u=d(o);b=A|0,p=c-T|0,Pe(u);return}let t=n.subarray(e,e+f|0),s=d(t);r.type.segment=s,a=no;break}case no:{let t=n.subarray(e,e+f|0);if(n[e]===nt){if(r.declarationValue){let{declarationValue:u,procedure:E,stack:_}=r,{target:N}=u,{description:S}=E,{locals:k}=S,V;N.mutable?V=Object.freeze({name:N.name,data:{...r.type,mutable:N.mutable}}):V=Object.freeze({name:N.name,data:r.type}),_.set(N.name,V.data),k.push(V),M()}else{let{type:u}=r;M(),r.data=u}return}b=A|0,p=c-T|0;let s=d(t);w(s,Vt);break}case Lu:{let t=n.subarray(e,e+f|0),s=d(t),o=Object.seal({type:s,path:null,name:null}),{declarationValue:u,stack:E,procedure:_}=r;r=Object.seal({declarationValue:u,stack:E,procedure:_,type:o}),a=Ru;break}case Ru:{let t=n.subarray(e,e+f|0);if(n[e]===Ke){a=Cu;return}b=A|0,p=c-T|0;let s=d(t);w(s,Qt);break}case Cu:{let t=n.subarray(e,e+f|0),s=d(t);if(Ye(c,n,e,f)){b=A|0,p=c-T|0,Pe(s);return}let o=Fe(s);r.type.name=s,r.type.path=o.path,a=vu;break}case vu:{let t=n.subarray(e,e+f|0);if(n[e]===nt){let{declarationValue:u,procedure:E,stack:_}=r,{target:N}=u,{description:S}=E,{locals:k}=S,V;N.mutable?V=Object.freeze({name:N.name,data:{...r.type,mutable:N.mutable}}):V=Object.freeze({name:N.name,data:r.type}),_.set(N.name,V.data),k.push(V),M();return}b=A|0,p=c-T|0;let s=d(t);w(s,Vt);break}}},Nl=(c,n,e,f)=>{switch(a){case Bs:{let t=Object.seal({type:kt,unsafe:null,smart:null,value:null}),s=n.subarray(e,e+f|0);X(s,It)&&(t.unsafe=!0),X(s,ps)&&(t.smart=!0),r.value=t,a=Ha;break}case Ha:{if(n[e]===he){a=ca;return}b=A|0,p=c-T|0;let t=n.subarray(e,e+f|0),s=d(t);w(s,Ge);break}case ca:{let{stack:t,procedure:s}=r,o=n.subarray(e,e+f|0),u=d(o),E=t.get(u);E&&E.moved&&(b=A|0,p=c-T|0,re(`Moved variable used as value. Variable '${u}' was used while having been moved before.`)),a=$a,B(),r={stack:t,procedure:s,value:null},B(),a=Le,P=ke,l=!0;break}case $a:{if(n[e]===Se){let{value:u}=r;M(),r.value.value=je(u),M();return}b=A|0,p=c-T|0;let t=n.subarray(e,e+f|0),s=d(t);w(s,Ge);break}case aa:{let t=Object.seal({type:Et,link:null});r.value=t,a=za;break}case za:{if(n[e]===he){a=ua;return}b=A|0,p=c-T|0;let t=n.subarray(e,e+f|0),s=d(t);w(s,Ge);break}case ua:{let{stack:t,procedure:s}=r,o=n.subarray(e,e+f|0),u=d(o),E=t.get(u);E&&E.moved&&(b=A|0,p=c-T|0,re(`Moved variable used as value. Variable '${u}' was used while having been moved before.`)),a=Xa,B(),r={stack:t,procedure:s,value:null},B(),a=Le,P=ke,l=!0;break}case Xa:{if(n[e]===Se){let{value:u}=r;M(),r.value.link=je(u),M();return}b=A|0,p=c-T|0;let t=n.subarray(e,e+f|0),s=d(t);w(s,$e);break}case Ta:{let t=Object.seal({type:sn,trail:[]});r.value=t,a=Hn;break}case Hn:{if(n[e]===qe){a=Na;return}a=$n,l=!0;break}case Na:{let t=n.subarray(e,e+f|0),s=d(t);r.value.trail.push(s),a=da;break}case da:{if(n[e]===qe){a=Hn,l=!0;return}a=$n,l=!0;break}case $n:{M(),l=!0;break}case Ea:{let t=n.subarray(e,e+f|0),s=d(t),o=L.find(S=>S.name===s);if(!o){b=A|0,p=c-T|0,os(s);return}let{description:u}=o,{members:E}=u,_=E.some(S=>S.name==="constructor"&&S.type===st),N=Object.seal({type:Ue,explicitConstructor:_,name:s,literal:[],path:o.path});r.value=N,a=Ma;break}case Ma:{let t=n[e];if(t===he){a=wn,l=!0;return}if(t===Ke){a=ja;return}break}case ja:{B(),r=[],a=Fa,l=!0;break}case Fa:{a=wa,B(),r={data:null},B(),P=vt,a=bt,l=!0;break}case wa:{let t=n[e],{data:s}=r;if(M(),r.push(s),t===ge){a=Ms;return}if(t===nt){let o=r;M();let{value:u}=r,{name:E}=u,_=L.find(N=>N.type===Ve&&N.name===E);if(_){if(!(_.description.generics.length===o.length)){b=A|0,p=c-T|0,re(`Generic procedure '${E}' was provided with fewer or more than expect number of types. Expected: ${genericProcedure.description.generics.length}. Got: ${o.length}`);return}let S=lt(_.name,o);if(!L.some(k=>k.name===S)){let k=Qe(_,o);k.name=S,k.description.generics=[],L.push(k)}u.name=S}a=wn;break}}case wn:{let{value:t}=r,{explicitConstructor:s,...o}=t;if(t=Object.seal(o),n[e]===he){if(s){a=Ja;return}a=Yn;return}b=A|0,p=c-T|0;let E=n.subarray(e,e+f|0),_=d(E);w(_,Ge);break}case Yn:{if(n[e]===Oe)return;if(n[e]===ge){a=gn;return}a=gn,l=!0;break}case gn:{let t=n.subarray(e,e+f|0),s=d(t),{stack:o,procedure:u}=r;B();let E=Object.seal({name:s,value:null});r={procedure:u,stack:o,prop:E},a=_a;break}case _a:{let{stack:t,procedure:s}=r;if(n[e]===Os){a=ma,B(),r={stack:t,procedure:s,value:null},B(),a=Le,P=ke;return}b=A|0,p=c-T|0;let u=n.subarray(e,e+f|0),E=d(u);w(E,Gt);break}case ma:{let{value:t}=r;M();let{prop:s}=r;if(s.value=je(t),M(),r.value.literal.push(s),n[e]===ge){a=Yn;return}l=!0,a=pa;break}case pa:{if(n[e]===Oe){a=Gn;return}l=!0,a=Gn;break}case Gn:{let t=n[e];if(b=A|0,p=c-T|0,t===Se){let K=function(Z,me){let be=new Set(Z.map(x=>x.name));for(let x of me)if(!be.has(x.name))return x.name;return null},E=Z=>{let me=new Set;for(let be of Z){if(me.has(be.name))return be.name;me.add(be.name)}return!1},{value:_}=r,{literal:N}=_,S=L.find(Z=>Z.name===_.name&&Z.type===Ve),k=E(N);if(k){re(`Propery ${k} of ${S.name} was initialized multiple times during object declaration. Please remove unnecessary value.`);return}let V=S.description.members.filter(Z=>Z.type!==st),g=S.description.members.filter(Z=>Z.type!==st&&Z.value===void 0),H=K(N,g);if(H){re(`Properties ${H} of ${S.name} is missing in initialization without having been given a default value. Please give a value in initialization or provide a default value in type definition`);return}for(let Z of N){let me=ue(Z.value),be=N.indexOf(Z),x=V.find(Q=>Q.name===Z.name);x||re(`Invalid member name. Name ${Z.name} does not exist on object ${S.name}`),me.data.type!==Ue&&me.data.name!==x.data.name&&re(`Type mismatch in input for Object ${S.name}. At index ${be}, expected ${x.data.name} but received ${me.data.name}.`)}M();return}let s=n.subarray(e,e+f|0),o=d(s);w(o,$e);break}case Ja:{let u=function(_){let N=_.data.name,S=L.find(k=>k.name===N);if(S.type===Ve){let k=[],{members:V}=S.description;for(let g of V)g.data&&k.push({name:g.name,value:u(g)});return{type:Ue,name:N,literal:k,path:_.data.path}}else if(_.data.type===Me){let k=parseInt(_.data.length,10);return{type:Ue,literal:Array(k).fill(Uu),name:N,layout:Me,path:_.data.path}}else if(_.data.type===Pt){let k=parseInt(_.data.length,10);return{type:Ue,literal:Array(k).fill(tt),name:N,path:_.data.path}}else return{type:Ue,literal:Uu,name:N,path:_.data.path}},{value:t}=r,{literal:s,name:o}=t,E=L.find(_=>_.name===o);if(E){let{description:_}=E,{members:N}=_;for(let be of N)be.data&&s.push({name:be.name,value:u(be)});M(),M();let{stack:S,procedure:k,statements:V,declarationValue:g,inferenceValue:K}=r,H=g?.target.name;if(!H){H="literalObjectConstructor";let be=ue(t),{literal:x,...Q}=be.data,{locals:q}=k.description;q.push({name:H,data:Q}),S.set(H,Q)}K&&(K.data={type:ve,name:o,path:E.path},K.mutable&&(K.data.mutable=K.mutable),H&&r.stack.set(H,K.data)),g&&(g.source=t,V.push(g)),B();let Z=Object.seal({type:Mt,name:[H,_s],path:E.path,inputs:[]}),me=Object.seal({type:Fo,expression:Z});r={stack:S,procedure:k,drop:me,value:Z},a=Qn,P=Be,l=!0;return}break}case Qn:{let{stack:t,procedure:s}=r;if(n[e]===Se){a=qn,l=!0;return}a=Wa,B(),r={stack:t,procedure:s,value:null},B(),a=Le,P=ke,l=!0;break}case Wa:{let{value:t}=r;M();let{value:s,stack:o,procedure:u}=r,{inputs:E}=s;E.push(je(t));let _=n[e];if(_===Se){a=qn,l=!0;return}if(_===ge){a=Qn;return}b=A|0,p=c-T|0;let N=n.subarray(e,e+f|0),S=d(N);w(S,ln);break}case qn:{let{value:t,stack:s,drop:o}=r,u=s.get(t?.name[0]);if(u){let S=L.find(K=>K.name===u.name),k=S.description.members.find(K=>K.name===_s),V=t.inputs.filter(K=>K.type===Ue);for(let K of V){let H=t.inputs.indexOf(K);H>=0&&t.inputs[H]&&(t.inputs[H]={...t.inputs[H],name:k.description.inputs[H]?.data?.name||K.name,path:k.description.inputs[H]?.data?.path||K.path})}let g=t.inputs.map(K=>ue(K))||[];if(k.description.inputs.length!==g.length){b=A|0,p=c-T|0,re(`Mismatching number of parameters passed to constructor of object '${S.name}'. Expected: ${k.description.inputs.length}, Got: ${g.length}`);return}for(let K of k.description.inputs){let H=k.description.inputs.indexOf(K);if(K.data.name!==g[H].data.name){b=A|0,p=c-T|0,re(`Input type mismatch on index '${H+1}'. '${S.name}' expected ${K.data.name}, but was provided with a rather ${g[H].data.name}`);return}}}if(n[e]===Se){a=Za;return}b=A|0,p=c-T|0;let E=n.subarray(e,e+f|0),_=d(E);w(_,$e);break}case Za:{if(n[e]===Oe){let{drop:S}=r;M();let{statements:k}=r;k||M(),k&&k.push(S),M();return}let{value:s,stack:o,procedure:u}=r;if(M(),a===Fs){B(),r={stack:o,procedure:u,value:s},l=!0;return}b=A|0,p=c-T|0;let E=n.subarray(e,e+f|0),_=d(E);w(_,gt);break}case la:{let{stack:t}=r,s=n.subarray(e,e+f|0),o=d(s);if(t.has(o)){let S=t.get(o);if(S&&(S.moved&&(b=A|0,p=c-T|0,re(`Moved variable used as value. Variable '${o}' was used while having been moved before.`)),S.freed)){b=A|0,p=c-T|0,re(`Attempted to use '${o}', which has been freed. Ensure links are valid before use.`);return}let k=Object.freeze({type:ot,name:o});r.value=k,a=St;return}let u=S=>{let k=m[S];if(k.item.target){let V=k.item.target,g=_.item.stack.get(V.name);if(g)return g.name}else return k.item.value?.type==="expression"?u(S-1):null},E=m.length,_=m[E-2],N;if(_.item.target){let S=_.item.target;if(S.name||S.trail?.length===1){let k=_.item.stack.get(S.name||S.trail[0]);k&&(N=S.name?k.name:k.data?.name)}if(S.trail?.length>1){let k=JSON.parse(JSON.stringify(S.trail)),V=_.item.stack.get(S.trail[0]),g=L.find(H=>H.name===V.data.name&&H.path===V.data.path),K=1;for(let H=1;H<k.length;H++)V=g.description.members.find(Z=>Z.name===k[H]),H<k.length-1&&(g=L.find(Z=>Z.name===V.data.name&&Z.path===V.data.path));N=V.data.name}}else _.item.value?.type==="expression"&&(N=u(E-4));if(qs(c,n,e,f)){let S=o,k=Je(S),V=Object.freeze({type:Ue,literal:S,name:N||k,path:Ie});if(!k){b=A|0,p=c-T|0;let g=n.subarray(e,e+f|0),K=d(g);w(K,En)}Fe(V.name),r.value=V,a=St;return}if(ro(o)){let S=Object.freeze({type:Ue,literal:o,name:"Bool",path:Ie});r.value=S,Fe(S.name),a=St;return}if(n[e]===Yt){a=iu,l=!0;return}if(n[e]===sE){if(ws){if(ws=!1,a=St,r.value.literal.length>1){b=A|0,p=c-T|0,re("Type Mismatch: Use single quotes for a Char (one character) in Flogram. For Strings, use double quotes or ensure there's only one character within single quotes.");return}}else ws=!0;return}if(ws){let S=Object.freeze({type:Ue,literal:o,name:N||"Char",path:Ie});Fe(S.name),r.value=S;return}if(n[e]===at){a=Vn,l=!0;return}b=A|0,p=c-T|0,os(o),M();break}case iu:{if(n[e]===Yt){a=eo;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);console.log(o),w(o,Ge);break}case eo:{let t=n.subarray(e,e+f|0),s=d(t);if(f===0)return;if(a=Eu,n[e]===Yt){l=!0;return}else if(n[e]===Ke){l=!0;return}let o=Object.freeze({type:Ue,literal:s,name:Pt,path:Ie});r.value&&r.value.type===jt?r.value.values.push(o):r.value=o,Fe(o.name);break}case Eu:{let{stack:t,procedure:s}=r;if(n[e]===Yt){if(r.value.type===jt&&n[e+1]===Yt){a=fu;return}M();return}else if(n[e]===Ke){a=_u,B(),r=Object.seal({procedure:s,stack:t,value:null}),B(),P=ke,a=Le;return}b=A|0,p=c-T|0;let o=n.subarray(e,e+f|0),u=d(o);w(u,Ge);break}case _u:{let t=n.subarray(e,e+f|0),s=d(t),{value:o}=r;if(M(),!r.value||r.value.type!==jt){let u=Object.seal({type:jt,values:[]});r.value&&u.values.push(r.value),r.value=u}r.value.values.push(o),a=eo;break}case fu:{M();break}case xn:{B(),a=Qa,r={data:null},B(),P=vt,a=bt,l=!0;break}case Qa:{let t=n[e],{data:s}=r;M();let{stack:o,procedure:u}=r,E=Object.seal({type:Ue,literal:[],name:s.name,length:null,layout:s.type,path:s.path});if(B(),r={stack:o,procedure:u,value:E},t===he){a=qa;return}b=A|0,p=c-T|0;let _=n.subarray(e,e+f|0),N=d(_);w(N,Ge);break}case qa:{let t=n.subarray(e,e+f|0);if(X(zo,t)){a=xa;return}b=A|0,p=c-T|0;let s=d(t);w(s,As);break}case xa:{let t=n.subarray(e,e+f|0);if(X(rn,t)){a=eu;return}b=A|0,p=c-T|0;let s=d(t);w(s,Gt);break}case eu:{if(Ye(c,n,e,f)){let o=n.subarray(e,e+f|0),u=d(o);b=A|0,p=c-T|0,Pe(u);return}let t=n.subarray(e,e+f|0),s=d(t);r.value.length=s,a=su;break}case su:{let t=n[e];if(t===ge){let{stack:E,procedure:_}=r,N=[];B(),r={stack:E,procedure:_,value:N},a=nu;return}if(t===Se){let{value:E}=r;M(),r.value=E,a=St;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,$e);break}case nu:{if(n[e]===at){a=ou;return}b=A|0,p=c-T|0;let t=n.subarray(e,e+f|0),s=d(t);w(s,fn);break}case ou:{if(a=tu,n[e]===Zt)return;l=!0;break}case tu:{let t=n.subarray(e,e+f|0);if(n[e]===Se){let{value:s}=r;M();let{value:o}=r;M(),o.literal=s,r.value=o,M();return}B(),a=js,l=!0;break}case Vn:{let t=n.subarray(e,e+f|0);if(n[e]===at){r.value=[],a=St,B(),a=js;return}break}case js:{let{stack:t,procedure:s}=r;if(a=Fs,B(),r.value.length===0&&n[e]===Zt){r={stack:t,procedure:s,value:null},a=Fs,l=!0;break}r={stack:t,procedure:s,value:null},B(),a=Le,P=ke,l=!0;break}case Fs:{let t=n[e],{value:s}=r;if(M(),s!==null&&r.value.push(s),t===ge){a=js;return}if(t===Zt){let o=m.length,u=m[o-3],E=u.item.declarationValue?.target,_=u.item.stack.get(E?.name);if(u.situationSection!==xn){let N=!1,S;if(!_){if(r.value?.length>=1)if(S=ue(r.value[0]),S){(S.data.layout===Me||S.data.type===Me||Array.isArray(S.data.literal))&&(N=!0);for(let V=1;V<r.value.length;V++){let g=ue(r.value[V]);if((g.data.layout===Me||g.data.type===Me||Array.isArray(g.data.literal))&&(N=!0),g.data.name!==S.data.name||g.data.path!==S.data.path){b=A|0,p=c-T|0,re(`Type mismatch in array initialization. Expected all items to be of type ${S.data.name} from ${S.data.path}, but found type ${g.data.name} from ${g.data.path} at position ${V}. Ensure all items in the array have the same type.`);return}}}else{b=A|0,p=c-T|0;let V=n.subarray(e,e+f|0),g=d(V);w(g,En);return}else S={data:{name:"FP32",path:"Flogram"}};Fe(S.data.name)}if(_?.length&&parseInt(_.length,10)<r.value.length){b=A|0,p=c-T|0,re(`Too much data for an array. Array is defined to have a maximum of ${_.length} but value assigned has ${r.value.length}. Consider increasing size of the array or reducing the number of elements.`);return}let k=Object.freeze({type:Ue,literal:r.value,length:_?.length||r.value.length,name:_?.name||S.data.name,layout:Me,contains:N?Me:null,path:_?.path||S.data.path});r.value=k}M();return}break}case St:{let t=n[e];if(t===qe){let{stack:s,value:o}=r,u=[],E=Object.freeze({type:tn,value:o,trail:u});r.value=E,B(),r=Object.seal({stack:s,trail:u,value:o}),a=jn;return}else if(t===at){let{value:s}=r,o=Object.seal({type:Es,array:s,index:null});r.value=o,l=!0,a=Kn;return}M(),l=!0;break}case ia:{if(n[e]!==qe){let s=n.subarray(e,e+f|0),o=d(s);M(),M(),l=!0;return}a=jn;break}case jn:{let{stack:t,value:s,trail:o}=r,u=n.subarray(e,e+f|0),E=d(u),_,N,S=!1,k;try{let V=ue(s);V&&(_=V.data)}catch{}if((s.type===ot||s.type===Et||s.type===kt||Ot(s))&&!_){let V=We(s);if(o.length===0)_=t.get(V);else{let g=o.length-1,K=t.get(V),H=L.find(Q=>Q.name===K.name),{description:Z}=H,{members:me}=Z,be=me.find(Q=>Q.name===o[g]),{data:x}=be;if(_=x,x.freed){b=A|0,p=c-T|0,re(`Attempted to use '${o.join(".")}', which has been freed. Ensure links are valid before use.`);return}}}if(_){let{name:V,path:g}=_,K=`${g}.${V}`,H=ne.get(K);H.type===Ve&&(N=H)}if(N){let{description:V}=N,{members:g}=V;for(let K of g)if(K.name===E){S=!0;break}if(!S){b=A|0,p=c-T|0,mt(E,s.name);return}}if(s.value===rt||s.link===rt){if(!t.get(E)){b=A|0,p=c-T|0,mt(E,`${rt}(current object in definition)`);return}S=!0}if(!S){b=A|0,p=c-T|0,mt(E,s.name);return}o.push(E),a=ia;break}case ba:{let{stack:t}=r,s=n.subarray(e,e+f|0),o=d(s);if(t.has(o)){let u=Object.seal({type:Es,array:{type:ot,name:o},index:null});r.value=u}a=Kn;break}case Kn:{if(n[e]===at){a=Oa;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,fn);break}case Oa:{let{stack:t,procedure:s}=r;a=Aa,B(),r={stack:t,procedure:s,value:null},B(),a=Le,P=ke,l=!0;break}case Aa:{if(n[e]===Zt){let{value:E}=r;M();let _=ue(E);if(_.data.mutable?r.value.index=Object.seal({type:Et,link:E}):r.value.index=E,!_||![ct,"U32","I16","U16","U8","I8"].includes(_.data.name)){b=A|0,p=c-T|0,re("Invalid index. Array index should be a valid I32 variable");return}a=St;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,er);break}case Ds:{let{stack:t}=r,s=n.subarray(e,e+f|0),o=d(s),u=U.find(_=>_.type===st&&_.name===o),E=Object.seal({type:Mt,name:o,path:u?.path||Ie,inputs:[]});if(r.value=E,t.has(o)){r.value.name=[o],a=Ia;return}a=Zn;break}case Ia:{let t=n.subarray(e,e+f|0),s=d(t),o=n[e];if(o===qe)return;if(o===he){a=Zn,l=!0;return}if(Ye(c,n,e,f)){b=A|0,p=c-T|0,Pe(s);return}r.value.name.push(s);break}case Zn:{let t=n[e];if(t===he){a=Fn,l=!0;return}if(t===Ke){a=Da;return}break}case Fn:{if(n[e]===he){a=ys;return}break}case Da:{B(),r=[],a=Ms,l=!0;break}case Ms:{a=ya,B(),r={data:null},B(),P=vt,a=bt,l=!0;break}case ya:{let t=n[e],{data:s}=r;if(M(),r.push(s),t===ge){a=Ms;return}if(t===nt){let o=r;M();let{value:u}=r,{name:E}=u,_=U.find(N=>N.type===st&&N.name===E);if(_){if(!(_.description.generics.length===o.length)){b=A|0,p=c-T|0,re(`Generic procedure '${E}' was provided with fewer or more than expect number of types. Expected: ${_.description.generics.length}. Got: ${o.length}`);return}let S=lt(_.name,o);if(!U.some(k=>k.name===S)){let k=Qe(_,o);k.name=S,k.description.generics=[],U.push(k)}u.name=S}a=Fn;break}}case ys:{let t=n[e],s=n.subarray(e,e+f|0);if(t===Oe||X(s,Rt))return;if(t===Se){let E=r.value?.inputs?.map(K=>ue(K))||[],[_,...N]=E,{value:S}=r,{name:k}=S,V=rs[k],g=(K,H,Z,me)=>{for(let be in K.description?.members){let x=[K.description.members[be].data.name,...H.map(Q=>Q.description.members[be].data.name)];if(x.some(Q=>!Nt.includes(Q))){let Q=x.map(q=>L.find(te=>te.name===q));Q.every(Boolean)&&g(K,Q,Z,me)}else{let Q=Z.find(q=>q.description&&Array.isArray(q.description.inputs)?q.description.inputs.length!==x.length?!1:q.description.inputs.every((te,ie)=>te.data.name===x[ie]):!1);if(Q)U.push(Q),oe.set(me,Q);else{b=A|0,p=c-T|0,Xt(`${x.join(", ")} in ${me}`);return}}}};if(V){let K=V.find(H=>H.description&&Array.isArray(H.description.inputs)?H.description.inputs.length!==E.length?!1:H.description.inputs.every((Z,me)=>Z.data.name===E[me].data.name):!1);if(K)U.push(K),oe.set(k,K);else if(E.length>=1){if(E.some(H=>H.data.name!==_.data.name)){b=A|0,p=c-T|0,ul(E.map(H=>H.data?.name)?.join(", "));return}if(E[0]?.data.type===is){let H=V.find(me=>me.description.inputs.length===E.length&&E.length>0?me.description.inputs[0].data.name===Bu:!0),Z=JSON.parse(JSON.stringify(H).replace(new RegExp(Bu,"g"),E[0].data.name));U.push(Z),oe.set(k,Z)}else if(!Nt.includes(_.data.name)||N.some(H=>!Nt.includes(H.data.name))){let H=L.find(me=>me.name===_.data.name),Z=N.map(me=>L.find(be=>be.name===me.data.name));H&&Z.every(Boolean)&&g(H,Z,V,k)}else{b=A|0,p=c-T|0,Xt(`${_.data.name,N.map(H=>H.data.name)?.join(", ")} in ${k}`);return}}else{b=A|0,p=c-T|0,Xt(`${E.map(H=>H.data.name)?.join(", ")} in ${k}`);return}}else if(k!==Ff){let K,H=U.find(be=>be.type===st&&be.name===k);if(typeof k=="object"&&r.stack.has(k[0])){let be=k[k.length-2]||k[0],x=r.stack.get(be);if(x){let Q=L.find(q=>q.type===Ve&&q.name===x.name);Q&&(r.value.path=Q.path,K=Q.description.members.find(q=>q.type===st&&q.name===k[k.length-1]))}}let Z=r.procedure.name===k?r.procedure:null,me=K||H||Z;if(me){let{description:be}=me,{inputs:x}=be,{value:Q}=r,{inputs:q}=Q;if(x.length!==q.length){b=A|0,p=c-T|0,re(`Procedure '${k}' was provided with fewer or more than expect number of inputs. Please make sure you are passing the right number of inputs to the procedure.`);return}for(let te=0;te<x.length;te++){let ie=ue(q[te]);if(ie){if(x[te].data.name!==ie.data.name){b=A|0,p=c-T|0,re(`The procedure '${typeof k=="object"?k.join("."):k}' received an input of incorrect type at position ${te+1}. Expected: '${x[te].data.name}', but received: '${ie.data.name}'.`);return}if(x[te].data.mutable&&!ie.data.mutable){b=A|0,p=c-T|0,re(`The procedure '${typeof k=="object"?k.join("."):k}' received an immutable input at position ${te+1} while it expects a mutable input. Expected: mutable '${x[te].data.name}', received: immutable '${ie.data.name}'.`);return}x[te].data.mutable&&ie.data.mutable}else{b=A|0,p=c-T|0,Xt(q[te]);return}}}else{b=A|0,p=c-T|0,io(k);return}}M();return}if(Ye(c,n,e,f)&&n[e]!=at){let E=n.subarray(e,e+f|0),_=d(E);b=A|0,p=c-T|0,Pe(_);return}let{procedure:o,stack:u}=r;a=fa,B(),r=Object.seal({procedure:o,stack:u,value:null}),B(),P=ke,a=Le,l=!0;break}case fa:{let{value:t}=r;M();let{value:s}=r,{inputs:o}=s;s.path!==Ie?o.push(t):o.push(je(t));let u=n[e];if(u===ge){a=ys;return}if(u===Se){a=ys,l=!0;return}b=A|0,p=c-T|0;let E=n.subarray(e,e+f|0),_=d(E);w(_,$e);break}case zn:{let t=n.subarray(e,e+f|0),s=d(t),o=L.find(E=>E.type===yt&&E.name===s);if(o){let E=Object.seal({type:"literal",literal:null,name:o.name,path:o.path});r.value=E,a=ha;return}let u=L.find(E=>E.type===yt&&E.description.labels.find(_=>_.name===s));if(u){let E=Object.freeze({type:"literal",literal:s,name:u.name,path:u.path});r.value=E,M();return}b=A|0,p=c-T|0,mt(s);break}case ha:{if(n[e]===qe){a=Sa;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,tr);break}case Sa:{let t=n.subarray(e,e+f|0),s=d(t);if(L.find(u=>u.type===yt&&u.name===r.value.name&&u.description.labels.find(E=>E.name===s))){r.value.literal=s,M();return}b=A|0,p=c-T|0,mt(s);break}case ka:{let t=Object.seal({type:wo,layout:null,data:null,value:null});r.value=t,a=Pa;break}case Pa:{if(n[e]===Ke){a=La;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,Qt);break}case La:{let t=n.subarray(e,e+f|0),s=d(t);if(Ye(c,n,e,f)){b=A|0,p=c-T|0,Pe(s);return}if(X(ms,t)){a=Jn,B(),r={...r,data:null},B(),P=vt,a=bt,l=!0;return}if(X(t,It)||X(t,Lt)){a=Jn,B(),r={...r,data:null},B(),P=Kt,a=so,l=!0;return}if(X(t,bs)){b=A|0,p=c-T|0;let u=n.subarray(e,e+f|0),E=d(u);w(E,As);return}let o=Fe(s);o&&(r.value.data=o),a=Xn;break}case Jn:{let{data:t}=r;M(),r.value.data=t,l=!0,a=Xn;break}case Xn:{if(n[e]===nt){a=Ra;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,Vt);break}case Ra:{if(n[e]===qe){a=Ca;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,tr);break}case Ca:{let t=n.subarray(e,e+f|0),s=d(t);if(r.value.layout=s,X(t,Jf)){a=Wn;return}if(X(t,Wf)){a=va;return}b=A|0,p=c-T|0;let o=d(t);w(o,As);break}case va:{if(n[e]===he){a=Ua;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,Ge);break}case Ua:{let{procedure:t,stack:s}=r;if(Ye(c,n,e,f)){let o=n.subarray(e,e+f|0),u=d(o);b=A|0,p=c-T|0,Pe(u);return}a=Ba,B(),r=Object.seal({procedure:t,stack:s,value:null}),B(),P=ke,a=Le,l=!0;break}case Ba:{let{value:t}=r;if(M(),r.value.value=je(t),n[e]===Se){a=Wn;return}b=A|0,p=c-T|0;let o=n.subarray(e,e+f|0),u=d(o);w(u,$e);break}case Wn:{M(),l=!0;break}case Ya:{let t=Object.seal({type:nn,value:null});r.value=t,a=ga;break}case ga:{if(n[e]===he){a=Ga;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,Ge);break}case Ga:{let{procedure:t,stack:s}=r;if(Ye(c,n,e,f)){let o=n.subarray(e,e+f|0),u=d(o);b=A|0,p=c-T|0,Pe(u);return}a=Va,B(),r=Object.seal({procedure:t,stack:s,value:null}),B(),P=ke,a=Le,l=!0;break}case Va:{let{stack:t,value:s}=r;M();let o;if(s.type===ot)o=s.name;else if(s.type===Et)o=s.link;else if(s.type===kt)o=s.value;else{b=A|0,p=c-T|0,re("Non-movable type passed to move procedure. Please check types that can be moved and make sure your parameter's type is one of them.");return}let u=t.get(o);if(u&&t.set(o,{...u,moved:!0}),r.value.value=je(s),n[e]===Se){a=Ka;return}b=A|0,p=c-T|0;let _=n.subarray(e,e+f|0),N=d(_);w(N,$e);break}case Ka:{M(),l=!0;break}case ru:{let t=Object.seal({type:on,value:null});r.value=t,Fe(ct),a=cu;break}case cu:{if(n[e]===he){a=au;return}b=A|0,p=c-T|0;let s=n.subarray(e,e+f|0),o=d(s);w(o,Ge);break}case au:{let{procedure:t,stack:s}=r;if(Ye(c,n,e,f)){let o=n.subarray(e,e+f|0),u=d(o);b=A|0,p=c-T|0,Pe(u);return}a=uu,B(),r=Object.seal({procedure:t,stack:s,value:null}),B(),P=ke,a=Le,l=!0;break}case uu:{let{stack:t,value:s}=r;M();let o,u=ue(s);if(u.data.name===Pt||u.data.name===Me||u.data.layout===Pt||u.data.layout===Me||u.data.type===Pt||u.data.type===Me||(b=A|0,p=c-T|0,re(`Provided type '${u.data.name}' cannot be used here as it's neither a string nor an array.`)),r.value.value=s,n[e]===Se){a=lu;return}b=A|0,p=c-T|0;let _=n.subarray(e,e+f|0),N=d(_);w(N,$e);break}case lu:{M(),l=!0;break}}},dl=(c,n,e,f)=>{switch(a){case Xr:{let t=Object.seal({type:tt,path:[]}),s=Object.seal({type:Bf,source:t,alias:tt});r=Object.seal({import:s,source:t}),a=Jr;break}case Jr:{let t=n[e],{source:s}=r;if(t===nE&&n[e+1]===cn){s.type=ot,a=Wr,B(),r=[],B(),a=Tn;return}if(Ye(c,n,e,f)){b=A|0,p=c-T|0,Pe(name);return}s.type=Df,a=LE,l=!0;break}case Wr:{let t=n[e],s=r;M();let{source:o}=r;o.path.push(s.join("")),t===cn&&(B(),r=[],B(),a=Tn),t===Oe&&(a=Zr,l=!0);break}case Tn:{let t=n[e];if(t===cn){M(),l=!0;return}if(t===Oe){M(),l=!0;return}let s=n.subarray(e,e+f|0),o=d(s);r.push(o);return}case Zr:{let t=s=>{let o=!0,u=null,E=null,_=tl(R);_.on(zt,g=>{u=g}),_.on(Re,g=>{E=g});let N=new J({tabSize:4});if(N.on("token",(g,K,H,Z)=>{_.feed(g,K,H,Z)}),N.on("error",()=>{o=!1}),N.feed(s),N.done(),N.close(),_.done(),!o||E){console.error("Tokenizer or Parser error occurred.",E);return}if(!u){console.error("Invalid representation after parsing.");return}let{exports:S,data:k}=u;for(let g of S){let K=u[g.path]?.find(H=>H.name===g.name);K&&(g.path===oo&&(L.push(K),de({name:K.name,path:K.path,type:ve})),g.path===Du&&U.push(K))}let V=k.filter(g=>g.type===yf);L.unshift(...V)};if(v&&v.length>0){let s=v.find(o=>o.path===r.source.path.join("/"));if(s){let o=ce(s.data);t(o)}else b=A|0,p=c-T|0,re("NO FILES WERE FOUND: ",r.source.path)}else b=A|0,p=c-T|0,re("NO FILES WERE FOUND: ",r.source.path);M();break}}},Il=(c,n)=>{switch(c){case zt:{I.push(n);break}case Re:{h.push(n);break}}},B=()=>{let c=Object.freeze({item:r,indentation:_e,situationGeneral:P,situationSection:a});m.push(c)},M=()=>{let c=m.pop();return r=c.item,_e=c.indentation,P=c.situationGeneral,a=c.situationSection,c},Jt=(c,n,e,f)=>{if(C)return;let t=()=>{G=!0,T=c|0,A=A+1};Te=c+f|0;let s=n[e];if(s!==tE){if(s===Oe&&G){t();return}for(G=!1,l=!0;l;)switch(l=!1,P){case ke:{ll(c,n,e,f);break}case sr:{il(c,n,e,f);break}case qt:{El(c,n,e,f);break}case xt:{fl(c,n,e,f);break}case nr:{_l(c,n,e,f);break}case _n:{pl(c,n,e,f);break}case or:{bl(c,n,e,f);break}case rr:{ml(c,n,e,f);break}case ye:{Ol(c,n,e,f);break}case vt:{Al(c,n,e,f);break}case Be:{Nl(c,n,e,f);break}case Kt:{Tl(c,n,e,f);break}case cr:{dl(c,n,e,f);break}default:throw un}s===Oe&&(Mu.default.diff(r,Ee)&&t(),Ee=JSON.parse(JSON.stringify(r)))}};return Object.freeze({done:()=>{if(Jt(Te,Ft,0,Ft.length),Te=Te+Ft.length|0,Jt(Te,wt,0,wt.length),Te=Te+wt.length|0,Jt(Te,Ft,0,Ft.length),Te=Te+Ft.length|0,y){i.emit(zt,null);return}i.emit(zt,se)},feed:Jt,on:Il})},RE=Object.freeze({create:tl,...oE,...lE,...PE}),n_=RE;export{n_ as default};
/*! Bundled license information:

eventemitter2/lib/eventemitter2.js:
  (*!
   * EventEmitter2
   * https://github.com/hij1nx/EventEmitter2
   *
   * Copyright (c) 2013 hij1nx
   * Licensed under the MIT license.
   *)
*/
