var Fl=Object.create;var To=Object.defineProperty;var jl=Object.getOwnPropertyDescriptor;var wl=Object.getOwnPropertyNames;var Yl=Object.getPrototypeOf,gl=Object.prototype.hasOwnProperty;var Js=(R,L)=>()=>(L||R((L={exports:{}}).exports,L),L.exports);var Gl=(R,L,v,H)=>{if(L&&typeof L=="object"||typeof L=="function")for(let z of wl(L))!gl.call(R,z)&&z!==v&&To(R,z,{get:()=>L[z],enumerable:!(H=jl(L,z))||H.enumerable});return R};var No=(R,L,v)=>(v=R!=null?Fl(Yl(R)):{},Gl(L||!R||!R.__esModule?To(v,"default",{value:R,enumerable:!0}):v,R));var So=Js((Io,ho)=>{(function(R){var L=Object.hasOwnProperty,v=Array.isArray?Array.isArray:function(p){return Object.prototype.toString.call(p)==="[object Array]"},H=10,z=typeof process=="object"&&typeof process.nextTick=="function",se=typeof Symbol=="function",ie=typeof Reflect=="object",me=typeof setImmediate=="function",Ie=me?setImmediate:setTimeout,_e=se?ie&&typeof Reflect.ownKeys=="function"?Reflect.ownKeys:function(i){var p=Object.getOwnPropertyNames(i);return p.push.apply(p,Object.getOwnPropertySymbols(i)),p}:Object.keys;function Te(){this._events={},this._conf&&Be.call(this,this._conf)}function Be(i){i&&(this._conf=i,i.delimiter&&(this.delimiter=i.delimiter),i.maxListeners!==R&&(this._maxListeners=i.maxListeners),i.wildcard&&(this.wildcard=i.wildcard),i.newListener&&(this._newListener=i.newListener),i.removeListener&&(this._removeListener=i.removeListener),i.verboseMemoryLeak&&(this.verboseMemoryLeak=i.verboseMemoryLeak),i.ignoreErrors&&(this.ignoreErrors=i.ignoreErrors),this.wildcard&&(this.listenerTree={}))}function Fe(i,p){var h="(node) warning: possible EventEmitter memory leak detected. "+i+" listeners added. Use emitter.setMaxListeners() to increase limit.";if(this.verboseMemoryLeak&&(h+=" Event name: "+p+"."),typeof process<"u"&&process.emitWarning){var S=new Error(h);S.name="MaxListenersExceededWarning",S.emitter=this,S.count=i,process.emitWarning(S)}else console.error(h),console.trace&&console.trace()}var Qe=function(i,p,h){var S=arguments.length;switch(S){case 0:return[];case 1:return[i];case 2:return[i,p];case 3:return[i,p,h];default:for(var l=new Array(S);S--;)l[S]=arguments[S];return l}};function qe(i,p){for(var h={},S,l=i.length,C=p?p.length:0,D=0;D<l;D++)S=i[D],h[S]=D<C?p[D]:R;return h}function xe(i,p,h){this._emitter=i,this._target=p,this._listeners={},this._listenersCount=0;var S,l;if((h.on||h.off)&&(S=h.on,l=h.off),p.addEventListener?(S=p.addEventListener,l=p.removeEventListener):p.addListener?(S=p.addListener,l=p.removeListener):p.on&&(S=p.on,l=p.off),!S&&!l)throw Error("target does not implement any known event API");if(typeof S!="function")throw TypeError("on method must be a function");if(typeof l!="function")throw TypeError("off method must be a function");this._on=S,this._off=l;var C=i._observers;C?C.push(this):i._observers=[this]}Object.assign(xe.prototype,{subscribe:function(i,p,h){var S=this,l=this._target,C=this._emitter,D=this._listeners,G=function(){var j=Qe.apply(null,arguments),Y={data:j,name:p,original:i};if(h){var P=h.call(l,Y);P!==!1&&C.emit.apply(C,[Y.name].concat(j));return}C.emit.apply(C,[p].concat(j))};if(D[i])throw Error("Event '"+i+"' is already listening");this._listenersCount++,C._newListener&&C._removeListener&&!S._onNewListener?(this._onNewListener=function(j){j===p&&D[i]===null&&(D[i]=G,S._on.call(l,i,G))},C.on("newListener",this._onNewListener),this._onRemoveListener=function(j){j===p&&!C.hasListeners(j)&&D[i]&&(D[i]=null,S._off.call(l,i,G))},D[i]=null,C.on("removeListener",this._onRemoveListener)):(D[i]=G,S._on.call(l,i,G))},unsubscribe:function(i){var p=this,h=this._listeners,S=this._emitter,l,C,D=this._off,G=this._target,j;if(i&&typeof i!="string")throw TypeError("event must be a string");function Y(){p._onNewListener&&(S.off("newListener",p._onNewListener),S.off("removeListener",p._onRemoveListener),p._onNewListener=null,p._onRemoveListener=null);var P=F.call(S,p);S._observers.splice(P,1)}if(i){if(l=h[i],!l)return;D.call(G,i,l),delete h[i],--this._listenersCount||Y()}else{for(C=_e(h),j=C.length;j-- >0;)i=C[j],D.call(G,i,h[i]);this._listeners={},this._listenersCount=0,Y()}}});function mt(i,p,h,S){var l=Object.assign({},p);if(!i)return l;if(typeof i!="object")throw TypeError("options must be an object");var C=Object.keys(i),D=C.length,G,j,Y;function P(c){throw Error('Invalid "'+G+'" option value'+(c?". Reason: "+c:""))}for(var r=0;r<D;r++){if(G=C[r],!S&&!L.call(p,G))throw Error('Unknown "'+G+'" option');j=i[G],j!==R&&(Y=h[G],l[G]=Y?Y(j,P):j)}return l}function re(i,p){return(typeof i!="function"||!i.hasOwnProperty("prototype"))&&p("value must be a constructor"),i}function ge(i){var p="value must be type of "+i.join("|"),h=i.length,S=i[0],l=i[1];return h===1?function(C,D){if(typeof C===S)return C;D(p)}:h===2?function(C,D){var G=typeof C;if(G===S||G===l)return C;D(p)}:function(C,D){for(var G=typeof C,j=h;j-- >0;)if(G===i[j])return C;D(p)}}var et=ge(["function"]),it=ge(["object","function"]);function Tt(i,p,h){var S,l,C=0,D,G=new i(function(j,Y,P){h=mt(h,{timeout:0,overload:!1},{timeout:function(Se,he){return Se*=1,(typeof Se!="number"||Se<0||!Number.isFinite(Se))&&he("timeout must be a positive number"),Se}}),S=!h.overload&&typeof i.prototype.cancel=="function"&&typeof P=="function";function r(){l&&(l=null),C&&(clearTimeout(C),C=0)}var c=function(Se){r(),j(Se)},pe=function(Se){r(),Y(Se)};S?p(c,pe,P):(l=[function(Se){pe(Se||Error("canceled"))}],p(c,pe,function(Se){if(D)throw Error("Unable to subscribe on cancel event asynchronously");if(typeof Se!="function")throw TypeError("onCancel callback must be a function");l.push(Se)}),D=!0),h.timeout>0&&(C=setTimeout(function(){var Se=Error("timeout");Se.code="ETIMEDOUT",C=0,G.cancel(Se),Y(Se)},h.timeout))});return S||(G.cancel=function(j){if(l){for(var Y=l.length,P=1;P<Y;P++)l[P](j);l[0](j),l=null}}),G}function F(i){var p=this._observers;if(!p)return-1;for(var h=p.length,S=0;S<h;S++)if(p[S]._target===i)return S;return-1}function B(i,p,h,S,l){if(!h)return null;if(S===0){var C=typeof p;if(C==="string"){var D,G,j=0,Y=0,P=this.delimiter,r=P.length;if((G=p.indexOf(P))!==-1){D=new Array(5);do D[j++]=p.slice(Y,G),Y=G+r;while((G=p.indexOf(P,Y))!==-1);D[j++]=p.slice(Y),p=D,l=j}else p=[p],l=1}else C==="object"?l=p.length:(p=[p],l=1)}var c=null,pe,Se,he,N,d,Oe=p[S],Nt=p[S+1],O,b;if(S===l)h._listeners&&(typeof h._listeners=="function"?(i&&i.push(h._listeners),c=[h]):(i&&i.push.apply(i,h._listeners),c=[h]));else if(Oe==="*"){for(O=_e(h),G=O.length;G-- >0;)pe=O[G],pe!=="_listeners"&&(b=B(i,p,h[pe],S+1,l),b&&(c?c.push.apply(c,b):c=b));return c}else if(Oe==="**"){for(d=S+1===l||S+2===l&&Nt==="*",d&&h._listeners&&(c=B(i,p,h,l,l)),O=_e(h),G=O.length;G-- >0;)pe=O[G],pe!=="_listeners"&&(pe==="*"||pe==="**"?(h[pe]._listeners&&!d&&(b=B(i,p,h[pe],l,l),b&&(c?c.push.apply(c,b):c=b)),b=B(i,p,h[pe],S,l)):pe===Nt?b=B(i,p,h[pe],S+2,l):b=B(i,p,h[pe],S,l),b&&(c?c.push.apply(c,b):c=b));return c}else h[Oe]&&(c=B(i,p,h[Oe],S+1,l));if(Se=h["*"],Se&&B(i,p,Se,S+1,l),he=h["**"],he)if(S<l)for(he._listeners&&B(i,p,he,l,l),O=_e(he),G=O.length;G-- >0;)pe=O[G],pe!=="_listeners"&&(pe===Nt?B(i,p,he[pe],S+2,l):pe===Oe?B(i,p,he[pe],S+1,l):(N={},N[pe]=he[pe],B(i,p,{"**":N},S+1,l)));else he._listeners?B(i,p,he,l,l):he["*"]&&he["*"]._listeners&&B(i,p,he["*"],l,l);return c}function U(i,p,h){var S=0,l=0,C,D=this.delimiter,G=D.length,j;if(typeof i=="string")if((C=i.indexOf(D))!==-1){j=new Array(5);do j[S++]=i.slice(l,C),l=C+G;while((C=i.indexOf(D,l))!==-1);j[S++]=i.slice(l)}else j=[i],S=1;else j=i,S=i.length;if(S>1){for(C=0;C+1<S;C++)if(j[C]==="**"&&j[C+1]==="**")return}var Y=this.listenerTree,P;for(C=0;C<S;C++)if(P=j[C],Y=Y[P]||(Y[P]={}),C===S-1)return Y._listeners?(typeof Y._listeners=="function"&&(Y._listeners=[Y._listeners]),h?Y._listeners.unshift(p):Y._listeners.push(p),!Y._listeners.warned&&this._maxListeners>0&&Y._listeners.length>this._maxListeners&&(Y._listeners.warned=!0,Fe.call(this,Y._listeners.length,P))):Y._listeners=p,!0;return!0}function J(i,p,h,S){for(var l=_e(i),C=l.length,D,G,j,Y=i._listeners,P;C-- >0;)G=l[C],D=i[G],G==="_listeners"?j=h:j=h?h.concat(G):[G],P=S||typeof G=="symbol",Y&&p.push(P?j:j.join(this.delimiter)),typeof D=="object"&&J.call(this,D,p,j,P);return p}function W(i){for(var p=_e(i),h=p.length,S,l,C;h-- >0;)l=p[h],S=i[l],S&&(C=!0,l!=="_listeners"&&!W(S)&&delete i[l]);return C}function ae(i,p,h){this.emitter=i,this.event=p,this.listener=h}ae.prototype.off=function(){return this.emitter.off(this.event,this.listener),this};function ne(i,p,h){if(h===!0)l=!0;else if(h===!1)S=!0;else{if(!h||typeof h!="object")throw TypeError("options should be an object or true");var S=h.async,l=h.promisify,C=h.nextTick,D=h.objectify}if(S||C||l){var G=p,j=p._origin||p;if(C&&!z)throw Error("process.nextTick is not supported");l===R&&(l=p.constructor.name==="AsyncFunction"),p=function(){var Y=arguments,P=this,r=this.event;return l?C?Promise.resolve():new Promise(function(c){Ie(c)}).then(function(){return P.event=r,G.apply(P,Y)}):(C?process.nextTick:Ie)(function(){P.event=r,G.apply(P,Y)})},p._async=!0,p._origin=j}return[p,D?new ae(this,i,p):this]}function ee(i){this._events={},this._newListener=!1,this._removeListener=!1,this.verboseMemoryLeak=!1,Be.call(this,i)}ee.EventEmitter2=ee,ee.prototype.listenTo=function(i,p,h){if(typeof i!="object")throw TypeError("target musts be an object");var S=this;h=mt(h,{on:R,off:R,reducers:R},{on:et,off:et,reducers:it});function l(C){if(typeof C!="object")throw TypeError("events must be an object");var D=h.reducers,G=F.call(S,i),j;G===-1?j=new xe(S,i,h):j=S._observers[G];for(var Y=_e(C),P=Y.length,r,c=typeof D=="function",pe=0;pe<P;pe++)r=Y[pe],j.subscribe(r,C[r]||r,c?D:D&&D[r])}return v(p)?l(qe(p)):l(typeof p=="string"?qe(p.split(/\s+/)):p),this},ee.prototype.stopListeningTo=function(i,p){var h=this._observers;if(!h)return!1;var S=h.length,l,C=!1;if(i&&typeof i!="object")throw TypeError("target should be an object");for(;S-- >0;)l=h[S],(!i||l._target===i)&&(l.unsubscribe(p),C=!0);return C},ee.prototype.delimiter=".",ee.prototype.setMaxListeners=function(i){i!==R&&(this._maxListeners=i,this._conf||(this._conf={}),this._conf.maxListeners=i)},ee.prototype.getMaxListeners=function(){return this._maxListeners},ee.prototype.event="",ee.prototype.once=function(i,p,h){return this._once(i,p,!1,h)},ee.prototype.prependOnceListener=function(i,p,h){return this._once(i,p,!0,h)},ee.prototype._once=function(i,p,h,S){return this._many(i,1,p,h,S)},ee.prototype.many=function(i,p,h,S){return this._many(i,p,h,!1,S)},ee.prototype.prependMany=function(i,p,h,S){return this._many(i,p,h,!0,S)},ee.prototype._many=function(i,p,h,S,l){var C=this;if(typeof h!="function")throw new Error("many only accepts instances of Function");function D(){return--p===0&&C.off(i,D),h.apply(this,arguments)}return D._origin=h,this._on(i,D,S,l)},ee.prototype.emit=function(){if(!this._events&&!this._all)return!1;this._events||Te.call(this);var i=arguments[0],p,h=this.wildcard,S,l,C,D,G;if(i==="newListener"&&!this._newListener&&!this._events.newListener)return!1;if(h&&(p=i,i!=="newListener"&&i!=="removeListener"&&typeof i=="object")){if(l=i.length,se){for(C=0;C<l;C++)if(typeof i[C]=="symbol"){G=!0;break}}G||(i=i.join(this.delimiter))}var j=arguments.length,Y;if(this._all&&this._all.length)for(Y=this._all.slice(),C=0,l=Y.length;C<l;C++)switch(this.event=i,j){case 1:Y[C].call(this,i);break;case 2:Y[C].call(this,i,arguments[1]);break;case 3:Y[C].call(this,i,arguments[1],arguments[2]);break;default:Y[C].apply(this,arguments)}if(h)Y=[],B.call(this,Y,p,this.listenerTree,0,l);else if(Y=this._events[i],typeof Y=="function"){switch(this.event=i,j){case 1:Y.call(this);break;case 2:Y.call(this,arguments[1]);break;case 3:Y.call(this,arguments[1],arguments[2]);break;default:for(S=new Array(j-1),D=1;D<j;D++)S[D-1]=arguments[D];Y.apply(this,S)}return!0}else Y&&(Y=Y.slice());if(Y&&Y.length){if(j>3)for(S=new Array(j-1),D=1;D<j;D++)S[D-1]=arguments[D];for(C=0,l=Y.length;C<l;C++)switch(this.event=i,j){case 1:Y[C].call(this);break;case 2:Y[C].call(this,arguments[1]);break;case 3:Y[C].call(this,arguments[1],arguments[2]);break;default:Y[C].apply(this,S)}return!0}else if(!this.ignoreErrors&&!this._all&&i==="error")throw arguments[1]instanceof Error?arguments[1]:new Error("Uncaught, unspecified 'error' event.");return!!this._all},ee.prototype.emitAsync=function(){if(!this._events&&!this._all)return!1;this._events||Te.call(this);var i=arguments[0],p=this.wildcard,h,S,l,C,D,G;if(i==="newListener"&&!this._newListener&&!this._events.newListener)return Promise.resolve([!1]);if(p&&(h=i,i!=="newListener"&&i!=="removeListener"&&typeof i=="object")){if(C=i.length,se){for(D=0;D<C;D++)if(typeof i[D]=="symbol"){S=!0;break}}S||(i=i.join(this.delimiter))}var j=[],Y=arguments.length,P;if(this._all)for(D=0,C=this._all.length;D<C;D++)switch(this.event=i,Y){case 1:j.push(this._all[D].call(this,i));break;case 2:j.push(this._all[D].call(this,i,arguments[1]));break;case 3:j.push(this._all[D].call(this,i,arguments[1],arguments[2]));break;default:j.push(this._all[D].apply(this,arguments))}if(p?(P=[],B.call(this,P,h,this.listenerTree,0)):P=this._events[i],typeof P=="function")switch(this.event=i,Y){case 1:j.push(P.call(this));break;case 2:j.push(P.call(this,arguments[1]));break;case 3:j.push(P.call(this,arguments[1],arguments[2]));break;default:for(l=new Array(Y-1),G=1;G<Y;G++)l[G-1]=arguments[G];j.push(P.apply(this,l))}else if(P&&P.length){if(P=P.slice(),Y>3)for(l=new Array(Y-1),G=1;G<Y;G++)l[G-1]=arguments[G];for(D=0,C=P.length;D<C;D++)switch(this.event=i,Y){case 1:j.push(P[D].call(this));break;case 2:j.push(P[D].call(this,arguments[1]));break;case 3:j.push(P[D].call(this,arguments[1],arguments[2]));break;default:j.push(P[D].apply(this,l))}}else if(!this.ignoreErrors&&!this._all&&i==="error")return arguments[1]instanceof Error?Promise.reject(arguments[1]):Promise.reject("Uncaught, unspecified 'error' event.");return Promise.all(j)},ee.prototype.on=function(i,p,h){return this._on(i,p,!1,h)},ee.prototype.prependListener=function(i,p,h){return this._on(i,p,!0,h)},ee.prototype.onAny=function(i){return this._onAny(i,!1)},ee.prototype.prependAny=function(i){return this._onAny(i,!0)},ee.prototype.addListener=ee.prototype.on,ee.prototype._onAny=function(i,p){if(typeof i!="function")throw new Error("onAny only accepts instances of Function");return this._all||(this._all=[]),p?this._all.unshift(i):this._all.push(i),this},ee.prototype._on=function(i,p,h,S){if(typeof i=="function")return this._onAny(i,p),this;if(typeof p!="function")throw new Error("on only accepts instances of Function");this._events||Te.call(this);var l=this,C;return S!==R&&(C=ne.call(this,i,p,S),p=C[0],l=C[1]),this._newListener&&this.emit("newListener",i,p),this.wildcard?(U.call(this,i,p,h),l):(this._events[i]?(typeof this._events[i]=="function"&&(this._events[i]=[this._events[i]]),h?this._events[i].unshift(p):this._events[i].push(p),!this._events[i].warned&&this._maxListeners>0&&this._events[i].length>this._maxListeners&&(this._events[i].warned=!0,Fe.call(this,this._events[i].length,i))):this._events[i]=p,l)},ee.prototype.off=function(i,p){if(typeof p!="function")throw new Error("removeListener only takes instances of Function");var h,S=[];if(this.wildcard){var l=typeof i=="string"?i.split(this.delimiter):i.slice();if(S=B.call(this,null,l,this.listenerTree,0),!S)return this}else{if(!this._events[i])return this;h=this._events[i],S.push({_listeners:h})}for(var C=0;C<S.length;C++){var D=S[C];if(h=D._listeners,v(h)){for(var G=-1,j=0,Y=h.length;j<Y;j++)if(h[j]===p||h[j].listener&&h[j].listener===p||h[j]._origin&&h[j]._origin===p){G=j;break}if(G<0)continue;return this.wildcard?D._listeners.splice(G,1):this._events[i].splice(G,1),h.length===0&&(this.wildcard?delete D._listeners:delete this._events[i]),this._removeListener&&this.emit("removeListener",i,p),this}else(h===p||h.listener&&h.listener===p||h._origin&&h._origin===p)&&(this.wildcard?delete D._listeners:delete this._events[i],this._removeListener&&this.emit("removeListener",i,p))}return this.listenerTree&&W(this.listenerTree),this},ee.prototype.offAny=function(i){var p=0,h=0,S;if(i&&this._all&&this._all.length>0){for(S=this._all,p=0,h=S.length;p<h;p++)if(i===S[p])return S.splice(p,1),this._removeListener&&this.emit("removeListenerAny",i),this}else{if(S=this._all,this._removeListener)for(p=0,h=S.length;p<h;p++)this.emit("removeListenerAny",S[p]);this._all=[]}return this},ee.prototype.removeListener=ee.prototype.off,ee.prototype.removeAllListeners=function(i){if(i===R)return!this._events||Te.call(this),this;if(this.wildcard){var p=B.call(this,null,i,this.listenerTree,0),h,S;if(!p)return this;for(S=0;S<p.length;S++)h=p[S],h._listeners=null;this.listenerTree&&W(this.listenerTree)}else this._events&&(this._events[i]=null);return this},ee.prototype.listeners=function(i){var p=this._events,h,S,l,C,D;if(i===R){if(this.wildcard)throw Error("event name required for wildcard emitter");if(!p)return[];for(h=_e(p),C=h.length,l=[];C-- >0;)S=p[h[C]],typeof S=="function"?l.push(S):l.push.apply(l,S);return l}else{if(this.wildcard){if(D=this.listenerTree,!D)return[];var G=[],j=typeof i=="string"?i.split(this.delimiter):i.slice();return B.call(this,G,j,D,0),G}return p?(S=p[i],S?typeof S=="function"?[S]:S:[]):[]}},ee.prototype.eventNames=function(i){var p=this._events;return this.wildcard?J.call(this,this.listenerTree,[],null,i):p?_e(p):[]},ee.prototype.listenerCount=function(i){return this.listeners(i).length},ee.prototype.hasListeners=function(i){if(this.wildcard){var p=[],h=typeof i=="string"?i.split(this.delimiter):i.slice();return B.call(this,p,h,this.listenerTree,0),p.length>0}var S=this._events,l=this._all;return!!(l&&l.length||S&&(i===R?_e(S).length:S[i]))},ee.prototype.listenersAny=function(){return this._all?this._all:[]},ee.prototype.waitFor=function(i,p){var h=this,S=typeof p;return S==="number"?p={timeout:p}:S==="function"&&(p={filter:p}),p=mt(p,{timeout:0,filter:R,handleError:!1,Promise,overload:!1},{filter:et,Promise:re}),Tt(p.Promise,function(l,C,D){function G(){var j=p.filter;if(!(j&&!j.apply(h,arguments)))if(h.off(i,G),p.handleError){var Y=arguments[0];Y?C(Y):l(Qe.apply(null,arguments).slice(1))}else l(Qe.apply(null,arguments))}D(function(){h.off(i,G)}),h._on(i,G,!1)},{timeout:p.timeout,overload:p.overload})};function Pe(i,p,h){h=mt(h,{Promise,timeout:0,overload:!1},{Promise:re});var S=h.Promise;return Tt(S,function(l,C,D){var G;if(typeof i.addEventListener=="function"){G=function(){l(Qe.apply(null,arguments))},D(function(){i.removeEventListener(p,G)}),i.addEventListener(p,G,{once:!0});return}var j=function(){Y&&i.removeListener("error",Y),l(Qe.apply(null,arguments))},Y;p!=="error"&&(Y=function(P){i.removeListener(p,j),C(P)},i.once("error",Y)),D(function(){Y&&i.removeListener("error",Y),i.removeListener(p,j)}),i.once(p,j)},{timeout:h.timeout,overload:h.overload})}var ft=ee.prototype;if(Object.defineProperties(ee,{defaultMaxListeners:{get:function(){return ft._maxListeners},set:function(i){if(typeof i!="number"||i<0||Number.isNaN(i))throw TypeError("n must be a non-negative number");ft._maxListeners=i},enumerable:!0},once:{value:Pe,writable:!0,configurable:!0}}),Object.defineProperties(ft,{_maxListeners:{value:H,writable:!0,configurable:!0},_observers:{value:null,writable:!0,configurable:!0}}),typeof define=="function"&&define.amd)define(function(){return ee});else if(typeof Io=="object")ho.exports=ee;else{var tt=new Function("","return this")();tt.EventEmitter2=ee}})()});var Po=Js((XE,ko)=>{ko.exports=So()});var Ro=Js((Ws,Lo)=>{(function(R,L){var v=L(R);if(typeof define=="function"&&define.amd)define("DeepDiff",function(){return v});else if(typeof Ws=="object"||typeof navigator=="object"&&navigator.product.match(/ReactNative/i))Lo.exports=v;else{var H=R.DeepDiff;v.noConflict=function(){return R.DeepDiff===v&&(R.DeepDiff=H),v},R.DeepDiff=v}})(Ws,function(R){var L=["N","E","A","D"];function v(F,B){F.super_=B,F.prototype=Object.create(B.prototype,{constructor:{value:F,enumerable:!1,writable:!0,configurable:!0}})}function H(F,B){Object.defineProperty(this,"kind",{value:F,enumerable:!0}),B&&B.length&&Object.defineProperty(this,"path",{value:B,enumerable:!0})}function z(F,B,U){z.super_.call(this,"E",F),Object.defineProperty(this,"lhs",{value:B,enumerable:!0}),Object.defineProperty(this,"rhs",{value:U,enumerable:!0})}v(z,H);function se(F,B){se.super_.call(this,"N",F),Object.defineProperty(this,"rhs",{value:B,enumerable:!0})}v(se,H);function ie(F,B){ie.super_.call(this,"D",F),Object.defineProperty(this,"lhs",{value:B,enumerable:!0})}v(ie,H);function me(F,B,U){me.super_.call(this,"A",F),Object.defineProperty(this,"index",{value:B,enumerable:!0}),Object.defineProperty(this,"item",{value:U,enumerable:!0})}v(me,H);function Ie(F,B,U){var J=F.slice((U||B)+1||F.length);return F.length=B<0?F.length+B:B,F.push.apply(F,J),F}function _e(F){var B=typeof F;return B!=="object"?B:F===Math?"math":F===null?"null":Array.isArray(F)?"array":Object.prototype.toString.call(F)==="[object Date]"?"date":typeof F.toString=="function"&&/^\/.*\//.test(F.toString())?"regexp":"object"}function Te(F){var B=0;if(F.length===0)return B;for(var U=0;U<F.length;U++){var J=F.charCodeAt(U);B=(B<<5)-B+J,B=B&B}return B}function Be(F){var B=0,U=_e(F);if(U==="array"){F.forEach(function(ee){B+=Be(ee)});var J="[type: array, hash: "+B+"]";return B+Te(J)}if(U==="object"){for(var W in F)if(F.hasOwnProperty(W)){var ae="[ type: object, key: "+W+", value hash: "+Be(F[W])+"]";B+=Te(ae)}return B}var ne="[ type: "+U+" ; value: "+F+"]";return B+Te(ne)}function Fe(F,B,U,J,W,ae,ne,ee){U=U||[],W=W||[],ne=ne||[];var Pe=W.slice(0);if(typeof ae<"u"&&ae!==null){if(J){if(typeof J=="function"&&J(Pe,ae))return;if(typeof J=="object"){if(J.prefilter&&J.prefilter(Pe,ae))return;if(J.normalize){var ft=J.normalize(Pe,ae,F,B);ft&&(F=ft[0],B=ft[1])}}}Pe.push(ae)}_e(F)==="regexp"&&_e(B)==="regexp"&&(F=F.toString(),B=B.toString());var tt=typeof F,i=typeof B,p,h,S,l,C=tt!=="undefined"||ne&&ne.length>0&&ne[ne.length-1].lhs&&Object.getOwnPropertyDescriptor(ne[ne.length-1].lhs,ae),D=i!=="undefined"||ne&&ne.length>0&&ne[ne.length-1].rhs&&Object.getOwnPropertyDescriptor(ne[ne.length-1].rhs,ae);if(!C&&D)U.push(new se(Pe,B));else if(!D&&C)U.push(new ie(Pe,F));else if(_e(F)!==_e(B))U.push(new z(Pe,F,B));else if(_e(F)==="date"&&F-B!==0)U.push(new z(Pe,F,B));else if(tt==="object"&&F!==null&&B!==null){for(p=ne.length-1;p>-1;--p)if(ne[p].lhs===F){l=!0;break}if(l)F!==B&&U.push(new z(Pe,F,B));else{if(ne.push({lhs:F,rhs:B}),Array.isArray(F)){for(ee&&(F.sort(function(Y,P){return Be(Y)-Be(P)}),B.sort(function(Y,P){return Be(Y)-Be(P)})),p=B.length-1,h=F.length-1;p>h;)U.push(new me(Pe,p,new se(void 0,B[p--])));for(;h>p;)U.push(new me(Pe,h,new ie(void 0,F[h--])));for(;p>=0;--p)Fe(F[p],B[p],U,J,Pe,p,ne,ee)}else{var G=Object.keys(F),j=Object.keys(B);for(p=0;p<G.length;++p)S=G[p],l=j.indexOf(S),l>=0?(Fe(F[S],B[S],U,J,Pe,S,ne,ee),j[l]=null):Fe(F[S],void 0,U,J,Pe,S,ne,ee);for(p=0;p<j.length;++p)S=j[p],S&&Fe(void 0,B[S],U,J,Pe,S,ne,ee)}ne.length=ne.length-1}}else F!==B&&(tt==="number"&&isNaN(F)&&isNaN(B)||U.push(new z(Pe,F,B)))}function Qe(F,B,U,J,W){var ae=[];if(Fe(F,B,ae,J,null,null,null,W),U)for(var ne=0;ne<ae.length;++ne)U(ae[ne]);return ae}function qe(F,B,U,J,W,ae,ne){return Fe(F,B,U,J,W,ae,ne,!0)}function xe(F,B,U,J){var W=J?function(ne){ne&&J.push(ne)}:void 0,ae=Qe(F,B,W,U);return J||(ae.length?ae:void 0)}function mt(F,B,U,J){var W=J?function(ne){ne&&J.push(ne)}:void 0,ae=Qe(F,B,W,U,!0);return J||(ae.length?ae:void 0)}function re(F,B,U){if(U.path&&U.path.length){var J=F[B],W,ae=U.path.length-1;for(W=0;W<ae;W++)J=J[U.path[W]];switch(U.kind){case"A":re(J[U.path[W]],U.index,U.item);break;case"D":delete J[U.path[W]];break;case"E":case"N":J[U.path[W]]=U.rhs;break}}else switch(U.kind){case"A":re(F[B],U.index,U.item);break;case"D":F=Ie(F,B);break;case"E":case"N":F[B]=U.rhs;break}return F}function ge(F,B,U){if(typeof U>"u"&&B&&~L.indexOf(B.kind)&&(U=B),F&&U&&U.kind){for(var J=F,W=-1,ae=U.path?U.path.length-1:0;++W<ae;)typeof J[U.path[W]]>"u"&&(J[U.path[W]]=typeof U.path[W+1]<"u"&&typeof U.path[W+1]=="number"?[]:{}),J=J[U.path[W]];switch(U.kind){case"A":U.path&&typeof J[U.path[W]]>"u"&&(J[U.path[W]]=[]),re(U.path?J[U.path[W]]:J,U.index,U.item);break;case"D":delete J[U.path[W]];break;case"E":case"N":J[U.path[W]]=U.rhs;break}}}function et(F,B,U){if(U.path&&U.path.length){var J=F[B],W,ae=U.path.length-1;for(W=0;W<ae;W++)J=J[U.path[W]];switch(U.kind){case"A":et(J[U.path[W]],U.index,U.item);break;case"D":J[U.path[W]]=U.lhs;break;case"E":J[U.path[W]]=U.lhs;break;case"N":delete J[U.path[W]];break}}else switch(U.kind){case"A":et(F[B],U.index,U.item);break;case"D":F[B]=U.lhs;break;case"E":F[B]=U.lhs;break;case"N":F=Ie(F,B);break}return F}function it(F,B,U){if(F&&B&&U&&U.kind){var J=F,W,ae;for(ae=U.path.length-1,W=0;W<ae;W++)typeof J[U.path[W]]>"u"&&(J[U.path[W]]={}),J=J[U.path[W]];switch(U.kind){case"A":et(J[U.path[W]],U.index,U.item);break;case"D":J[U.path[W]]=U.lhs;break;case"E":J[U.path[W]]=U.lhs;break;case"N":delete J[U.path[W]];break}}}function Tt(F,B,U){if(F&&B){var J=function(W){(!U||U(F,B,W))&&ge(F,B,W)};Qe(F,B,J)}}return Object.defineProperties(xe,{diff:{value:xe,enumerable:!0},orderIndependentDiff:{value:mt,enumerable:!0},observableDiff:{value:Qe,enumerable:!0},orderIndependentObservableDiff:{value:qe,enumerable:!0},orderIndepHash:{value:Be,enumerable:!0},applyDiff:{value:Tt,enumerable:!0},applyChange:{value:ge,enumerable:!0},revertChange:{value:it,enumerable:!0},isConflict:{value:function(){return typeof $conflict<"u"},enumerable:!0}}),xe.DeepDiff=xe,R&&(R.DeepDiff=xe),xe})});var Ku=No(Po(),1),Hu=No(Ro(),1);var Vl="as",$l="=",Kl="break",Hl="else",zl="enum",Xl="export",Jl="if",Wl="import",Zl="->",Ql="is",ql="loop",xl="mut",ei="native",ti="object",si="fn",ni="return",oi="self",ci="template",ri=Object.freeze({ALIAS:Vl,ASSIGN:$l,BREAK:Kl,ELSE:Hl,ENUMERATION:zl,EXPORT:Xl,IF:Jl,IMPORT:Wl,INTO:Zl,IS:Ql,LOOP:ql,MUTABLE:xl,NATIVE:ei,OBJECT:ti,PROCEDURE:si,RETURN:ni,SELF:oi,TEMPLATE:ci}),Co=ri;var ai="assign",ui="array_assignment",li="branch-match",ii="branch-default",fi="condition",Ei="loop",_i="data",mi="generics",pi="enumeration",bi="expression",Oi="instance",Ai="Link",Ti="local",Ni="object",di="procedure",Ii="return",hi="select",Si="member",ki="store",Pi="break",Li="literal",Ri="array_access",Ci="valueLink",vi="linkValue",Ui="self",yi="procedure-call",Bi="Maybe",Di="native",Mi="move",Fi="String",ji="Array",wi="import",Yi="library",gi="constructor",Gi="destructor",Vi="free",$i="block-end",Ki="default-block",Hi="continue",zi="branch",Xi="statement",Ji="draw",Wi="size",Zi="concatenation",Qi="foreach",qi="while",xi="while-condition",ef="foreach-condition",tf="foreach-end",sf="I32",nf="FP32",of="FP64",cf=Object.freeze({TYPES_ASSIGN:ai,TYPES_ARRAY:ji,TYPES_ARRAY_ASSIGNMENT:ui,TYPES_BRANCH_MATCH:li,TYPES_BRANCH_DEFAULT:ii,TYPES_CONDITION:fi,TYPES_LOOP:Ei,TYPES_FOREACH_END:tf,TYPES_WHILE_CONDITION:xi,TYPES_FOREACH_CONDITION:ef,TYPES_DATA:_i,TYPES_GENERICS:mi,TYPES_ENUMERATION:pi,TYPES_EXPRESSION:bi,TYPES_INSTANCE:Oi,TYPES_LINK:Ai,TYPES_IMPORT:wi,TYPES_LOCAL:Ti,TYPES_OBJECT:Ni,TYPES_PROCEDURE:di,TYPES_RETURN:Ii,TYPES_SELECT:hi,TYPES_MEMBER:Si,TYPES_STORE:ki,TYPES_BREAK:Pi,TYPES_LITERAL:Li,TYPES_ARRAY_ACCESS:Ri,TYPES_LINK_TO:Ci,TYPES_VALUE_AT:vi,TYPES_SELF:Ui,TYPES_LIBRARY:Yi,TYPES_DROP:yi,TYPES_MAYBE:Bi,TYPES_NATIVE:Di,TYPES_MOVE:Mi,TYPES_STRING:Fi,TYPES_CONSTRUCTOR:gi,TYPES_FREE:Vi,TYPES_DEFAULT_BLOCK:Ki,TYPES_BLOCK_END:$i,TYPES_CONTINUE:Hi,TYPES_BRANCH:zi,TYPES_STATEMENT:Xi,TYPES_DESTRUCTOR:Gi,TYPES_DRAW:Ji,TYPES_SIZE:Wi,TYPES_CONCAT:Zi,TYPES_FOREACH:Qi,TYPES_WHILE:qi,TYPES_I32:sf,TYPES_FP32:nf,TYPES_FP64:of}),Zs=cf;var rf=Object.freeze({COLON:58,COMMA:44,DIGIT_ZERO:48,DIGIT_NINE:57,DOT:46,HASHTAG:35,HORIZONTAL_TAB:9,HYPHEN_MINUS:45,LEFT_CURLY_BRACKET:123,LEFT_PARENTHESIS:40,LEFT_SQUARE_BRACKET:91,LINE_BREAK:10,NULL:0,PLUS_SIGN:43,RIGHT_CURLY_BRACKET:125,RIGHT_PARENTHESIS:41,RIGHT_SQUARE_BRACKET:93,SEMICOLON:59,SPACE:32}),vo=rf;var af="assignment",uf="Flogram",lf=Object.freeze({K_ASSIGNMENT:af,K_FLOGRAM:uf}),Uo=lf;var ff=Object.freeze([]),Ef=Object.freeze({}),nt="",_f="	",mf=`
`,pf="UTF-8",yo=Zs,bf=Object.freeze({EMPTY_ARRAY:ff,EMPTY_OBJECT:Ef,EMPTY_STRING:nt,HORIZONTAL_TAB:_f,LINE_BREAK:mf,UNICODE_TEXT:pf,Codes:vo,Keys:Co,Types:Zs,Keywords:Uo}),ls=bf;function A(R,L=[],v=""){let H=L.map((se,ie)=>({name:`operand${ie+1}`,data:{type:"data",name:se,path:"Flogram"}})),z={type:"native",name:R,path:"Flogram",description:{inputs:H,outputs:v&&L.length<=0?null:[{name:"result",data:{type:"data",name:v||(L.length>0?L[0]:""),path:"Flogram"}}]}};return Object.freeze(z)}var Of=Object.freeze({"+":[A("+",["FP64","FP64"]),A("+",["U64","U64"]),A("+",["I64","I64"]),A("+",["FP32","FP32"]),A("+",["U32","U32"]),A("+",["I32","I32"]),A("+",["U16","U16"]),A("+",["I16","I16"]),A("+",["U8","U8"]),A("+",["I8","I8"]),A("+",["any","any"])],"-":[A("-",["FP64","FP64"]),A("-",["U64","U64"]),A("-",["I64","I64"]),A("-",["FP32","FP32"]),A("-",["U32","U32"]),A("-",["I32","I32"]),A("-",["U16","U16"]),A("-",["I16","I16"]),A("-",["U8","U8"]),A("-",["I8","I8"]),A("-",["any","any"]),A("-",["FP64"]),A("-",["I64"]),A("-",["FP32"]),A("-",["I32"]),A("-",["I16"]),A("-",["I8"]),A("-",["any"])],"*":[A("*",["FP64","FP64"]),A("*",["U64","U64"]),A("*",["I64","I64"]),A("*",["FP32","FP32"]),A("*",["U32","U32"]),A("*",["I32","I32"]),A("*",["U16","U16"]),A("*",["I16","I16"]),A("*",["U8","U8"]),A("*",["I8","I8"]),A("*",["any","any"])],"/":[A("/",["FP64","FP64"]),A("/",["U64","U64"]),A("/",["I64","I64"]),A("/",["FP32","FP32"]),A("/",["U32","U32"]),A("/",["I32","I32"]),A("/",["U16","U16"]),A("/",["I16","I16"]),A("/",["U8","U8"]),A("/",["I8","I8"]),A("/",["any","any"])],"%":[A("%",["I64","I64"]),A("%",["U64","U64"]),A("%",["I32","I32"]),A("%",["U32","U32"]),A("%",["I16","I16"]),A("%",["U16","U16"]),A("%",["I8","I8"]),A("%",["U8","U8"]),A("%",["any","any"])],"!=":[A("!=",["FP64","FP64"],"Bool"),A("!=",["U64","U64"],"Bool"),A("!=",["I64","I64"],"Bool"),A("!=",["FP32","FP32"],"Bool"),A("!=",["U32","U32"],"Bool"),A("!=",["I32","I32"],"Bool"),A("!=",["U16","U16"],"Bool"),A("!=",["I16","I16"],"Bool"),A("!=",["U8","U8"],"Bool"),A("!=",["I8","I8"],"Bool"),A("!=",["any","any"],"any")],"==":[A("==",["FP64","FP64"],"Bool"),A("==",["U64","U64"],"Bool"),A("==",["I64","I64"],"Bool"),A("==",["FP32","FP32"],"Bool"),A("==",["U32","U32"],"Bool"),A("==",["I32","I32"],"Bool"),A("==",["U16","U16"],"Bool"),A("==",["I16","I16"],"Bool"),A("==",["U8","U8"],"Bool"),A("==",["I8","I8"],"Bool"),A("==",["any","any"],"any")],">":[A(">",["FP64","FP64"],"Bool"),A(">",["U64","U64"],"Bool"),A(">",["I64","I64"],"Bool"),A(">",["FP32","FP32"],"Bool"),A(">",["U32","U32"],"Bool"),A(">",["I32","I32"],"Bool"),A(">",["U16","U16"],"Bool"),A(">",["I16","I16"],"Bool"),A(">",["U8","U8"],"Bool"),A(">",["I8","I8"],"Bool"),A(">",["any","any"],"any")],"<":[A("<",["FP64","FP64"],"Bool"),A("<",["U64","U64"],"Bool"),A("<",["I64","I64"],"Bool"),A("<",["FP32","FP32"],"Bool"),A("<",["U32","U32"],"Bool"),A("<",["I32","I32"],"Bool"),A("<",["U16","U16"],"Bool"),A("<",["I16","I16"],"Bool"),A("<",["U8","U8"],"Bool"),A("<",["I8","I8"],"Bool"),A("<",["any","any"],"any")],">=":[A(">=",["FP64","FP64"],"Bool"),A(">=",["U64","U64"],"Bool"),A(">=",["I64","I64"],"Bool"),A(">=",["FP32","FP32"],"Bool"),A(">=",["U32","U32"],"Bool"),A(">=",["I32","I32"],"Bool"),A(">=",["U16","U16"],"Bool"),A(">=",["I16","I16"],"Bool"),A(">=",["U8","U8"],"Bool"),A(">=",["I8","I8"],"Bool"),A(">=",["any","any"],"any")],"<=":[A("<=",["FP64","FP64"],"Bool"),A("<=",["U64","U64"],"Bool"),A("<=",["I64","I64"],"Bool"),A("<=",["FP32","FP32"],"Bool"),A("<=",["U32","U32"],"Bool"),A("<=",["I32","I32"],"Bool"),A("<=",["U16","U16"],"Bool"),A("<=",["I16","I16"],"Bool"),A("<=",["U8","U8"],"Bool"),A("<=",["I8","I8"],"Bool"),A("<=",["any","any"],"any")],"&":[A("&",["Bool","Bool"],"Bool"),A("&",["any","any"],"any")],"^":[A("^",["Bool","Bool"],"Bool"),A("^",["any","any"],"any")],"|":[A("|",["Bool","Bool"],"Bool"),A("|",["any","any"],"any")],not:[A("not",["Bool"],"Bool"),A("not",["any"],"any")],I32:[A("I32",["FP64"],"I32"),A("I32",["U64"],"I32"),A("I32",["I64"],"I32"),A("I32",["FP32"],"I32"),A("I32",["U32"],"I32"),A("I32",["I32"],"I32"),A("I32",["U16"],"I32"),A("I32",["I16"],"I32"),A("I32",["U8"],"I32"),A("I32",["I8"],"I32"),A("I32",["any"],"any")],U32:[A("U32",["FP64"],"U32"),A("U32",["U64"],"U32"),A("U32",["I64"],"U32"),A("U32",["FP32"],"U32"),A("U32",["U32"],"U32"),A("U32",["I32"],"U32"),A("U32",["U16"],"U32"),A("U32",["I16"],"U32"),A("U32",["U8"],"U32"),A("U32",["I8"],"U32"),A("U32",["any"],"any")],I64:[A("I64",["FP64"],"I64"),A("I64",["U64"],"I64"),A("I64",["I64"],"I64"),A("I64",["FP32"],"I64"),A("I64",["U32"],"I64"),A("I64",["I32"],"I64"),A("I64",["U16"],"I64"),A("I64",["I16"],"I64"),A("I64",["U8"],"I64"),A("I64",["I8"],"I64"),A("I64",["any"],"any")],U64:[A("U64",["FP64"],"U64"),A("U64",["U64"],"U64"),A("U64",["I64"],"U64"),A("U64",["FP32"],"U64"),A("U64",["U32"],"U64"),A("U64",["I32"],"U64"),A("U64",["U16"],"U64"),A("U64",["I16"],"U64"),A("U64",["U8"],"U64"),A("U64",["I8"],"U64"),A("U64",["any"],"any")],FP32:[A("FP32",["FP64"],"FP32"),A("FP32",["U64"],"FP32"),A("FP32",["I64"],"FP32"),A("FP32",["FP32"],"FP32"),A("FP32",["U32"],"FP32"),A("FP32",["I32"],"FP32"),A("FP32",["U16"],"FP32"),A("FP32",["I16"],"FP32"),A("FP32",["U8"],"FP32"),A("FP32",["I8"],"FP32"),A("FP32",["any"],"any")],FP64:[A("FP64",["FP64"],"FP64"),A("FP64",["U64"],"FP64"),A("FP64",["I64"],"FP64"),A("FP64",["FP32"],"FP64"),A("FP64",["U32"],"FP64"),A("FP64",["I32"],"FP64"),A("FP64",["U16"],"FP64"),A("FP64",["I16"],"FP64"),A("FP64",["U8"],"FP64"),A("FP64",["I8"],"FP64"),A("FP64",["any"],"any")]}),xt=Of;var Bo=Object.freeze(["+","-","*","/","%",">",">=","<","<=","!=","&","|","^","not","I32","U32","I64","U64","FP64","FP32"]);var Af=Object.freeze(["FP64","U64","I64","FP32","U32","I32","U16","I16","U8","I8","Bool","Char","Array","String","Link","Maybe"]),It=Af;var{EMPTY_STRING:Tf,UNICODE_TEXT:en}=ls,Nf=44,df=48,If=57,hf=46,Sf=45,kf=43,Pf=65,Lf=90,Rf=-1,Cf=1,vf=new TextDecoder(en),Uf=new TextEncoder,yf=(R,L,v=0,H=R.length|0,z=0,se=L.length|0)=>{for(z=z|0,v=v|0,se=se|0,H=H|0;;){let ie=v>=H,me=z>=se;if(ie||me)break;let _e=R[v],Te=L[z];if(v=v+1|0,z=z+1|0,_e<Te)return Rf;if(_e>Te)return Cf}return 0},tn=(R,L,v=0,H=R.length|0,z=0,se=L.length|0)=>{for(z=z|0,v=v|0,se=se|0,H=H|0;;){let ie=z>=se,me=v>=H;if(ie||me)break;L[z]=R[v],z=z+1|0,v=v+1|0}},sn=(R,L,v=0,H=R.length|0,z=0,se=L.length|0)=>{v=v|0,z=z|0,H=H|0,se=se|0;let ie=H-v|0,me=se-z|0;if(ie!==me)return!1;for(;;){let Ie=v>=H,_e=z>=se;if(Ie||_e)break;let Be=R[v],Fe=L[z];if(v=v+1|0,z=z+1|0,Be!==Fe)return!1}return!0},Bf=R=>{R=R>>>0;let L=0,v=0;for(;v=(v<<1|1)>>>0,!(v>R);)L=L+1|0;return L},Fo=Object.freeze([48,49,50,51,52,53,54,55,56,57,97,98,99,100,101,102]),xs=(R,L,v,H)=>{for(R=R>>>0,H=H??L.length|0,v=v|0,H=H|0;R>0&&H>v;)H=H-1|0,L[H]=Fo[R&15],R=R>>>4},nn=(R,L,v,H)=>{let z=v|0,se=v+H|0;if(H===0)return!1;let ie=L[z];for((ie===kf||ie===Sf)&&(z=z+1|0);z<se;){let me=L[z];if(z=z+1|0,!(df<=me&&me<=If||(hf===me||Nf===me)))return!1}return!0},on=R=>{let L=R>=Pf,v=R<=Lf;return L&&v},fs=128,Es=127,jo=-1,wt=64,cn=R=>{R=R|0;let L=[];for(;;){let v=R&Es;R=R>>7;let H=R===0,z=(v&wt)===0,se=H&&z,ie=R===-1,me=(v&wt)!==0;if(se||ie&&me){L.push(v);break}v=v|fs,L.push(v)}return L},Df=R=>{let L=[],v=!0;for(;v;){let H=R&Es;R>>=7,R===0&&!(H&wt)||R===-1&&H&wt?v=!1:H|=fs,L.push(H)}return L},wo=(R,L)=>{L=L|0;let v=0,H=0;for(;;){let z=R[L]|0;L=L+1|0;let se=(z&Es)<<H;if(H=H+7|0,v=v|se,(z&fs)===0){let me=(z&wt)!==0,Ie=H<32;if(me&&Ie){let Te=jo<<H;v=v|Te}break}}return v},Mf=(R,L)=>{L=L|0;let v=0,H=0;for(;;){let z=R[L]|0;L=L+1|0;let se=(z&Es)<<H;if(H=H+7|0,v=v|se,!(z&fs)){if(z&wt){let ie=jo<<H;v=v|ie}break}}return v},_=R=>vf.decode(R),le=R=>Uf.encode(R),Ff=(R=Tf)=>{let L=R.length|0,v=cn(L),H=Buffer.from(R,en);return Object.freeze([...v,...H])},jf=(R,L)=>{L=L|0;let v=wo(R,L),H=cn(v).length;return L=L+H|0,R.subarray(L,L+v|0).toString(en)},wf=58,Yf=46,es=32,Qs=48,gf=67,ht=new Uint8Array(gf),Do=ht.subarray(0,8),is=ht.subarray(10,49),Mo=ht.subarray(51,68),qs=16,Gf=2;ht[8]=wf;ht[9]=es;ht[49]=es;ht[50]=es;var Vf=(R,L)=>{L=L??console.log;let v=32,H=126,z=R.length|0,se=0;for(;z>0;){Do.fill(Qs),xs(se,Do),is.fill(es),Mo.fill(es);let ie=z>=qs?qs:z;z=z-qs|0;let me=0,Ie=0;for(let Te=1;Te<=ie;Te=Te+1|0){let Be=R[se]&255;is[me+0|0]=Qs,is[me+1|0]=Qs,xs(Be,is,me,me+2|0);let Fe=Yf;v<=Be&&Be<=H&&(Fe=Be),Mo[Ie]=Fe,se=se+1|0,me=me+2|0,Ie=Ie+1|0,Te%Gf===0&&(me=me+1|0)}let _e=String.fromCodePoint(...ht);L(_e)}},$f=function*(R,L){let v=R.length|0,H=L.length|0,z=0;for(;z<v&&z<H;){let se=R[z],ie=L[z];yield[se,ie],z=z+1|0}},Kf=function*(R,L,v){let H=R.length|0,z=L.length|0,se=v.length|0,ie=0;for(;ie<H&&ie<z&&ie<se;){let me=R[ie],Ie=L[ie],_e=v[ie];yield[me,Ie,_e],ie=ie+1|0}},a_=Object.freeze({ARRAY_COMPARE:yf,ARRAY_COPY:tn,ARRAY_EQUAL:sn,BIT_DEPTH:Bf,HEX_DIGITS:Fo,HEX_ENCODE:xs,IS_NUMBER:nn,IS_UPPERCASE:on,LEB128_DECODE:wo,LEB128_DECODE_SIGNED:Mf,LEB128_ENCODE:cn,LEB128_ENCODE_SIGNED:Df,UTF8_DECODE:_,UTF8_ENCODE:le,WASM_STRING_ENCODE:Ff,WASM_STRING_DECODE:jf,XXD_DUMP_HEX:Vf,ZIP2:$f,ZIP3:Kf});var{TYPES_ASSIGN:_s,TYPES_ARRAY:Ye,TYPES_ARRAY_ASSIGNMENT:Hf,TYPES_BRANCH_MATCH:Yo,TYPES_BRANCH_DEFAULT:zf,TYPES_CONDITION:go,TYPES_LOOP:Go,TYPES_DATA:De,TYPES_GENERICS:ms,TYPES_ENUMERATION:Yt,TYPES_EXPRESSION:Ct,TYPES_IMPORT:Xf,TYPES_INSTANCE:i_,TYPES_LIBRARY:Jf,TYPES_LINK:Vo,TYPES_LOCAL:ct,TYPES_OBJECT:Ke,TYPES_PROCEDURE:ot,TYPES_RETURN:ps,TYPES_SELECT:_t,TYPES_MEMBER:rn,TYPES_NATIVE:Wf,TYPES_STORE:an,TYPES_BREAK:Zf,TYPES_LITERAL:Me,TYPES_ARRAY_ACCESS:bs,TYPES_LINK_TO:St,TYPES_VALUE_AT:rt,TYPES_SELF:at,TYPES_DROP:$o,TYPES_MAYBE:Ko,TYPES_MOVE:un,TYPES_STRING:vt,TYPES_CONSTRUCTOR:Os,TYPES_DESTRUCTOR:Ho,TYPES_FREE:Qf,TYPES_DRAW:qf,TYPES_SIZE:ln,TYPES_CONCAT:gt,TYPES_FOREACH:zo,TYPES_WHILE:Xo,TYPES_I32:ut}=yo,X=sn,Gt=le("="),xf=le("enum"),eE=le("loop"),tE=le("break"),sE=le("if"),nE=le("else"),fn=le("is"),As=le("->"),Vt=le(`
`),En=le("object"),$t=le("pass"),Jo=le("fn"),oE=le("return"),Ts=le("size"),Wo=le("at"),Ns=le(Ye),kt=le("Link!!"),Ut=le("Link"),ds=le("LinkSmart"),yt=le("mut"),Zo=le("self"),Qo=le("nocopy"),cE=le("move"),rE=le("size"),aE=le("import"),uE=le("export"),Is=le("Maybe"),qo=le("NONE"),xo=le("SOME"),ec=le("free"),lE=le("free!!"),iE=le("foreach"),p_=le("for"),fE=le("while"),tc=le("in"),EE=le("at"),be=58,Ot=61,de=44,He=46,Le=123,Ee=40,ce=10,_E=35,je=125,oe=41,Je=91,Bt=93,mE=39,Pt=34,pE=64,_n=47,bE=[43,45,42,47,37,124,60,62,94,38,33,61,[60,61],[62,61],[33,61]],mn=1,sc=2,pn=3,Zt="done",ye="fail",OE={EVENT_DONE:Zt,EVENT_FAIL:ye},zu=1,Xu=2,Ju=3,Wu=4,Zu=5,Qu=6,qu=7,xu=8,el=9,tl=10,sl=11,nl=12,AE=13,TE=14,NE=15,ol=16,dE=99,ze={FAIL_UNRESOLVED_NAME:R=>`Unresolved name '${R}'. The name '${R}' does not exist in the current context. Please check the spelling and scope of your identifiers.`,FAIL_UNEXPECTED_TOKEN:(R,L,v)=>`Unexpected token '${L}' at position ${v}. Looking for ${R}, found ${L}. Please check the syntax.`,FAIL_INDENTATION_MISMATCH:R=>`Indentation mismatch on line ${R}. The code on this line does not align with the expected indentation. Check your indentation for inconsistencies.`,FAIL_INDENTATION_NO_INCREASE:R=>`Indentation error on line ${R}. Expected an increase in indentation but found none. Check your indentation.`,FAIL_DUPLICATE_DATA:R=>`Duplicate data '${R}' found. Ensure each piece of data is unique.`,FAIL_DUPLICATE_OBJECT_MEMBER:(R,L)=>`Duplicate member '${R}' in object '${L}'. Each member in an object must have a unique name.`,FAIL_INVALID_IDENTIFIER:R=>`Invalid identifier '${R}'. The name '${R}' is not a valid identifier. Ensure your identifiers adhere to the language's naming rules.`,FAIL_RETURN_LENGTH_MISMATCH:(R,L)=>`Return length mismatch. Expected '${R}' value(s) but received '${L}'. Ensure the number of return values matches the expected count.`,FAIL_UNRESOLVED_OBJECT_MEMBER:(R,L)=>`Unresolved member '${R}' of object '${L}'. The member '${R}' does not exist on the object '${L}'`,FAIL_UNKNOWN_PROCEDURE_NAME:R=>`Call to undefined procedure '${R}'. Please ensure that the procedure is defined before calling it.`,FAIL_IMMUTABLE_ASSIGNMENT:R=>`Assignment to an immutable variable '${R}'. You are attempting to assign a new value to a variable which was declared as immutable and cannot be changed.`,FAIL_RESERVED_KEYWORD_USAGE:R=>`Reserved keyword '${R}' used as an identifier. The keyword '${R}' is reserved by the language and cannot be used as an identifier. Please choose a different name.`,FAIL_INPUT_TYPE_MISMATCH:(R,L)=>`Type Mismatch at line ${R}. Nature procedures expect all parameters to be of same type. Provided: ${L}.`,FAIL_UNSUPPORTED_TYPE:R=>`Unsupported type found. Type '${R}' was not defined in this context and isn't a native to Flogram. Please check your code and language supported types.`,FAIL_UNALLOWED_COPY:R=>`Copy operation not allowed. The object '${R}' has been defined as uncopyable in your code, and therefore, the copy operation you're attempting is not allowed.`,FAIL_ASSIGNMENT_TYPE_MISMATCH:(R,L)=>`Assignment type mismatch. Type '${L}' assigned to '${R}'.`},IE=Object.freeze({FAIL_UNRESOLVED_NAME:zu,FAIL_UNEXPECTED_TOKEN:Xu,FAIL_INDENTATION_MISMATCH:Ju,FAIL_INDENTATION_NO_INCREASE:Wu,FAIL_DUPLICATE_DATA:Zu,FAIL_DUPLICATE_OBJECT_MEMBER:Qu,FAIL_INVALID_IDENTIFIER:qu,FAIL_RETURN_LENGTH_MISMATCH:xu,FAIL_UNRESOLVED_OBJECT_MEMBER:el,FAIL_UNKNOWN_PROCEDURE_NAME:tl,FAIL_IMMUTABLE_ASSIGNMENT:sl,FAIL_RESERVED_KEYWORD_USAGE:nl,FAIL_ASSIGNMENT_TYPE_MISMATCH:ol}),hE=new Set(["fn","object","pass","enum"]),nc=new Set(["==","!=",">",">=","<","<=","!","&","|"]),Ve=(R,L,v,H)=>{if(H===1){let re=L[v],ge=re&191,et=re&223,it=et^93,Tt=et^91,F=re&254,U=re&254^40,W=re&253^44,ne=re&254^58;return ge===0||(it===0||Tt===0)||U===0||W===0||ne===0||re===ce}let xe=L.subarray(v,v+H|0),mt=_(xe);return!1},SE=(R,L,v,H)=>{let z=L.subarray(v,v+H|0),se=_(z);return hE.has(se)||It.includes(se)},kE=512,_o=1,cl=2,Ks=3,mo=4,rl=5,al=6,ul=7,ll=8,il=9,PE=10,LE=11,RE=12,CE=13,vE=14,UE=15,yE=16,BE=17,DE=18,lt=Object.freeze([_o]),Kt=Object.freeze([cl]),Dt=Object.freeze([Ks]),bn=Object.freeze([Ks,mo]),oc=Object.freeze([rl]),ME=Object.freeze([_o,al]),FE=Object.freeze([ul]),Xe=Object.freeze([mo,ll]),$e=Object.freeze([il]),jE=Object.freeze([PE]),Ht=Object.freeze([LE]),wE=Object.freeze([Ks,il]),ts=Object.freeze([RE]),zt=Object.freeze([CE]),On=Object.freeze([vE]),cc=Object.freeze([UE]),rc=Object.freeze([yE]),hs=Object.freeze([BE]),An=Object.freeze([DE]),YE=Object.freeze({REASON_COLON_OPENS_SCOPE:_o,REASON_LINE_BREAK_BEFORE_OPEN_SCOPE:cl,REASON_CLOSING_LINE_BREAK:Ks,REASON_SEQUENCE_SEPARATOR_COMMA:mo,REASON_INTO_BETWEEN_INPUTS_OUTPUTS:rl,REASON_IS_OPENS_CONDITION_BRANCH_MATCH:al,REASON_OPEN_STATEMENT_WITH_KEYWORD:ul,REASON_RIGHT_PARENTHESIS_CLOSES_LIST:ll}),Re=1,ac=2,ss=3,uc=4,Tn=5,lc=6,we=7,Mt=8,Ue=9,ns=10,Xt=11,ic=12,fc=13,os=1,Ec=2,Ce=3,Nn=4,_c=5,mc=6,pc=7,bc=1,Oc=2,Ac=3,Tc=4,Nc=5,dn=6,dc=7,Ic=8,hc=9,Sc=10,kc=11,Pc=12,Lc=13,In=14,cs=1,Rc=2,Ss=3,Cc=4,hn=5,vc=6,Uc=7,rs=1,yc=2,ks=3,Bc=4,Dc=6,Mc=1,Fc=2,jc=3,wc=4,Yc=5,gc=6,Sn=7,Gc=8,Vc=9,Ps=10,$c=11,Kc=12,Hc=13,zc=14,Xc=15,Jc=16,Wc=17,Zc=1,Qc=2,qc=1,xc=2,gE=3;var er=7,kn=8,tr=9,Ls=1,Rs=2,Cs=3,vs=4,Jt=5,Us=6,ys=7,Wt=8,Bs=9,Ds=10,Ms=11,Lt=1,sr=2,nr=3,Pn=4,or=5,cr=6,rr=7,Ln=8,ar=9,ur=10,lr=11,ir=12,fr=13,Er=14,Rn=15;var _r=17,Cn=18,vn=19,mr=20,pr=21,Un=22,br=23,Or=24,Ft=25,Fs=26,Ar=27,Tr=28,Nr=29,dr=30,Ir=31,hr=32,Sr=33,kr=34,Pr=35,Lr=36,Rr=37,Cr=38,vr=39,yn=40,Bn=41,Ur=42,yr=43,Br=44,Dn=45,Dr=46,Mr=47,Fr=48,jr=49,Mn=50,wr=51,Yr=52,Fn=53,jn=54,gr=55,Gr=56,Vr=57,$r=58,wn=59,Kr=60,Hr=61,zr=62,Xr=63,Jr=64,Wr=65,Zr=66,Qr=67,qr=68,xr=69,Yn=70,ea=71,ta=72,sa=73,gn=74,na=75,oa=76,ca=77,ra=78,At=1,aa=2,ua=3,la=4,Gn=5,ia=6,js=1,fa=2,Ea=3,_a=4,ma=5,Rt=6,pa=7,Vn=8,ws=9,$n=10,Ys=11,ba=12,Oa=13,Kn=14,Hn=15,zn=16,Aa=17,Ta=18,Na=19,Xn=20,Jn=21,da=22,Wn=23,Ia=24,ha=25,Sa=26,Zn=27,ka=28,Pa=29,Qn=30,La=31,qn=32,Ra=33,Ca=34,va=35,Ua=36,ya=37,xn=38,eo=39,Ba=40,Da=41,Ma=42,Fa=43,ja=44,to=45,so=46,wa=47,gs=48,Ya=49,ga=50,Ga=51,Va=52,$a=53,Ka=54,Ha=55,za=56,Xa=57,Ja=58,Wa=59,Za=60,Qa=61,qa=62,xa=63,no=64,eu=65,oo=66,tu=67,Gs=68,Vs=69,co=70,su=71,nu=72,ou=73,cu=74,ru=75,au=76,uu=77,lu=78,iu=79,fu=80,Eu=81,_u=82,mu=83,pu=84,ro=85,bu=86,Ou=87,Au=88,Tu=89,ao=90,Nu=91,du=92,Iu=93,hu=94,uo=1,Su=2,ku=3,Pu=4,Lu=5,Ru=6,Cu=7,vu=8,Uu=9,yu=10,lo=11,Bu=12,Du=13,Mu=14,Fu=15,io=16,ju=17,wu=18,Yu=19,gu=20,{K_FLOGRAM:ke}=ls.Keywords,Gu="0",Vu="any",fo="data",$u="code",Eo=R=>["TRUE","FALSE"].includes(R),$s=!1,fl=R=>{let L=[],v=[],H=[],z={name:"draw",type:"procedure",description:{inputs:[{name:"a",data:{type:"data",name:ut,path:"Flogram"}}],locals:[],outputs:[]}},se=Object.freeze({data:L,code:v,exports:H}),ie=new Uint8Array(kE),me=[],Ie=0,_e=(a,o,e,f)=>{let t=Object.freeze({position:a,length:f});tn(o,ie,e,e+f|0,Ie,Ie+f|0),me.push(t),Ie=Ie+f|0},Te=()=>{Ie=0;let a=ie,o=me,e=0;for(;o.length>0;){let f=o.shift(),{length:t,position:s}=f;qt(s,a,e,t),e=e+t|0}},Be=()=>{let a=new Date,o=a.getHours().toString().padStart(2,"0"),e=a.getMinutes().toString().padStart(2,"0"),f=a.getSeconds().toString().padStart(2,"0"),t=a.getMilliseconds().toString().padStart(3,"0");return`${o}_${e}_${f}_${t}`},Fe=(a,o,e,f)=>{let{description:t}=a,{members:s}=t,n=s.find(E=>E.name===o[e]),u=L.find(E=>E.name===n.data.name);return u.type===Ke&&e<o.length-1?Fe(u,o,e+1,f):n},Qe=a=>{let o=Number(a);if(isNaN(o))return"";if(Number.isInteger(o)){if(o>=-Math.pow(2,31)&&o<Math.pow(2,31))return ut;if(o>=-Math.pow(2,63)&&o<Math.pow(2,63))return"I64"}else if(typeof o=="number")return a.replace(".","").length<=7?"FP32":"FP64"},qe=a=>{switch(a.type){case _t:return a.value.name;case an:case rt:return qe(a.link);case St:return qe(a.value)}return a.name},xe=(a,o)=>{let e=xt[a];if(e){let f=e.find(t=>t.description&&Array.isArray(t.description.inputs)?t.description.inputs.length!==o.length?!1:t.description.inputs.every((s,n)=>s.data.name===o[n].data.name):!1);if(f)return f;O=N|0,b=position-d|0,Qt(a);return}else{O=N|0,b=position-d|0,Oo(a);return}},mt=a=>{let o=c.procedure.description.inputs.find(e=>e.name===a)||c.procedure.description.locals.find(e=>e.name===a);if(o){let e=L.find(f=>f.type===ms&&f.name===o.data.name);if(e)return{data:e}}return o},re=(a,o=!1)=>{let e;switch(a.type){case _t:{let f=c.stack.get(a.value.name||a.value.link,a.value.value);if(f){let t=L.find(T=>T.name===f.name),{description:s}=t,{members:n}=s,u=0,E=n.find(T=>T.name===a.trail[u]),m=L.find(T=>T.name===E.data.name);if(m.type===Ke&&u<a.trail.length-1)e={data:Fe(m,a.trail,u+1,o)?.data};else{if(E.data.freed){O=N|0,b=position-d|0,ue(`Attempted to use '${a.trail.join(".")}', which has been freed. Ensure links are valid before use.`);return}if(o){let T=L.indexOf(t),I=JSON.parse(JSON.stringify(t)),k=t.description.members.indexOf(E);k>=0&&(I.description.members[k].data.freed=!0,L.splice(T,1,I))}e=E}}break}case rt:{e=re(a.link);break}case un:case St:{e=re(a.value);break}case gt:{e={data:{type:De,name:vt,path:ke}};break}case ln:{e={data:{type:De,name:ut,path:ke}};break}case bs:{e={data:c.stack.get(a.array.name)};break}case rn:{if(a.trail.length>0){let f=L.find(t=>{if(t.description&&t.description.members)return t.description.members.find(s=>s.name===a.trail[0])});if(f){let{description:t}=f,{members:s}=t,n=0,u=s.find(m=>m.name===a.trail[n]),E=L.find(m=>m.name===u.data.name);E.type===Ke&&n<a.trail.length-1?e={data:Fe(E,a.trail,n+1,o).data}:e={data:u.data}}else O=N|0,b=0,pt(a.trail[0],`${at}(current object in definition)`)}else e=c.stack.get(a.trail[0]);break}case Ct:{let f=s=>v.find(n=>n.type===ot&&n.name===s.name)?.description.outputs[0],t=(s,n)=>{let u;for(let E=0;n&&E<=s.name.length-2;E++)n=c.stack.get(s.name[E]),n&&(u=L.find(m=>m.type===Ke&&m.name===n.name));return u?.description.members?.find(E=>E.name===s.name[s.name.length-1])?.description.outputs[0]};if(a.path!==ke){if(e=f(a),typeof a.name=="object"){let s=c.stack.get(a.name[0]);e=t(a,s);let n=a.name.length;a.name[n-1]===Os&&(e={data:s})}}else if(nc.has(a.name))e={data:{type:De,name:"Bool",path:ke}},Ge(e.data.name);else{let s=a.inputs.map(u=>re(u)),n=v.find(u=>u.description&&Array.isArray(u.description.inputs)?u.description.inputs.length!==s.length||u.name!==a.name||u.path!==a.path?!1:u.description.inputs.every((E,m)=>E.data.name===s[m].data.name):!1);if(n){let{description:u}=n,{outputs:E}=u;e=E[0]}else{O=N|0,b=position-d|0,ue(`Unable to find expression matching: ${s.map(u=>u.data.name)}`);return}}break}default:{e=mt(a.name);break}}if(!e)if(Bo.includes(a.name)&&a.type===Ct){let f=a.inputs.map(s=>re(s)),t=xe(a.name,f);e={data:{name:t.description.outputs[0].data.name,path:t.description.outputs[0].data.path}}}else a.type===Me&&(e={data:{type:Me,name:a.name,literal:a.literal,path:a.path}});return e},ge=a=>{let o=re(a);return o&&a.type!==_t&&o.data.path===ke&&o.data.type!==Ye&&o.data.mutable?Object.seal({type:rt,link:a}):a},et=(a,o)=>{let e=JSON.parse(JSON.stringify(a)),f=a.description.generics.map(s=>s.name);function t(s){for(let n in s)if(s[n]&&typeof s[n]=="object")t(s[n]);else if(n==="name"&&f.includes(s[n])){let u=f.indexOf(s[n]);s[n]=o[u].name,s.path=o[u].path}else if(n==="path"&&s[n].split(".").includes(e.name)){let u=s[n].split("."),E=u.indexOf(e.name),m=it(e.name,o);u[E]=m,s[n]=u.join(".")}}t(e);for(let s of v){let{description:n}=s,{inputs:u,outputs:E}=n,m=[...u,...E];if(s.type==="native"&&m.some(T=>f.includes(T.data.name))){let T=JSON.parse(JSON.stringify(s));t(T),v.push(T)}}return e},it=(a,o)=>{let f=o.map(t=>`${t.name}${t.segment?`_${t.segment}`:""}`).join("__");return`${a}___${f}`},Tt=a=>a.type===St&&a.value!==at||a.type===rt&&a.link!==at,{path:F,imports:B,files:U,Tokenizer:J}=R,W=new Map,ae=new Map,ne=new Map,ee=new Map,Pe=(a,o="")=>{let{name:e,path:f}=a,t=o||e,s=`${f}.${t}`;ne.set(s,a);let n=ee.get(t)||[];n.push(a),ee.set(t,n)},{data:ft}=B;for(let a of ft)Pe(a);let tt=[F],i=new Ku.default,p=[],h=[],S=[],l=!1,C=!1,D=!1,G=!0,j=!1,Y=!1,P=Re,r=os,c=null,pe=null,Se=[],he=0,N=1,d=0,Oe=1,Nt=null,O=0,b=0,st=(a,o,e,f)=>{let t=o.subarray(e,e+f|0),s=_(t);return SE(a,o,e,f)?(O=N|0,b=a-d|0,pl(s),!0):Ve(a,o,e,f)?(O=N|0,b=a-d|0,ve(s),!0):!1};i.on(Zt,a=>{for(let o of h)o(a)}),i.on(ye,a=>{for(let o of S)o(a)});let as=a=>{let o=Object.freeze({type:Zu,message:ze.FAIL_DUPLICATE_DATA(a),failureRow:O,failureColumn:b,name:a});C=!0,D=!0,i.emit(ye,o)},po=(a,o)=>{let e=Object.freeze({type:Qu,message:ze.FAIL_DUPLICATE_OBJECT_MEMBER(a,o),failureRow:O,failureColumn:b,property:a,object:o});C=!0,D=!0,i.emit(ye,e)},El=a=>{let o=Oe,e=dt(a),f=Object.freeze({type:Ju,message:ze.FAIL_INDENTATION_MISMATCH(O),failureRow:O,failureColumn:b,expected:o,actual:e});C=!0,D=!0,i.emit(ye,f)},bo=a=>{let o=Object.freeze({type:Wu,message:ze.FAIL_INDENTATION_NO_INCREASE(O),failureRow:O,failureColumn:b,indentation:Oe});C=!0,D=!0,i.emit(ye,o)},ve=a=>{let o=Object.freeze({type:qu,message:ze.FAIL_INVALID_IDENTIFIER(a),failureRow:O,failureColumn:b,identifier:a});C=!0,D=!0,i.emit(ye,o)},_l=(a,o)=>{let e=Object.freeze({type:xu,message:ze.FAIL_RETURN_LENGTH_MISMATCH(a,o),failureRow:O,failureColumn:b});D=!0,i.emit(ye,e)},ml=a=>{let o=Object.freeze({type:sl,message:ze.FAIL_IMMUTABLE_ASSIGNMENT(a),failureRow:O,failureColumn:b,variable:a});C=!0,D=!0,i.emit(ye,o)},pl=a=>{let o=Object.freeze({type:nl,message:ze.FAIL_RESERVED_KEYWORD_USAGE(a),failureRow:O,failureColumn:b,keyword:a});C=!0,D=!0,i.emit(ye,o)},w=(a,o,e)=>{let f=Object.freeze({type:Xu,message:ze.FAIL_UNEXPECTED_TOKEN(a,o,b),failureRow:O,failureColumn:b,reasons:e,expected:a,found:o});C=!0,D=!0,i.emit(ye,f)},us=a=>{let o=Object.freeze({type:zu,message:ze.FAIL_UNRESOLVED_NAME(a),failureRow:O,failureColumn:b,name:a});C=!0,D=!0,i.emit(ye,o)},pt=(a,o)=>{let e=Object.freeze({type:el,message:ze.FAIL_UNRESOLVED_OBJECT_MEMBER(a,o),failureRow:O,failureColumn:b,name:a});C=!0,D=!0,i.emit(ye,e)},Oo=a=>{let o=Object.freeze({type:tl,message:ze.FAIL_UNKNOWN_PROCEDURE_NAME(a),failureRow:O,failureColumn:b,name:a});C=!0,D=!0,i.emit(ye,o)},bl=a=>{let o=Object.freeze({type:NE,message:ze.FAIL_UNALLOWED_COPY(a),failureRow:O,failureColumn:b,name:a});C=!0,D=!0,i.emit(ye,o)},Ol=(a,o)=>{let e=Object.freeze({type:ol,message:ze.FAIL_ASSIGNMENT_TYPE_MISMATCH(a,o),failureRow:O,failureColumn:b});C=!0,D=!0,i.emit(ye,e)},ue=a=>{let o=Object.freeze({type:dE,message:a,failureRow:O,failureColumn:b});C=!0,D=!0,i.emit(ye,o)},Al=a=>{let o=Object.freeze({type:AE,message:ze.FAIL_INPUT_TYPE_MISMATCH(O,a),failureRow:O,failureColumn:b,inputs:a});C=!0,D=!0,i.emit(ye,o)},Qt=a=>{let o=Object.freeze({type:TE,message:ze.FAIL_UNSUPPORTED_TYPE(a),failureRow:O,failureColumn:b,inputs});C=!0,D=!0,i.emit(ye,o)},dt=a=>a-d|0,Hs=a=>{let o=Oe|0;return dt(a)<o},zs=(a,o)=>{let e=Oe|0,f=dt(a);switch(o){case mn:return f<=e;case sc:return f!==e}throw pn},VE=a=>{v.push(a)},Xs=(a,o=!0)=>{let{name:e,path:f}=a,t=`${f}.${e}`;if(!W.has(t)){o?L.unshift(a):L.push(a),W.set(t,a),ne.has(t)||Pe(a);return}},Ge=a=>{let o=ee.get(a);if(!o)return null;if(o.length===1){let[e]=o;return Xs(e),e}throw pn},$E=(a,o)=>{let{description:e}=a,{inputs:f,locals:t}=e,{name:s}=o;for(let n of f)if(n.name===s)return n.data;for(let n of t)if(n.name===s)return n.data;return null},Tl=(a,o,e,f)=>{switch(r){case os:{let t=o.subarray(e,e+f|0);if(c&&c.export&&(Oe=dt(a),Nt&&Nt!==Oe&&(M(),c=null,y(),Nt=null,Oe=1),Nt=Oe),X(t,aE)){y(),P=fc,r=qc,l=!0;return}if(X(t,uE)){y(),Oe=dt(a),c=Object.freeze({export:!0,indentation:Oe}),r=mc;return}if(X(t,xf)){y(),P=ac,r=bc,l=!0;return}if(X(t,En)||X(t,Qo)){y(),P=uc,r=Mc,l=!0;return}if(X(t,$t)){y(),P=Tn,r=Zc,l=!0;return}if(X(t,Jo)){y(),P=lc,r=Ls,l=!0;return}break}case mc:{if(o[e]===be){r=os,y(),r=pc;return}l=!0,r=os;break}case pc:{if(o[e]===ce){r=os;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=Kt;w(_(ce),n,u);break}case Ec:{Y=!1;let t=o.subarray(e,e+f|0);if(X(t,sE)){P=we,r=nr,l=!0;return}if(X(t,nE)){P=we,r=Br,l=!0;return}if(X(t,eE)){P=we,r=Ir,l=!0;return}if(X(t,iE)){P=we,r=Zr,l=!0;return}if(X(t,fE)){P=we,r=na,l=!0;return}if(X(t,tE)){P=we,r=Pr;return}if(X(t,Wo)){P=we,r=mr,l=!0;return}if(X(t,Ut)||X(t,kt)||X(t,ds)){O=N|0,b=a-d|0;let u=_(t);w("statement declarer",u,An);return}if(X(t,$t)){P=we,r=ir,l=!0;return}if(X(t,oE)){P=we,r=Er,l=!0;return}if(X(t,ec)||X(t,lE)){P=we,r=Hr,l=!0;return}if(!st(a,o,e,f)){P=we,r=Fr,l=!0;return}O=N|0,b=a-d|0;let s=_(t);w("statement declarer",s,FE);break}case Ce:{let t=o[e],s=o.subarray(e,e+f|0),n=_(s);if(L.find(E=>E.type===Yt&&E.description.labels.find(m=>m.name===n))){P=Ue,r=qn,l=!0;return}if(on(t)&&!Eo(_(s))){if(L.find(T=>T.name===n&&T.type===Ke)){P=Ue,r=Oa,l=!0;return}if(L.find(T=>T.type===Yt&&T.name===n)){P=Ue,r=qn,l=!0;return}}if(X(s,Is)){P=Ue,r=va,l=!0;return}if(X(s,Zo)){P=Ue,r=Sa,l=!0;return}if(X(s,Wo)){P=Ue,r=Ea,l=!0;return}if(X(s,Ut)){P=Ue,r=js,l=!0;return}if(X(s,kt)){P=Ue,r=js,l=!0;return}if(X(s,ds)){P=Ue,r=js,l=!0;return}if(X(s,Ns)){P=Ue,r=co,l=!0;return}if(X(s,cE)){P=Ue,r=Ka,l=!0;return}if(X(s,rE)){P=Ue,r=iu,l=!0;return}if(t===Je){P=Ue,r=Jn,l=!0;return}if(t===Ee){P=Ue,r=Tu,l=!0;return}r=Nn,l=!0;break}case Nn:{_e(a,o,e,f),y(),c=o[e],r=_c;break}case _c:{_e(a,o,e,f);let t=c;M();let s=o[e];if(s===Ee){P=Ue,r=ws,Te();return}if(s===Je){P=Ue,r=da,Te();return}if(s===Le&&t!==Pt){P=Ue,r=ws,Te();return}if(s===He){r=Nn;return}P=Ue,r=ma,Te();break}}},Nl=(a,o,e,f)=>{switch(r){case bc:{let t=tt.join("."),s=Object.seal({labels:[],generics:[]}),n=Object.seal({type:Yt,name:nt,path:t,description:s});c=Object.seal({enumeration:n}),r=Oc;break}case Oc:{let{enumeration:t}=c,s=o.subarray(e,e+f|0),n=_(s);if(st(a,o,e,f))return;t.name=n,r=Ac;break}case Ac:{let t=o[e];if(t===be){r=Tc;return}if(t===Le){let{enumeration:E}=c,{description:m}=E,{generics:T}=m;y(),c=T,P=ns,r=rs,l=!0;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=lt;w(`${_(be)} or ${_(Le)} for generics`,n,u);break}case Tc:{if(o[e]===ce){r=Nc;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=Kt;w(_(ce),n,u);break}case Nc:{Oe=dt(a),r=dn,l=!0;break}case dn:{let{enumeration:t}=c;if(Hs(a)){if(Xs(t),M(),c&&c.export){let s=Object.freeze({name:t.name,type:t.type,path:fo});H.push(s);let n=Oe;M(),Oe===n&&M(),Oe<n&&y()}l=!0;return}r=dc,l=!0;break}case dc:{let{enumeration:t}=c,{description:s}=t,{labels:n}=s,u=o.subarray(e,e+f|0),E=_(u);if(st(a,o,e,f))return;let m={name:E};n.push(m),r=dn,y(),r=Ic;break}case Ic:{let t=o[e];if(l=!0,t===Ee){r=hc;return}let{enumeration:s}=c,{description:n}=s,{labels:u}=n,E=u.length-1;c=Object.seal({label:u[E]}),r=In;break}case hc:{if(o[e]===Ee){r=Sc;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=$e;w(_(Ee),n,u);break}case Sc:{let{enumeration:t}=c,{description:s}=t,{labels:n}=s;if(Ve(a,o,e,f)){O=N|0,b=a-d|0,ve(E);return}let u=o.subarray(e,e+f|0),E=_(u),m=n.pop();m.data={name:E,path:F},n.push(m),r=kc;break}case kc:{if(o[e]===be){r=Pc;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=lt;w(_(be),n,u);break}case Pc:{let{enumeration:t}=c,{description:s}=t,{labels:n}=s,u=o.subarray(e,e+f|0),E=_(u);if(st(a,o,e,f))return;let m=n.pop();m.data.type=E,n.push(m),c=Object.seal({label:m}),r=Lc;break}case Lc:{if(o[e]===oe){r=In;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=Xe;w(_(oe),n,u);break}case In:{if(o[e]===ce){M();return}break}}},dl=(a,o,e,f)=>{switch(r){case rs:{r=yc,l=!0;break}case yc:{if(o[e]===Le){r=ks;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=$e;w(_(Le),n,u);break}case ks:{let t=o[e];if(t===ce)return;if(t===je){M();return}r=Bc,l=!0;break}case Bc:{let t=o.subarray(e,e+f|0),s=_(t);if(st(a,o,e,f))return;y();let n=Object.seal({type:ms,name:s,path:F});c=Object.seal({name:s,data:n}),Pe(c.data,c.name),r=Dc;break}case Dc:{let t=c;M(),c.push(t);let n=o[e];if(n===je){r=ks,l=!0;return}if(n===de){r=ks;return}O=N|0,b=a-d|0;let u=o.subarray(e,e+f|0),E=_(u),m=Xe;w(_(oe),E,m);break}}},Il=(a,o,e,f)=>{switch(r){case cs:{r=Rc,l=!0;break}case Rc:{if(o[e]===Ee){r=Ss;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=$e;w(_(Ee),n,u);break}case Ss:{let t=o[e];if(t===ce)return;if(t===oe){M();return}r=Cc,l=!0;break}case Cc:{let t=o.subarray(e,e+f|0);if(y(),X(yt,t)){c=Object.seal({name:null,mutable:!0,data:null}),r=hn;return}c=Object.seal({name:null,data:null}),r=hn,l=!0;break}case hn:{let t=o.subarray(e,e+f|0),s=_(t);if(st(a,o,e,f))return;c.name=s,r=vc;break}case vc:{if(o[e]===be){r=Uc,y(),P=Mt,r=At;return}break}case Uc:{let t=c;M();let s=c,{mutable:n,...u}=t;s.push(u);let E=o[e];if(E===oe){r=Ss,l=!0;return}if(E===de){r=Ss;return}O=N|0,b=a-d|0;let m=o.subarray(e,e+f|0),T=_(m),I=Xe;w(`${_(oe)} or ${_(de)}`,T,I);break}}},hl=(a,o,e,f)=>{switch(r){case Mc:{let t=tt.join("."),s=Object.seal({members:[],generics:[]}),n=Object.seal({type:Ke,name:nt,copy:!0,path:t,description:s});c=Object.seal({mapNameMember:new Map,object:n}),r=Fc,l=!0;break}case Fc:{let t=o.subarray(e,e+f|0);if(r=jc,X(t,Qo)){c.object.copy=!1;return}l=!0;break}case jc:{let t=o.subarray(e,e+f|0);if(X(t,En)){r=wc;return}O=N|0,b=a-d|0;let s=_(t),n=lt;w(_(En),s,n);break}case wc:{let{object:t}=c,s=o.subarray(e,e+f|0),n=_(s);if(st(a,o,e,f))return;let u=Ge(n);if(u&&tt.join(".")===u.path&&(O=N|0,b=a-d|0,as(n)),X(s,yt)){O=N|0,b=a-d|0,failReservedKeyword(n);return}t.name=n,Xs(t,!1),r=Yc;break}case Yc:{if(o[e]===Le)r=gc,l=!0;else if(o[e]===be)r=Sn,l=!0;else{let t=o.subarray(e,e+f|0),s=_(t);O=N|0,b=a-d|0,ve(s);return}break}case gc:{let{object:t}=c,{description:s}=t,{generics:n}=s;r=Sn,y(),c=n,P=ns,r=rs,l=!0;break}case Sn:{if(o[e]===be){r=Gc;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=lt;w(_(be),n,u);break}case Gc:{if(o[e]===ce){r=Vc;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=Kt;w(_(ce),n,u);break}case Vc:{if(zs(a,mn)){let t=p.length;if(p.length<1||p[t-1].item.indentation>=Oe){O=N|0,b=a-d|0,bo(a);return}}Oe=dt(a),r=Ps,l=!0;break}case Ps:{let{object:t}=c;if(Hs(a)){if(M(),c&&c.export){let s=Object.freeze({name:t.name,type:t.type,path:fo});H.push(s);let n=Oe;M(),Oe===n&&M(),Oe<n&&y()}l=!0;return}if(zs(a,sc)){O=N|0,b=a-d|0,El(a);return}r=$c,l=!0;break}case $c:{let{object:t,mapNameMember:s}=c,{description:n}=t,{members:u}=n,E=o.subarray(e,e+f|0),m=_(E);if(r=Kc,X(E,yt)){y(),c=Object.freeze({mutable:!0});return}l=!0;break}case Kc:{let t;c.mutable&&(t=c.mutable,M());let{object:s,mapNameMember:n}=c,{description:u}=s,{members:E}=u,m=o.subarray(e,e+f|0),T=_(m);if(X(Jo,m)){r=Ps,y(),P=ic,r=Ls,l=!0;return}if(st(a,o,e,f))return;n.has(T)&&(O=N|0,b=a-d|0,po(T,s.name));let I={name:T,data:null};t&&(I.mutable=t),E.push(I),n.set(T,I),r=Ps,y(),c=Object.seal({member:I}),r=Hc;break}case Hc:{if(o[e]===be){r=zc;return}break}case zc:{r=Wc,y(),c=Object.seal({data:null}),y(),P=Mt,r=At,l=!0;break}case Wc:{let t=o[e],{data:s}=c;M();let{member:n}=c;if(n.data=s,n.mutable&&(n.data={...s,mutable:n.mutable}),t===ce){M();return}if(t===Ot){r=Xc;return}O=N|0,b=a-d|0;let u=o.subarray(e,e+f|0),E=_(u),m=Dt;w(`${_(ce)} or ${_(Ot)}`,E,m);break}case Xc:{let{stack:t}=c;r=Jc,y(),c={stack:new Map,procedure:null,value:null},y(),r=Ce,P=Re,l=!0;break}case Jc:{let{value:t}=c;M();let{member:s}=c;s.value=t,M();break}}},Sl=(a,o,e,f)=>{switch(r){case Ls:{let{mapNameMember:t,object:s}=c,{name:n}=s,u=new Map(t),E=`${tt.join(".")}.${n}`,m=Object.seal({generics:[],inputs:[],locals:[],outputs:[],statements:[]}),T=Object.seal({type:ot,name:nt,path:E,description:m});c=Object.seal({procedure:T,stack:u}),r=Rs;break}case Rs:{let{procedure:t}=c,s=o.subarray(e,e+f|0),n=_(s);if(st(a,o,e,f))return;if(X(s,yt)){O=N|0,b=a-d|0,failReservedKeyword(n);return}t.name=n,r=Cs;break}case Cs:{if(o[e]===Le)r=vs,l=!0;else if(o[e]===Ee)r=Jt,l=!0;else{let t=o.subarray(e,e+f|0),s=_(t);O=N|0,b=a-d|0,ve(s);return}break}case vs:{let{procedure:t}=c,{description:s}=t,{generics:n}=s;r=Jt,y(),c=n,P=ns,r=rs,l=!0;break}case Jt:{let{procedure:t}=c,{description:s}=t,{inputs:n}=s;r=Us,y(),c=n,P=ss,r=cs,l=!0;break}case Us:{let{procedure:t,stack:s}=c,{description:n}=t,{inputs:u}=n;for(let k of u){let{name:V,data:g}=k;s.set(V,g)}u.length>0&&c.procedure.name===Ho&&(O=N|0,b=a-d|0,ue("Destructors should not return any values. Your destructor appears to return a number. Please adhere to Flogram's conventions and correct your code."));let E=o.subarray(e,e+f|0),m=o[e];if(X(E,As)){r=ys;return}if(m===be){r=Wt,l=!0;return}O=N|0,b=a-d|0;let T=_(E),I=oc;w(`${_(As)} or ${_(be)}`,T,I);break}case ys:{let{procedure:t}=c,{description:s}=t,{outputs:n}=s;r=Wt,y(),c=n,P=ss,r=cs,l=!0;break}case Wt:{let t=o[e],{outputs:s}=c.procedure.description;if(s.length>0&&c.procedure.name===Os&&(O=N|0,b=a-d|0,ue(`Constructors in Flogram should not return any values. Your constructor seems to return ${s.length} outputs. Please correct your code according to Flogram rules.`)),s.length>0&&c.procedure.name===Ho&&(O=N|0,b=a-d|0,ue(`Destructors in Flogram should not return any values. Your destructor seems to return ${s.length} outputs. Please correct your code according to Flogram rules.`)),t===be){r=Bs;return}O=N|0,b=a-d|0;let n=o.subarray(e,e+f|0),u=_(n),E=lt;w(_(be),u,E);break}case Bs:{if(o[e]===ce){r=Ds;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=Kt;w(_(ce),n,u);break}case Ds:{let{procedure:t,stack:s}=c,{description:n}=t,{statements:u}=n;r=Ms,y(),c=Object.seal({procedure:t,stack:s,statements:u}),P=we,r=Lt,l=!0;break}case Ms:{let{procedure:t}=c,{name:s}=t;M();let{object:n,mapNameMember:u}=c,{description:E}=n,{members:m}=E;u.has(s)&&(O=N|0,b=a-d|0,po(s,n.name));let T=Object.seal({name:t.name,data:{name:t.name,type:t.type,path:t.path}});m.push(t),u.set(s,T),l=!0;break}}},kl=(a,o,e,f)=>{switch(r){case Zc:{let t=o.subarray(e,e+f|0);if(X(t,$t)){y(),P=Tn,r=Qc,l=!0;return}break}case Qc:{if(o[e]===ce){M();return}break}}},Pl=(a,o,e,f)=>{switch(r){case Ls:{let t=new Map,s=tt.join("."),n=Object.seal({generics:[],inputs:[],locals:[],outputs:[],statements:[]}),u=Object.seal({type:ot,name:nt,path:s,description:n});c=Object.seal({procedure:u,stack:t}),r=Rs;break}case Rs:{let{procedure:t}=c,s=o.subarray(e,e+f|0),n=_(s);if(st(a,o,e,f))return;if(X(s,yt)){O=N|0,b=a-d|0,failReservedKeyword(n);return}t.name=n,r=Cs;break}case Cs:{if(o[e]===Le)r=vs,l=!0;else if(o[e]===Ee)r=Jt,l=!0;else{let t=o.subarray(e,e+f|0),s=_(t);O=N|0,b=a-d|0,ve(s);return}break}case vs:{let{procedure:t}=c,{description:s}=t,{generics:n}=s;r=Jt,y(),c=n,P=ns,r=rs,l=!0;break}case Jt:{let{procedure:t}=c,{description:s}=t,{inputs:n}=s;r=Us,y(),c=n,P=ss,r=cs,l=!0;break}case Us:{let{procedure:t,stack:s}=c,{description:n}=t,{inputs:u}=n;for(let k of u){let{name:V,data:g}=k;s.set(V,g)}let E=o.subarray(e,e+f|0),m=o[e];if(X(E,As)){r=ys;return}if(m===be){r=Wt,l=!0;return}O=N|0,b=a-d|0;let T=_(E),I=oc;w(`${_(As)} or ${_(be)}`,T,I);break}case ys:{let{procedure:t}=c,{description:s}=t,{outputs:n}=s;r=Wt,y(),c=n,P=ss,r=cs,l=!0;break}case Wt:{let t=o[e],{procedure:s}=c;if(v.push(s),t===be){r=Bs;return}O=N|0,b=a-d|0;let n=o.subarray(e,e+f|0),u=_(n),E=lt;w(_(be),u,E);break}case Bs:{if(o[e]===ce){r=Ds;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=Kt;w(_(ce),n,u);break}case Ds:{let{procedure:t,stack:s}=c,{description:n}=t,{statements:u}=n;r=Ms,y(),c=Object.seal({procedure:t,stack:s,statements:u}),P=we,r=Lt,l=!0;break}case Ms:{let E=function(m,T=!0){let I=[Xo,zo,Go],k=!1;if(m.find(g=>g.type===ps))return!0;for(let g=m.length-1;g>=0;g--){let $=m[g];if(I.includes($.type)&&$.statements)E($.statements,!1)&&(k=!0);else if($.type===go)if($.branches&&$.branches.length>0){let K=m.some(Z=>Z.type===ps);if(T&&!K&&$.branches.length<2)return console.error("Error: If the condition is not met, the procedure will not return."),O=N|0,b=a-d|0,ue("Procedure does not return on a specific condition; it will not return if conditions are not met."),!1;if(!K){for(let Z of $.branches)if(!Z.statements||!E(Z.statements,!1))return O=N|0,b=a-d|0,ue(`Procedure ${t.name} does not have a return statement. Please make sure your return values are marked as defined in the procedure definition.`),!1;g!==m.length-1&&(console.log("Code will not be executed after return in block"),O=N|0,b=a-d|0,ue(`Code after return statement will not be executed. Procedure ${t.name} has defined statements after a return statements which makes them unreachable.`))}k=!0}else return console.error("Error: Condition does not have branches"),!1;else $.type===ps&&(g!==m.length-1&&(console.log("Code will not be executed after return in block"),O=N|0,b=a-d|0,ue(`Code after return statement will not be executed. Procedure ${t.name} has defined statements after a return statements which makes them unreachable.`)),k=!0);if(k==!0)break}return T&&!k&&(O=N|0,b=a-d|0,ue(`Procedure ${t.name} does not have a return statement. Please make sure your return values are marked as defined in the procedure definition.`)),k},{procedure:t}=c,{description:s}=t,{statements:n,outputs:u}=s;if(u.length!==0&&E(n),M(),c&&c.export){let m=Object.freeze({name:t.name,type:t.type,path:$u});H.push(m);let T=Oe;M(),Oe===T&&M(),Oe<T&&y()}l=!0;break}}},Ll=(a,o,e,f)=>{switch(r){case Lt:{if(zs(a,mn)){O=N|0,b=a-d|0,bo(a);return}Oe=dt(a),r=sr,l=!0;break}case sr:{let t=o.subarray(e,e+f|0);if(Hs(a)){M(),l=!0;return}y(),P=Re,r=Ec,l=!0;break}case Pr:{let{statements:t}=c,s={type:Zf};t.push(s),M();break}case na:{let{procedure:t,stack:s,statements:n}=c,u=Object.seal({type:Xo,condition:null,statements:[]});n.push(u),y(),c=Object.seal({blockWhile:u,procedure:t,stack:s}),r=oa;break}case oa:{let{stack:t,procedure:s}=c;r=ca,y(),c={stack:t,procedure:s,value:null},y(),r=Ce,P=Re,l=!0;break}case ca:{if(o[e]===be){let{value:E}=c;M();let{blockWhile:m}=c;m.condition=E,r=ra;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=lt;w(_(be),n,u);break}case ra:{let{blockWhile:t,procedure:s,stack:n}=c,{statements:u}=t;if(o[e]===ce){r=gn,y(),c=Object.seal({procedure:s,stack:n,statements:u}),P=we,r=Lt;return}O=N|0,b=a-d|0;let m=o.subarray(e,e+f|0),T=_(m),I=Dt;w(_(ce),T,I);break}case Zr:{let{procedure:t,stack:s,statements:n}=c,u=Object.seal({type:zo,iterator:null,index:`{j_${Be()}}`,collection:null,statements:[]}),E={name:u.index,data:{type:De,name:ut,path:ke}};s.set(E.name,E.data),n.push(u),y(),c=Object.seal({blockForeach:u,procedure:t,stack:new Map(JSON.parse(JSON.stringify(Array.from(s))))}),r=Qr;break}case Qr:{let t=o.subarray(e,e+f|0),{blockForeach:s,stack:n}=c,u=_(t);if(n.has(u)){as(u),O=N|0,b=a-d|0;return}s.iterator=u,r=qr;break}case qr:{let{blockForeach:t,stack:s,procedure:n}=c,{description:u}=n,{locals:E}=u,m=o.subarray(e,e+f|0);if(X(EE,m)){s.delete(t.index),r=xr;return}l=!0,r=Yn;break}case xr:{let{blockForeach:t,stack:s,procedure:n}=c,{description:u}=n,{locals:E}=u,m=o.subarray(e,e+f|0),T=_(m);if(s.has(T)){as(T),O=N|0,b=a-d|0;return}let I={name:T,data:{type:De,name:ut,path:ke}};s.set(T,I.data),E.push(I),t.index=T,r=Yn;break}case Yn:{let{blockForeach:t,stack:s,procedure:n}=c,{description:u}=n,{locals:E}=u,m=o.subarray(e,e+f|0);if(X(tc,m)){s.has(t.index)&&!E.find(k=>k.name===t.index)&&E.push({name:t.index,data:s.get(t.index)}),r=ea;return}O=N|0,b=a-d|0;let T=_(m),I=lt;w(_(tc),T,I);break}case ea:{let{stack:t,procedure:s}=c;r=ta,y(),c={stack:t,procedure:s,value:null},y(),r=Ce,P=Re,l=!0;break}case ta:{if(o[e]===be){let{value:E,stack:m,procedure:T}=c,{description:I}=T,{locals:k}=I;M();let{blockForeach:V}=c;V.collection=E;let{data:g}=re(E),$={name:V.iterator,data:{type:g.contains||De,name:g?.name,path:g?.path,layout:g.contains}};m.set($.name,$.data),k.push($),r=sa;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=lt;w(_(be),n,u);break}case sa:{let{blockForeach:t,procedure:s,stack:n}=c,{statements:u}=t;if(o[e]===ce){r=gn,y(),c=Object.seal({procedure:s,stack:n,statements:u}),P=we,r=Lt;return}O=N|0,b=a-d|0;let m=o.subarray(e,e+f|0),T=_(m),I=Dt;w(_(ce),T,I);break}case gn:{M(),M(),l=!0;break}case Ir:{let{procedure:t,stack:s,statements:n}=c,u=Object.freeze({type:Go,statements:[]});n.push(u),y(),c=Object.seal({blockLoop:u,procedure:t,stack:new Map(JSON.parse(JSON.stringify(Array.from(s)))),value:0}),r=hr;break}case hr:{if(o[e]===be){r=Sr;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=lt;w(_(be),n,u);break}case Sr:{let{blockLoop:t,procedure:s,stack:n}=c,{statements:u}=t;if(o[e]===ce){r=kr,y(),c=Object.seal({procedure:s,stack:n,statements:u}),P=we,r=Lt;return}O=N|0,b=a-d|0;let m=o.subarray(e,e+f|0),T=_(m),I=Dt;w(_(ce),T,I);break}case kr:{M(),M(),l=!0;break}case nr:{let{procedure:t,stack:s,statements:n}=c,u=Object.freeze({type:go,branches:[],values:[]});n.push(u),y(),c=Object.seal({blockCondition:u,procedure:t,stack:new Map(JSON.parse(JSON.stringify(Array.from(s)))),value:0}),r=Lr;break}case Lr:{_e(a,o,e,f),r=Rr;break}case Rr:{_e(a,o,e,f);let t=o[e],s=o.subarray(e,e+f|0);if(t===Ee){r=Cr,Te();return}if(X(s,fn)){r=Pn,Te();return}break}case Br:{let{stack:t,branches:s,procedure:n}=c,u={type:zf,statements:[],values:[]};s.push(u),c=Object.seal({branch:u,stack:t,procedure:n}),r=Bn;break}case Cr:{let t=o.subarray(e,e+f|0),{blockCondition:s,stack:n,procedure:u}=c,{branches:E}=s,m={type:Yo,statements:[],values:[]};E.push(m);let T=_(t),I={type:Ct,name:T,path:ke,inputs:[]},k=v.find(V=>V.type===ot&&V.name===T);k&&(I.path,k.path),c=Object.seal({blockCondition:s,branch:m,stack:n,value:I,procedure:u}),r=vr;break}case vr:{if(o[e]===Ee){r=wn;return}O=N|0,b=a-d|0;let t=o.subarray(e,e+f|0),s=_(t),n=$e;w(_(Ee),s,n);break}case wn:{let{stack:t,procedure:s}=c;if(o[e]===oe){r=yn,l=!0;return}r=Kr,y(),c={stack:t,procedure:s,value:null},y(),r=Ce,P=Re,l=!0;break}case Kr:{let{value:t}=c;M();let{value:s,stack:n,procedure:u}=c,{inputs:E}=s;E.push(ge(t));let m=o[e];if(m===oe){r=yn,l=!0;return}if(m===de){r=wn;return}O=N|0,b=a-d|0;let T=o.subarray(e,e+f|0),I=_(T),k=bn;w(`${_(de)} or ${_(oe)}`,I,k);break}case yn:{let{value:t,branch:s,stack:n}=c,{values:u}=s,{name:E}=t,m=xt[E];if(m){let V=t.inputs.map($=>re($))||[],g=m.find($=>$.description&&Array.isArray($.description.inputs)?$.description.inputs.length!==V.length?!1:$.description.inputs.every((K,Z)=>K.data.name===V[Z].data.name):!1);g&&v.push(g)}if(u.push(t),Ge("Bool"),o[e]===oe){r=Bn;return}O=N|0,b=a-d|0;let T=o.subarray(e,e+f|0),I=_(T),k=Xe;w(_(oe),I,k);break}case Bn:{let t=o.subarray(e,e+f|0);if(o[e]===be){r=Ur;return}O=N|0,b=a-d|0;let s=_(t),n=Ht;w(_(be),s,n);break}case Ur:{let{branch:t,procedure:s,stack:n}=c,{statements:u}=t;if(o[e]===ce){r=yr,y(),c=Object.seal({procedure:s,stack:n,statements:u}),P=we,r=Lt;return}O=N|0,b=a-d|0;let m=o.subarray(e,e+f|0),T=_(m),I=Dt;w(_(ce),T,I);break}case yr:{let{branch:t}=c;if(c.blockCondition){let{blockCondition:s}=c,{branches:n}=s;M(),M(),c=Object.seal({...c,branches:n})}else{M();let{branches:s,...n}=c;c=Object.seal(n)}l=!0;break}case Pn:{let{blockCondition:t,stack:s}=c,{values:n}=t,u=o.subarray(e,e+f|0),E=_(u);if(st(a,o,e,f))return;if(s.has(E)){let m=Object.freeze({type:ct,name:E});n.push(m)}r=or;break}case or:{if(o[e]===de){r=Pn;return}let s=o.subarray(e,e+f|0);if(X(s,fn)){r=cr,y(),r=rr,l=!0;return}O=N|0,b=a-d|0;let n=_(s),u=ME;w(`${_(fn)} or ${_(de)}`,n,u);break}case cr:{M(),M(),l=!0;break}case rr:{let{blockCondition:t,procedure:s,stack:n}=c,{branches:u}=t,E=Object.seal({type:Yo,statements:[],values:[]});u.push(E),c=Object.seal({blockCondition:t,branchMatch:E,procedure:s,stack:n}),r=Ln;break}case Ln:{let{blockCondition:t,branchMatch:s,stack:n}=c,{values:u}=t,{values:E}=s,m=o.subarray(e,e+f|0),T=_(m);if(st(a,o,e,f))return;if(n.has(T)){let I=Object.freeze({type:ct,name:T});E.push(I)}else if(Eo(T)){let I=Object.freeze({type:Me,literal:T,name:"Bool",path:ke});E.push(I),Ge(I.name)}else{let{procedure:I}=c,{description:k}=I,{outputs:V}=k,g=T,{name:$,path:K}=V[0].data,Z=Object.freeze({type:Me,literal:g,name:$,path:K});E.push(Z)}r=ar;break}case ar:{let t=o[e];if(t===de){r=Ln;return}if(t===be){r=ur;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=lt;w(`${_(de)} or ${_(be)}`,n,u);break}case ur:{let{branchMatch:t,procedure:s,stack:n}=c,{statements:u}=t;if(o[e]===ce){r=lr,y(),c=Object.seal({procedure:s,stack:n,statements:u}),P=we,r=Lt;return}O=N|0,b=a-d|0;let m=o.subarray(e,e+f|0),T=_(m),I=Dt;w(_(ce),T,I);break}case lr:{M();let t=o.subarray(e,e+f|0),s=_(t);l=!0;break}case ir:{r=fr;break}case fr:{if(o[e]===ce){M();return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=Dt;w(_(ce),n,u);break}case Er:{let{procedure:t,stack:s,statements:n}=c,u=Object.seal({type:ps,values:[]});n.push(u),y();let E=N|0,m=a-d|0,T=Object.freeze({row:E,column:m});c=Object.seal({commandReturn:u,coordinates:T,procedure:t,stack:s}),r=Rn;break}case Rn:{let{stack:t,procedure:s}=c;if(o[e]===ce){r=Cn,l=!0;return}r=_r,y(),c={stack:t,procedure:s,value:null},y(),r=Ce,P=Re,l=!0;break}case _r:{let{value:t}=c;M();let{commandReturn:s,stack:n,procedure:u}=c,{values:E}=s;E.push(ge(t));let m=o[e];if(m===ce){r=Cn,l=!0;return}if(m===de){r=Rn;return}O=N|0,b=a-d|0;let T=o.subarray(e,e+f|0),I=_(T),k=bn;w(`${_(ce)} or ${_(de)}`,I,k);break}case Cn:{let{commandReturn:t,coordinates:s,procedure:n}=c,{values:u}=t,{description:E}=n,{outputs:m}=E;u.length!==m.length&&(O=s.row|0,b=s.column|0,_l(m.length,u.length));for(let T of m){let I=m.indexOf(T),k=re(u[I]);k&&k.data.name!=T.data.name&&(O=s.row|0,b=s.column|0,ue(`Mismatching types provided on procedure's return. Procedure expected ${T.data.name} at index ${I} but was provided with a rather ${k.data.name}. Please review to provide matching types.`))}M(),M();break}case Fr:{let t=o.subarray(e,e+f|0),{procedure:s,stack:n,statements:u}=c,E={type:ct,name:null},m=Object.seal({type:_s,target:E,source:null});c=Object.freeze({declarationValue:m,procedure:s,stack:n,statements:u,target:E}),X(yt,t)?(E.mutable=!0,r=vn):(l=!0,r=jn);break}case jn:{_e(a,o,e,f),r=gr;break}case gr:{if(_e(a,o,e,f),o[e]===Ee){let{procedure:t,stack:s,statements:n}=c;r=Gr;let u=Object.seal({type:$o,expression:null});c=Object.seal({stack:s,procedure:t,drop:u,value:null,statements:n}),y(),P=Ue,r=ws,Te();return}if(o[e]===He){r=jn;return}r=vn,Te();break}case Gr:{let{statements:t,drop:s,value:n}=c;s.expression=n,t.push(s),M();break}case vn:{let{stack:t}=c,s=o.subarray(e,e+f|0),n=_(s),u=t.get(n);if(t.has(n)&&!u.mutable&&(Y=!0),X(Zo,s)){l=!0,r=jr;return}let{target:E}=c;E.name=n,r=Un;break}case Un:{let t=o[e],{procedure:s,stack:n,statements:u,target:E}=c;if(t===Je){let k=c.declarationValue,V={type:_s,target:{type:Hf,array:{type:ct,name:k.target.name},index:null},source:null};c=Object.seal({declarationValue:V,procedure:s,stack:n,statements:u}),l=!0,r=Tr;return}if(t===He){let k=c.declarationValue,V=[],g=k.target;c=Object.seal({declarationValue:{type:_s,target:{type:_t,value:g,trail:V},source:null},procedure:s,stack:n,statements:u}),y(),c=Object.seal({stack:n,trail:V,value:g}),r=Dn;return}if(t===be){l=!0,r=br;return}if(t===oe){let{declarationValue:k}=c;M(),c.declarationValue.target=k.target,l=!0;return}if(t===Ot){let k=c.declarationValue?.target&&qe(c.declarationValue?.target);if(k&&k!==at&&!n.get(k)){O=N|0,b=a-d|0,us(k);return}r=Fs;return}O=N|0,b=a-d|0;let m=o.subarray(e,e+f|0),T=_(m),I=Ht;w(`${_(Je)} or ${_(oe)} or ${_(Ot)} or ${_(Ot)} or ${_(He)}`,T,I);break}case jr:{c.target.type=rn,c.target.trail=[],delete c.target.name,r=Mn;break}case Mn:{if(o[e]===He){r=wr;return}r=Fn,l=!0;break}case wr:{let t=o.subarray(e,e+f|0),s=_(t);c.target.trail.push(s),r=Yr;break}case Yr:{if(o[e]===He){r=Mn,l=!0;return}r=Fn,l=!0;break}case Fn:{r=Ft,l=!0;break}case Tr:{if(o[e]===Je){r=Nr;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=On;w(_(Je),n,u);break}case Nr:{let{stack:t,procedure:s}=c;r=dr,y(),c={stack:t,procedure:s,value:null},y(),r=Ce,P=Re,l=!0;break}case dr:{if(o[e]===Bt){let{value:E}=c;M();let m=re(E);if(m.data.mutable&&E.type!==_t?c.declarationValue.target.index=Object.seal({type:rt,link:E}):c.declarationValue.target.index=E,!m||![ut,"U32","I16","U16","U8","I8"].includes(m.data.name)){O=N|0,b=a-d|0,ue("Invalid index. Array index should be a valid I32 variable");return}r=Ft;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=cc;w(_(Bt),n,u);break}case mr:{let{procedure:t,stack:s,statements:n}=c,u=Object.seal({type:an,link:null}),E=Object.seal({type:_s,target:u,source:null});c=Object.freeze({declarationValue:E,procedure:t,stack:s,statements:n}),r=Vr;break}case Vr:{if(o[e]===Ee){r=pr;return}O=N|0,b=a-d|0;let t=o.subarray(e,e+f|0),s=_(t),n=$e;w(_(Ee),s,n);break}case pr:{let{stack:t,procedure:s}=c;r=$r,y(),c={stack:t,procedure:s,value:null},y(),r=Ce,P=Re,l=!0;break}case $r:{if(o[e]===oe){let{value:u}=c;M(),c.declarationValue.target.link=u,r=Un;return}O=N|0,b=a-d|0;let t=o.subarray(e,e+f|0),s=_(t),n=Xe;w(_(oe),s,n);break}case Dr:{if(o[e]!==He){M(),l=!0;return}r=Dn;break}case Dn:{let{stack:t,value:s,trail:n}=c,u=o.subarray(e,e+f|0),E=_(u),m,T,I=!1;if(s.type===ct){let{name:k}=s;m=t.get(k)}if(m){let{name:k,path:V}=m,g=`${V}.${k}`,$=ne.get(g);$.type===Ke&&(T=$)}if(T){let{description:k}=T,{members:V}=k;for(let g of V)if(g.name===E){I=!0;break}if(!I){O=N|0,b=a-d|0,pt(E,s.name);return}}if(s.value===at||s.link===at){if(!t.get(E)){O=N|0,b=a-d|0,pt(E,`${at}(current object in definition)`);return}I=!0}if(!I){O=N|0,b=a-d|0,pt(E,s.name);return}n.push(E),r=Dr;break}case br:{let t=o.subarray(e,e+f|0),s=_(t);if(o[e]===be){let{target:E,stack:m}=c,{name:T}=E;if(m.has(T)){O=N|0,b=a-d|0,as(T);return}if(o[e+1]===Ot&&f>1){r=Mr,l=!0;return}r=Or;return}O=N|0,b=a-d|0;let u=jE;w(`${_(be)} or ${_([be,Ot])}`,s,u);break}case Or:{let{declarationValue:t,procedure:s,stack:n}=c,{target:u}=t,{description:E}=s,{locals:m}=E,T=o.subarray(e,e+f|0),I=_(T);if(Ve(a,o,e,f)){O=N|0,b=a-d|0,ve(I);return}if(X(Ns,T)){r=Ft,y(),P=Xt,r=uo,l=!0;return}if(X(T,kt)||X(T,Ut)){r=Ft,y(),P=Xt,r=lo,l=!0;return}if(X(T,Is)){r=Ft,y(),P=Xt,r=ju,l=!0;return}let k=Ge(I);if(k){let V=Object.seal({type:De,name:k.name,path:k.path}),g;u.mutable?g=Object.freeze({name:u.name,data:{...V,mutable:u.mutable}}):g=Object.freeze({name:u.name,data:V}),n.set(u.name,g.data),m.push(g)}r=Ft;break}case Mr:{let{declarationValue:t,procedure:s,stack:n,statements:u}=c,{target:E}=t,{description:m}=s,{locals:T}=m,I;E.mutable?(I={name:E.name,mutable:E.mutable,data:null},delete E.mutable):I=Object.seal({name:E.name,data:null}),n.set(E.name,I.data),T.push(I),c=Object.seal({declarationValue:t,procedure:s,stack:n,statements:u,inferenceValue:I}),r=Fs;break}case Ft:{let t=o.subarray(e,e+f|0);if(X(t,Gt)){r=Fs;return}O=N|0,b=a-d|0;let s=_(t),n=Ht;w(_(Gt),s,n);break}case Fs:{let{procedure:t,stack:s,target:n}=c,u=o[e];if(Ve(a,o,e,f)&&u!==Ee&&u!==Je){let E=o.subarray(e,e+f|0),m=_(E);O=N|0,b=a-d|0,ve(m);return}r=Ar,y(),c=Object.seal({procedure:t,stack:s,value:null}),y(),P=Re,r=Ce,l=!0;break}case Ar:{if(o[e]===ce){let{value:E}=c;M();let{declarationValue:m,statements:T,stack:I}=c;if(c.inferenceValue){let Q=function(q){let te;switch(q.type){case ct:{let fe=I.get(q.name);fe.type===De?te=fe:fe.type===Me?(te={type:De,name:fe.name,path:fe.path},q.mutable&&(te.mutable=q.mutable),q.contains&&(te.contains=q.contains)):(fe.type===Ye||fe.type==="Link")&&(te=fe);let{moved:Ao,...We}=te;te=We;break}case gt:{te={type:De,name:vt,path:ke};break}case Me:{te={type:De,name:q.name,path:q.path},q.layout===Ye&&(te.type=Ye,te.length=q.literal.length),q.contains&&(te.contains=q.contains);break}case ln:{te={type:De,name:ut,path:ke};break}case Ko:{te={type:q.type,name:q.data.name,path:q.data.path},q.data.contains&&(te.contains=q.data.contains);break}case un:{te=Q(q.value);break}case Ct:{let fe=We=>v.find(Et=>Et.type===ot&&Et.name===We.name)?.description.outputs[0]?.data,Ao=(We,Et)=>{let Ze;for(let bt=0;Et&&bt<=We.name.length-2;bt++)Et=I.get(We.name[bt]),Et&&(Ze=L.find(jt=>jt.type===Ke&&jt.name===Et.name));return Ze?.description.members?.find(bt=>bt.name===We.name[We.name.length-1])?.description.outputs[0]?.data};if(q.path!==ke){if(te=fe(q),typeof q.name=="object"){let We=I.get(q.name[0]);te=Ao(q,We)}}else if(nc.has(q.name))te={type:De,name:"Bool",path:ke},Ge(te.name);else{let We=q.inputs.map(Ze=>re(Ze)),Et=v.find(Ze=>Ze.description&&Array.isArray(Ze.description.inputs)?Ze.description.inputs.length!==We.length||Ze.name!=q.name?!1:Ze.description.inputs.every((bt,jt)=>bt.data.name===We[jt].data.name):!1);if(Et){let{description:Ze}=Et,{outputs:bt}=Ze,jt=bt[0],{data:Bl}=jt,{name:Dl,path:Ml}=Bl;te={type:De,name:Dl,path:Ml}}else{O=N|0,b=a-d|0,ue(`Unable to find expression matching: ${We.map(Ze=>Ze.data.name)}`);return}}break}case St:{te={...Q(q.value),type:Vo},q.unsafe&&(te.unsafe=q.unsafe),q.smart&&(te.smart=q.smart);break}case rt:{let fe=I.get(q.link);te={type:De,name:fe.name,path:fe.path},fe.contains&&(te.contains=fe.contains);break}case bs:{let fe=I.get(q.array.name);te={type:De,name:fe.name,path:fe.path},fe.contains&&(te.contains=fe.contains);break}case _t:return re(q)?.data;default:{console.log("Unhandled: ",q.type);break}}return te},{inferenceValue:x}=c;x.data=Q(E),x.mutable&&(x.data.mutable=x.mutable,delete x.mutable),I.set(x.name,x.data)}let{target:k}=m,V=qe(k),g=qe(E);if(I.has(g)){let x=L.find(Q=>Q.name===I.get(g).name&&Q.type===Ke);x&&!x.copy&&(O=N|0,b=a-d|0,bl(g))}V&&V!==at&&(x=>{if(!I.get(x)?.mutable&&Y){O=N|0,b=a-d|0,ml(x);return}})(V),m.source=E;let K=re(k),Z=re(E),Ae=(x,Q)=>{if(x===Q)return!0;if(typeof x!="object"||x===null||typeof Q!="object"||Q===null)return!1;if(x.type==="local"&&Q.type==="local")return x.name===Q.name;let q=Object.keys(x).filter(fe=>fe!=="mutable"),te=Object.keys(Q).filter(fe=>fe!=="mutable");if(q.length!==te.length)return!1;for(let fe of q)if(!te.includes(fe)||!Ae(x[fe],Q[fe]))return!1;return!0},Ne=(x,Q)=>x.some(q=>Ae(q,Q));if(K&&Z){K.data?.mutable&&K.data.path===ke&&K.data.type!==Ye&&(Ne(Se,k)||c.procedure.description.inputs.some(Q=>Q.name===K.name||Q.name===qe(k))?m.target=Object.seal({type:an,link:k}):Z.data.path===ke&&Z.data.type!==Ye&&(m.source=Object.seal({type:St,value:E}),Se.push(k))),Z.data?.mutable&&Z.data.path===ke&&Z.data.type!==Ye&&E.type!==_t&&(m.source=Object.seal({type:rt,link:m.source}));let x=(Q,q)=>Q.slice(1)===Q.slice(1)||Q.charAt(0)===Q.charAt(0)||(Q==="FP64"||Q==="FP32"||Q==="I64"||Q==="U64"||Q===ut||Q==="U32"||Q==="I16"||Q==="U16"||Q==="I8"||Q==="U8")&&q===ut||Q==="FP64"&&q=="FP32";if(K.data.name!==Z.data.name&&!(K.data.type===Z.data.name||K.data.name===Z.data.type)&&!(Z.data.type===Me&&x(K.data.name,Z.data.name))){O=N|0,b=a-d|0,Ol(K.data.name,Z.data.name);return}}T.push(m),M();return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=wE;w(_(ce),n,u);break}case Hr:{let{stack:t,procedure:s}=c,n=Object.seal({type:Qf,unsafe:!0,value:null}),u=o.subarray(e,e+f|0);X(u,ec)&&(n.unsafe=!1),y(),c=Object.seal({free:n,stack:t,procedure:s}),r=zr;break}case zr:{if(o[e]===Ee){let{stack:E,procedure:m}=c;r=Xr,y(),c={stack:E,procedure:m,value:null},y(),r=Ce,P=Re;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=$e;w(_(Ee),n,u);break}case Xr:{let{value:t,stack:s}=c;M();let{free:n}=c;n.value=ge(t);let u=!0,{name:E,data:m}=re(t,u);if(O=N|0,b=a-d|0,m.type!==Vo){ue(`Variable '${E}' is not a link and cannot be freed. Only 'unsafe' links are freeable.`);return}if(m.unsafe!==n.unsafe){ue(`Improper free method used for link '${E}'. Unsafe links are unsafely freed with 'free!!' while safe ones are freed with 'free'. Your link(${E}) is ${m.unsafe?"un":""}safe.`);return}let T=s.get(E);T&&s.set(E,{...T,freed:!0}),r=Jr,l=!0;break}case Jr:{if(o[e]===oe){let{free:E}=c;M();let{statements:m}=c;m.push(E),r=Wr;break}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=Xe;w(_(oe),n,u);break}case Wr:{M();break}}},Rl=(a,o,e,f)=>{switch(r){case At:{let t=o.subarray(e,e+f|0),s=_(t);if(Ve(a,o,e,f)&&!It.includes(s)){O=N|0,b=a-d|0,ve(s);return}if(r=aa,X(kt,t)){c.data=Object.seal({type:s,unsafe:!0});return}if(X(Ut,t)){c.data=Object.seal({type:s});return}if(X(Is,t)){c.data=Object.seal({type:s});return}if(X(Ns,t)){c.data={type:s};let u=p.length;if(p[u-1].situationGeneral===4){y();let{data:m}=c;c={isEnum:!0,type:m},l=!0,r=uo,P=Xt;return}return}let n=Ge(s);if(n){n.type===ms?c.data=Object.seal({type:De,name:s,path:n.path}):c.data=Object.seal({type:De,name:n.name,path:n.path}),c.mutable&&(c.data=Object.seal({...c.data,type:_(Ut),unsafe:!0,mutable:c.mutable}));return}console.log("Failed to find type",s),O=N|0,b=a-d|0,us(s),M();break}case aa:{let t=o.subarray(e,e+f|0);if(o[e]===Le){l=!0,r=ua;return}M(),l=!0;break}case ua:{if(o[e]===Le){r=la;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=ts;w(_(Le),n,u);break}case la:{let t=o.subarray(e,e+f|0),s=_(t),n=Ge(s);if(n){let{data:E}=c,{unsafe:m,type:T,smart:I}=E,k=le(T);if(X(k,kt))c.data=Object.seal({type:T.replace(/!!$/,""),name:n.name,path:n.path,segment:nt,unsafe:m});else if(X(k,Ut))c.data=Object.seal({type:T,name:n.name,path:n.path,segment:nt});else if(X(k,ds))c.data=Object.seal({type:T,name:n.name,path:n.path,segment:nt,smart:I});else{if(L.find(g=>g.type===Ke&&g.name===E.name)){r=ia,y(),c=[],y(),c={data:null},y(),l=!0,r=At;return}c.data=Object.seal({type:T,name:n.name,path:n.path})}c.mutable&&(c.data=Object.seal({...c.data,mutable:c.mutable}));return}let u=o[e];if(u===de)return;if(u===je){l=!0,r=Gn;return}c.data.segment!==void 0&&(c.data.segment=s),r=Gn;break}case ia:{let t=o[e],{data:s}=c;if(M(),c.push(s),t===de){y(),c={data:null},y(),r=At;return}if(t===je){let m=c;M();let T=L.find(k=>k.type===Ke&&k.name===c.data.name);if(!(T.description?.generics?.length===m.length)){O=N|0,b=a-d|0,ue(`Generic object '${name}' was provided with fewer or more than expect number of types. Expected: ${T.description.generics.length}. Got: ${m.length}`);return}c.data.name=it(c.data.name,m),M();return}O=N|0,b=a-d|0;let n=o.subarray(e,e+f|0),u=_(n),E=zt;w(`${_(de)} or ${_(je)}`,u,E);break}case Gn:{if(o[e]===je){M();return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=zt;w(_(je),n,u);break}}},Cl=(a,o,e,f)=>{switch(r){case uo:{let t=o.subarray(e,e+f|0),s=_(t),n=Object.seal({type:s,name:null,length:null,path:ke});c=Object.seal({...c,type:n}),r=Su;break}case Su:{let t=o.subarray(e,e+f|0);if(o[e]===Le){r=ku;return}O=N|0,b=a-d|0;let s=_(t),n=ts;w(_(Le),s,n);break}case ku:{let t=o.subarray(e,e+f|0),s=_(t);if(Ve(a,o,e,f)&&!It.includes(s)){let u=o.subarray(e,e+f|0),E=_(u);O=N|0,b=a-d|0,ve(E);return}let n=Ge(s);c.type.name=n.name,c.type.path=n.path,r=Pu;break}case Pu:{let t=o.subarray(e,e+f|0);if(o[e]===je){r=Lu;return}O=N|0,b=a-d|0;let s=_(t),n=zt;w(_(je),s,n);break}case Lu:{let t=o.subarray(e,e+f|0);if(o[e]===Ee){r=Ru;return}O=N|0,b=a-d|0;let s=_(t),n=$e;w(_(Ee),s,n);break}case Ru:{let t=o.subarray(e,e+f|0);if(X(Ts,t)){r=Cu;return}O=N|0,b=a-d|0;let s=_(t),n=hs;w(_(Ts),s,n);break}case Cu:{let t=o.subarray(e,e+f|0);if(X(Gt,t)){r=vu;return}O=N|0,b=a-d|0;let s=_(t),n=Ht;w(_(Gt),s,n);break}case vu:{if(Ve(a,o,e,f)){let n=o.subarray(e,e+f|0),u=_(n);O=N|0,b=a-d|0,ve(u);return}let t=o.subarray(e,e+f|0),s=_(t);c.type.length=s,r=Uu;break}case Uu:{let t=o.subarray(e,e+f|0);if(o[e]===oe){r=yu,l=!0;return}O=N|0,b=a-d|0;let s=_(t),n=Xe;w(_(oe),s,n);break}case yu:{if(c.isEnum){let{type:I}=c;M(),c.data=I;return}let{declarationValue:t,procedure:s,stack:n}=c,{target:u}=t,{description:E}=s,{locals:m}=E,T;u.mutable?T=Object.freeze({name:u.name,data:{...c.type,mutable:u.mutable}}):T=Object.freeze({name:u.name,data:c.type}),n.set(u.name,T.data),m.push(T),M();break}case lo:{let t=o.subarray(e,e+f|0),n={type:_(t).replace(/!!$/,""),path:ke};X(t,kt)&&(n.unsafe=!0),n=Object.seal({...n,name:null,segment:null});let{declarationValue:u,stack:E,procedure:m}=c;c=Object.seal({declarationValue:u,stack:E,procedure:m,type:n}),r=Bu;break}case Bu:{let t=o.subarray(e,e+f|0);if(o[e]===Le){r=Du;return}O=N|0,b=a-d|0;let s=_(t),n=ts;w(_(Le),s,n);break}case Du:{let t=o.subarray(e,e+f|0),s=_(t);if(Ve(a,o,e,f)&&!It.includes(s)){O=N|0,b=a-d|0,ve(s);return}Ge(s),c.type.name=s,r=Mu;break}case Mu:{let t=o.subarray(e,e+f|0);if(o[e]===de){r=Fu;return}if(o[e]===je){r=io,l=!0;return}O=N|0,b=a-d|0;let s=_(t),n=Xe;w(`${de} or ${_(je)}`,s,n);break}case Fu:{if(Ve(a,o,e,f)){let n=o.subarray(e,e+f|0),u=_(n);O=N|0,b=a-d|0,ve(u);return}let t=o.subarray(e,e+f|0),s=_(t);c.type.segment=s,r=io;break}case io:{let t=o.subarray(e,e+f|0);if(o[e]===je){if(c.declarationValue){let{declarationValue:u,procedure:E,stack:m}=c,{target:T}=u,{description:I}=E,{locals:k}=I,V;T.mutable?V=Object.freeze({name:T.name,data:{...c.type,mutable:T.mutable}}):V=Object.freeze({name:T.name,data:c.type}),m.set(T.name,V.data),k.push(V),M()}else{let{type:u}=c;M(),c.data=u}return}O=N|0,b=a-d|0;let s=_(t),n=zt;w(_(je),s,n);break}case ju:{let t=o.subarray(e,e+f|0),s=_(t),n=Object.seal({type:s,path:null,name:null}),{declarationValue:u,stack:E,procedure:m}=c;c=Object.seal({declarationValue:u,stack:E,procedure:m,type:n}),r=wu;break}case wu:{let t=o.subarray(e,e+f|0);if(o[e]===Le){r=Yu;return}O=N|0,b=a-d|0;let s=_(t),n=ts;w(_(Le),s,n);break}case Yu:{let t=o.subarray(e,e+f|0),s=_(t);if(Ve(a,o,e,f)){O=N|0,b=a-d|0,ve(s);return}let n=Ge(s);c.type.name=s,c.type.path=n.path,r=gu;break}case gu:{let t=o.subarray(e,e+f|0);if(o[e]===je){let{declarationValue:u,procedure:E,stack:m}=c,{target:T}=u,{description:I}=E,{locals:k}=I,V;T.mutable?V=Object.freeze({name:T.name,data:{...c.type,mutable:T.mutable}}):V=Object.freeze({name:T.name,data:c.type}),m.set(T.name,V.data),k.push(V),M();return}O=N|0,b=a-d|0;let s=_(t),n=zt;w(_(je),s,n);break}}},vl=(a,o,e,f)=>{switch(r){case js:{let t=Object.seal({type:St,unsafe:null,smart:null,value:null}),s=o.subarray(e,e+f|0);X(s,kt)&&(t.unsafe=!0),X(s,ds)&&(t.smart=!0),c.value=t,r=Wa;break}case Wa:{if(o[e]===Ee){r=fa;return}O=N|0,b=a-d|0;let t=o.subarray(e,e+f|0),s=_(t),n=$e;w(_(Ee),s,n);break}case fa:{let{stack:t,procedure:s}=c,n=o.subarray(e,e+f|0),u=_(n),E=t.get(u);E&&E.moved&&(O=N|0,b=a-d|0,ue(`Moved variable used as value. Variable '${u}' was used while having been moved before.`)),r=Za,y(),c={stack:t,procedure:s,value:null},y(),r=Ce,P=Re,l=!0;break}case Za:{if(o[e]===oe){let{value:u}=c;M(),c.value.value=ge(u),M();return}O=N|0,b=a-d|0;let t=o.subarray(e,e+f|0),s=_(t),n=$e;w(_(oe),s,n);break}case Ea:{let t=Object.seal({type:rt,link:null});c.value=t,r=Qa;break}case Qa:{if(o[e]===Ee){r=_a;return}O=N|0,b=a-d|0;let t=o.subarray(e,e+f|0),s=_(t),n=$e;w(_(Ee),s,n);break}case _a:{let{stack:t,procedure:s}=c,n=o.subarray(e,e+f|0),u=_(n),E=t.get(u);E&&E.moved&&(O=N|0,b=a-d|0,ue(`Moved variable used as value. Variable '${u}' was used while having been moved before.`)),r=qa,y(),c={stack:t,procedure:s,value:null},y(),r=Ce,P=Re,l=!0;break}case qa:{if(o[e]===oe){let{value:u}=c;M(),c.value.link=ge(u),M();return}O=N|0,b=a-d|0;let t=o.subarray(e,e+f|0),s=_(t),n=Xe;w(_(oe),s,n);break}case Sa:{let t=Object.seal({type:rn,trail:[]});c.value=t,r=Zn;break}case Zn:{if(o[e]===He){r=ka;return}r=Qn,l=!0;break}case ka:{let t=o.subarray(e,e+f|0),s=_(t);c.value.trail.push(s),r=Pa;break}case Pa:{if(o[e]===He){r=Zn,l=!0;return}r=Qn,l=!0;break}case Qn:{M(),l=!0;break}case Oa:{let t=o.subarray(e,e+f|0),s=_(t),n=L.find(I=>I.name===s);if(!n){O=N|0,b=a-d|0,us(s);return}let{description:u}=n,{members:E}=u,m=E.some(I=>I.name==="constructor"&&I.type===ot),T=Object.seal({type:Me,explicitConstructor:m,name:s,literal:[],path:n.path});c.value=T,r=ga;break}case ga:{let t=o[e];if(t===Ee){r=Kn,l=!0;return}if(t===Le){r=Ga;return}break}case Ga:{y(),c=[],r=Va,l=!0;break}case Va:{r=$a,y(),c={data:null},y(),P=Mt,r=At,l=!0;break}case $a:{let t=o[e],{data:s}=c;if(M(),c.push(s),t===de){r=gs;return}if(t===je){let n=c;M();let{value:u}=c,{name:E}=u,m=L.find(T=>T.type===Ke&&T.name===E);if(m){if(!(m.description.generics.length===n.length)){O=N|0,b=a-d|0,ue(`Generic procedure '${E}' was provided with fewer or more than expect number of types. Expected: ${genericProcedure.description.generics.length}. Got: ${n.length}`);return}let I=it(m.name,n);if(!L.some(k=>k.name===I)){let k=et(m,n);k.name=I,k.description.generics=[],L.push(k)}u.name=I}r=Kn;break}}case Kn:{let{value:t}=c,{explicitConstructor:s,...n}=t;if(t=Object.seal(n),o[e]===Ee){if(s){r=xa;return}r=Hn;return}O=N|0,b=a-d|0;let E=o.subarray(e,e+f|0),m=_(E),T=$e;w(_(Ee),m,T);break}case Hn:{if(o[e]===ce)return;if(o[e]===de){r=zn;return}r=zn,l=!0;break}case zn:{let t=o.subarray(e,e+f|0),s=_(t),{stack:n,procedure:u}=c;y();let E=Object.seal({name:s,value:null});c={procedure:u,stack:n,prop:E},r=Aa;break}case Aa:{let{stack:t,procedure:s}=c;if(o[e]===Ot){r=Ta,y(),c={stack:t,procedure:s,value:null},y(),r=Ce,P=Re;return}O=N|0,b=a-d|0;let u=o.subarray(e,e+f|0),E=_(u),m=Ht;w(_(Ot),E,m);break}case Ta:{let{value:t}=c;M();let{prop:s}=c;if(s.value=ge(t),M(),c.value.literal.push(s),o[e]===de){r=Hn;return}l=!0,r=Na;break}case Na:{if(o[e]===ce){r=Xn;return}l=!0,r=Xn;break}case Xn:{let t=o[e];if(O=N|0,b=a-d|0,t===oe){let $=function(Z,Ae){let Ne=new Set(Z.map(x=>x.name));for(let x of Ae)if(!Ne.has(x.name))return x.name;return null},E=Z=>{let Ae=new Set;for(let Ne of Z){if(Ae.has(Ne.name))return Ne.name;Ae.add(Ne.name)}return!1},{value:m}=c,{literal:T}=m,I=L.find(Z=>Z.name===m.name&&Z.type===Ke),k=E(T);if(k){ue(`Propery ${k} of ${I.name} was initialized multiple times during object declaration. Please remove unnecessary value.`);return}let V=I.description.members.filter(Z=>Z.type!==ot),g=I.description.members.filter(Z=>Z.type!==ot&&Z.value===void 0),K=$(T,g);if(K){ue(`Properties ${K} of ${I.name} is missing in initialization without having been given a default value. Please give a value in initialization or provide a default value in type definition`);return}for(let Z of T){let Ae=re(Z.value),Ne=T.indexOf(Z),x=V.find(Q=>Q.name===Z.name);x||ue(`Invalid member name. Name ${Z.name} does not exist on object ${I.name}`),Ae.data.type!==Me&&Ae.data.name!==x.data.name&&ue(`Type mismatch in input for Object ${I.name}. At index ${Ne}, expected ${x.data.name} but received ${Ae.data.name}.`)}M();return}let s=o.subarray(e,e+f|0),n=_(s),u=Xe;w(_(oe),n,u);break}case xa:{let u=function(m){let T=m.data.name,I=L.find(k=>k.name===T);if(I.type===Ke){let k=[],{members:V}=I.description;for(let g of V)g.data&&k.push({name:g.name,value:u(g)});return{type:Me,name:T,literal:k,path:m.data.path}}else if(m.data.type===Ye){let k=parseInt(m.data.length,10);return{type:Me,literal:Array(k).fill(Gu),name:T,layout:Ye,path:m.data.path}}else if(m.data.type===vt){let k=parseInt(m.data.length,10);return{type:Me,literal:Array(k).fill(nt),name:T,path:m.data.path}}else return{type:Me,literal:Gu,name:T,path:m.data.path}},{value:t}=c,{literal:s,name:n}=t,E=L.find(m=>m.name===n);if(E){let{description:m}=E,{members:T}=m;for(let Ne of T)Ne.data&&s.push({name:Ne.name,value:u(Ne)});M(),M();let{stack:I,procedure:k,statements:V,declarationValue:g,inferenceValue:$}=c,K=g?.target.name;if(!K){K="literalObjectConstructor";let Ne=re(t),{literal:x,...Q}=Ne.data,{locals:q}=k.description;q.push({name:K,data:Q}),I.set(K,Q)}$&&($.data={type:De,name:n,path:E.path},$.mutable&&($.data.mutable=$.mutable),K&&c.stack.set(K,$.data)),g&&(g.source=t,V.push(g)),y();let Z=Object.seal({type:Ct,name:[K,Os],path:E.path,inputs:[]}),Ae=Object.seal({type:$o,expression:Z});c={stack:I,procedure:k,drop:Ae,value:Z},r=no,P=Ue,l=!0;return}break}case no:{let{stack:t,procedure:s}=c;if(o[e]===oe){r=oo,l=!0;return}r=eu,y(),c={stack:t,procedure:s,value:null},y(),r=Ce,P=Re,l=!0;break}case eu:{let{value:t}=c;M();let{value:s,stack:n,procedure:u}=c,{inputs:E}=s;E.push(ge(t));let m=o[e];if(m===oe){r=oo,l=!0;return}if(m===de){r=no;return}O=N|0,b=a-d|0;let T=o.subarray(e,e+f|0),I=_(T),k=bn;w(`${_(de)} or ${_(oe)}`,I,k);break}case oo:{let{value:t,stack:s,drop:n}=c,u=s.get(t?.name[0]);if(u){let I=L.find($=>$.name===u.name),k=I.description.members.find($=>$.name===Os),V=t.inputs.filter($=>$.type===Me);for(let $ of V){let K=t.inputs.indexOf($);K>=0&&t.inputs[K]&&(t.inputs[K]={...t.inputs[K],name:k.description.inputs[K]?.data?.name||$.name,path:k.description.inputs[K]?.data?.path||$.path})}let g=t.inputs.map($=>re($))||[];if(k.description.inputs.length!==g.length){O=N|0,b=a-d|0,ue(`Mismatching number of parameters passed to constructor of object '${I.name}'. Expected: ${k.description.inputs.length}, Got: ${g.length}`);return}for(let $ of k.description.inputs){let K=k.description.inputs.indexOf($);if($.data.name!==g[K].data.name){O=N|0,b=a-d|0,ue(`Input type mismatch on index '${K+1}'. '${I.name}' expected ${$.data.name}, but was provided with a rather ${g[K].data.name}`);return}}}if(o[e]===oe){r=tu;return}O=N|0,b=a-d|0;let E=o.subarray(e,e+f|0),m=_(E),T=Xe;w(_(oe),m,T);break}case tu:{if(o[e]===ce){let{drop:I}=c;M();let{statements:k}=c;k||M(),k&&k.push(I),M();return}let{value:s,stack:n,procedure:u}=c;if(M(),r===Vs){y(),c={stack:n,procedure:u,value:s},l=!0;return}O=N|0,b=a-d|0;let E=o.subarray(e,e+f|0),m=_(E),T=Kt;w(_(ce),m,T);break}case ma:{let{stack:t}=c,s=o.subarray(e,e+f|0),n=_(s);if(t.has(n)){let I=t.get(n);if(I&&(I.moved&&(O=N|0,b=a-d|0,ue(`Moved variable used as value. Variable '${n}' was used while having been moved before.`)),I.freed)){O=N|0,b=a-d|0,ue(`Attempted to use '${n}', which has been freed. Ensure links are valid before use.`);return}let k=Object.freeze({type:ct,name:n});c.value=k,r=Rt;return}let u=I=>{let k=p[I];if(k.item.target){let V=k.item.target,g=m.item.stack.get(V.name);if(g)return g.name}else return k.item.value?.type==="expression"?u(I-1):null},E=p.length,m=p[E-2],T;if(m.item.target){let I=m.item.target;if(I.name||I.trail?.length===1){let k=m.item.stack.get(I.name||I.trail[0]);k&&(T=I.name?k.name:k.data?.name)}if(I.trail?.length>1){let k=JSON.parse(JSON.stringify(I.trail)),V=m.item.stack.get(I.trail[0]),g=L.find(K=>K.name===V.data.name&&K.path===V.data.path),$=1;for(let K=1;K<k.length;K++)V=g.description.members.find(Z=>Z.name===k[K]),K<k.length-1&&(g=L.find(Z=>Z.name===V.data.name&&Z.path===V.data.path));T=V.data.name}}else m.item.value?.type==="expression"&&(T=u(E-4));if(nn(a,o,e,f)){let I=n,k=Qe(I),V=Object.freeze({type:Me,literal:I,name:T||k,path:ke});if(!k){O=N|0,b=a-d|0;let g=o.subarray(e,e+f|0),$=_(g);w("value",$,An)}Ge(V.name),c.value=V,r=Rt;return}if(Eo(n)){let I=Object.freeze({type:Me,literal:n,name:"Bool",path:ke});c.value=I,Ge(I.name),r=Rt;return}if(o[e]===Pt){r=pu,l=!0;return}if(o[e]===mE){if($s){if($s=!1,r=Rt,c.value.literal.length>1){O=N|0,b=a-d|0,ue("Type Mismatch: Use single quotes for a Char (one character) in Flogram. For Strings, use double quotes or ensure there's only one character within single quotes.");return}}else $s=!0;return}if($s){let I=Object.freeze({type:Me,literal:n,name:T||"Char",path:ke});Ge(I.name),c.value=I;return}if(o[e]===Je){r=Jn,l=!0;return}O=N|0,b=a-d|0,us(n),M();break}case pu:{if(o[e]===Pt){r=ro;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=$e;w(_(Pt),n,u);break}case ro:{let t=o.subarray(e,e+f|0),s=_(t);if(f===0)return;if(r=Ou,o[e]===Pt){l=!0;return}else if(o[e]===Le){l=!0;return}let n=Object.freeze({type:Me,literal:s,name:vt,path:ke});c.value&&c.value.type===gt?c.value.values.push(n):c.value=n,Ge(n.name);break}case Ou:{let{stack:t,procedure:s}=c;if(o[e]===Pt){if(c.value.type===gt&&o[e+1]===Pt){r=bu;return}M();return}else if(o[e]===Le){r=Au,y(),c=Object.seal({procedure:s,stack:t,value:null}),y(),P=Re,r=Ce;return}O=N|0,b=a-d|0;let n=o.subarray(e,e+f|0),u=_(n),E=$e;w(`${_(Pt)} or ${_(Le)}`,u,E);break}case Au:{let t=o.subarray(e,e+f|0),s=_(t),{value:n}=c;if(M(),!c.value||c.value.type!==gt){let u=Object.seal({type:gt,values:[]});c.value&&u.values.push(c.value),c.value=u}c.value.values.push(n),r=ro;break}case bu:{M();break}case co:{y(),r=su,c={data:null},y(),P=Mt,r=At,l=!0;break}case su:{let t=o[e],{data:s}=c;M();let{stack:n,procedure:u}=c,E=Object.seal({type:Me,literal:[],name:s.name,length:null,layout:s.type,path:s.path});if(y(),c={stack:n,procedure:u,value:E},t===Ee){r=nu;return}O=N|0,b=a-d|0;let m=o.subarray(e,e+f|0),T=_(m),I=$e;w(_(Ee),T,I);break}case nu:{let t=o.subarray(e,e+f|0);if(X(Ts,t)){r=ou;return}O=N|0,b=a-d|0;let s=_(t),n=hs;w(_(Ts),s,n);break}case ou:{let t=o.subarray(e,e+f|0);if(X(Gt,t)){r=cu;return}O=N|0,b=a-d|0;let s=_(t),n=Ht;w(_(Gt),s,n);break}case cu:{if(Ve(a,o,e,f)){let n=o.subarray(e,e+f|0),u=_(n);O=N|0,b=a-d|0,ve(u);return}let t=o.subarray(e,e+f|0),s=_(t);c.value.length=s,r=au;break}case au:{let t=o[e];if(t===de){let{stack:E,procedure:m}=c,T=[];y(),c={stack:E,procedure:m,value:T},r=uu;return}if(t===oe){let{value:E}=c;M(),c.value=E,r=Rt;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=Xe;w(`${_(de)} or ${_(oe)}`,n,u);break}case uu:{if(o[e]===Je){r=lu;return}O=N|0,b=a-d|0;let t=o.subarray(e,e+f|0),s=_(t),n=On;w(_(Je),s,n);break}case lu:{if(r=ru,o[e]===Bt)return;l=!0;break}case ru:{let t=o.subarray(e,e+f|0);if(o[e]===oe){let{value:s}=c;M();let{value:n}=c;M(),n.literal=s,c.value=n,M();return}y(),r=Gs,l=!0;break}case Jn:{let t=o.subarray(e,e+f|0);if(o[e]===Je){c.value=[],r=Rt,y(),r=Gs;return}break}case Gs:{let{stack:t,procedure:s}=c;if(r=Vs,y(),c.value.length===0&&o[e]===Bt){c={stack:t,procedure:s,value:null},r=Vs,l=!0;break}c={stack:t,procedure:s,value:null},y(),r=Ce,P=Re,l=!0;break}case Vs:{let t=o[e],{value:s}=c;if(M(),s!==null&&c.value.push(s),t===de){r=Gs;return}if(t===Bt){let n=p.length,u=p[n-3],E=u.item.declarationValue?.target,m=u.item.stack.get(E?.name);if(u.situationSection!==co){let T=!1,I;if(!m){if(c.value?.length>=1)if(I=re(c.value[0]),I){(I.data.layout===Ye||I.data.type===Ye||Array.isArray(I.data.literal))&&(T=!0);for(let V=1;V<c.value.length;V++){let g=re(c.value[V]);if((g.data.layout===Ye||g.data.type===Ye||Array.isArray(g.data.literal))&&(T=!0),g.data.name!==I.data.name||g.data.path!==I.data.path){O=N|0,b=a-d|0,ue(`Type mismatch in array initialization. Expected all items to be of type ${I.data.name} from ${I.data.path}, but found type ${g.data.name} from ${g.data.path} at position ${V}. Ensure all items in the array have the same type.`);return}}}else{O=N|0,b=a-d|0;let V=o.subarray(e,e+f|0),g=_(V);w("Inferred Type",g,An);return}else I={data:{name:"FP32",path:"Flogram"}};Ge(I.data.name)}if(m?.length&&parseInt(m.length,10)<c.value.length){O=N|0,b=a-d|0,ue(`Too much data for an array. Array is defined to have a maximum of ${m.length} but value assigned has ${c.value.length}. Consider increasing size of the array or reducing the number of elements.`);return}let k=Object.freeze({type:Me,literal:c.value,length:m?.length||c.value.length,name:m?.name||I.data.name,layout:Ye,contains:T?Ye:null,path:m?.path||I.data.path});c.value=k}M();return}break}case Rt:{let t=o[e];if(t===He){let{stack:s,value:n}=c,u=[],E=Object.freeze({type:_t,value:n,trail:u});c.value=E,y(),c=Object.seal({stack:s,trail:u,value:n}),r=Vn;return}else if(t===Je){let{value:s}=c,n=Object.seal({type:bs,array:s,index:null});c.value=n,l=!0,r=Wn;return}M(),l=!0;break}case pa:{if(o[e]!==He){let s=o.subarray(e,e+f|0),n=_(s);M(),M(),l=!0;return}r=Vn;break}case Vn:{let{stack:t,value:s,trail:n}=c,u=o.subarray(e,e+f|0),E=_(u),m,T,I=!1,k;try{let V=re(s);V&&(m=V.data)}catch{}if((s.type===ct||s.type===rt||s.type===St||Tt(s))&&!m){let V=qe(s);if(n.length===0)m=t.get(V);else{let g=n.length-1,$=t.get(V),K=L.find(Q=>Q.name===$.name),{description:Z}=K,{members:Ae}=Z,Ne=Ae.find(Q=>Q.name===n[g]),{data:x}=Ne;if(m=x,x.freed){O=N|0,b=a-d|0,ue(`Attempted to use '${n.join(".")}', which has been freed. Ensure links are valid before use.`);return}}}if(m){let{name:V,path:g}=m,$=`${g}.${V}`,K=ne.get($);K.type===Ke&&(T=K)}if(T){let{description:V}=T,{members:g}=V;for(let $ of g)if($.name===E){I=!0;break}if(!I){O=N|0,b=a-d|0,pt(E,s.name);return}}if(s.value===at||s.link===at){if(!t.get(E)){O=N|0,b=a-d|0,pt(E,`${at}(current object in definition)`);return}I=!0}if(!I){O=N|0,b=a-d|0,pt(E,s.name);return}n.push(E),r=pa;break}case da:{let{stack:t}=c,s=o.subarray(e,e+f|0),n=_(s);if(t.has(n)){let u=Object.seal({type:bs,array:{type:ct,name:n},index:null});c.value=u}r=Wn;break}case Wn:{if(o[e]===Je){r=Ia;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=On;w(_(Je),n,u);break}case Ia:{let{stack:t,procedure:s}=c;r=ha,y(),c={stack:t,procedure:s,value:null},y(),r=Ce,P=Re,l=!0;break}case ha:{if(o[e]===Bt){let{value:E}=c;M();let m=re(E);if(m.data.mutable&&E.type!==_t?c.value.index=Object.seal({type:rt,link:E}):c.value.index=E,!m||![ut,"U32","I16","U16","U8","I8"].includes(m.data.name)){O=N|0,b=a-d|0,ue("Invalid index. Array index should be a valid I32 variable");return}r=Rt;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=cc;w(_(Bt),n,u);break}case ws:{let{stack:t}=c,s=o.subarray(e,e+f|0),n=_(s),u=v.find(m=>m.type===ot&&m.name===n),E=Object.seal({type:Ct,name:n,path:u?.path||ke,inputs:[]});if(c.value=E,t.has(n)){c.value.name=[n],r=La;return}r=so;break}case La:{let t=o.subarray(e,e+f|0),s=_(t),n=o[e];if(n===He)return;if(n===Ee){r=so,l=!0;return}if(Ve(a,o,e,f)){O=N|0,b=a-d|0,ve(s);return}c.value.name.push(s);break}case so:{let t=o[e];if(t===Ee){r=$n,l=!0;return}if(t===Le){r=wa;return}break}case $n:{if(o[e]===Ee){r=Ys;return}break}case wa:{y(),c=[],r=gs,l=!0;break}case gs:{r=Ya,y(),c={data:null},y(),P=Mt,r=At,l=!0;break}case Ya:{let t=o[e],{data:s}=c;if(M(),c.push(s),t===de){r=gs;return}if(t===je){let n=c;M();let{value:u}=c,{name:E}=u,m=v.find(T=>T.type===ot&&T.name===E);if(m){if(!(m.description.generics.length===n.length)){O=N|0,b=a-d|0,ue(`Generic procedure '${E}' was provided with fewer or more than expect number of types. Expected: ${m.description.generics.length}. Got: ${n.length}`);return}let I=it(m.name,n);if(!v.some(k=>k.name===I)){let k=et(m,n);k.name=I,k.description.generics=[],v.push(k)}u.name=I}r=$n;break}}case Ys:{let t=o[e],s=o.subarray(e,e+f|0);if(t===ce||X(s,yt))return;if(t===oe){let E=c.value?.inputs?.map($=>re($))||[],[m,...T]=E,{value:I}=c,{name:k}=I,V=xt[k],g=($,K,Z,Ae)=>{for(let Ne in $.description?.members){let x=[$.description.members[Ne].data.name,...K.map(Q=>Q.description.members[Ne].data.name)];if(x.some(Q=>!It.includes(Q))){let Q=x.map(q=>L.find(te=>te.name===q));Q.every(Boolean)&&g($,Q,Z,Ae)}else{let Q=Z.find(q=>q.description&&Array.isArray(q.description.inputs)?q.description.inputs.length!==x.length?!1:q.description.inputs.every((te,fe)=>te.data.name===x[fe]):!1);if(Q)v.push(Q),ae.set(Ae,Q);else{O=N|0,b=a-d|0,Qt(`${x.join(", ")} in ${Ae}`);return}}}};if(V){let $=V.find(K=>K.description&&Array.isArray(K.description.inputs)?K.description.inputs.length!==E.length?!1:K.description.inputs.every((Z,Ae)=>Z.data.name===E[Ae].data.name):!1);if($)v.push($),ae.set(k,$);else if(E.length>=1){if(E.some(K=>K.data.name!==m.data.name)){O=N|0,b=a-d|0,Al(E.map(K=>K.data?.name)?.join(", "));return}if(E[0]?.data.type===ms){let K=V.find(Ae=>Ae.description.inputs.length===E.length&&E.length>0?Ae.description.inputs[0].data.name===Vu:!0),Z=JSON.parse(JSON.stringify(K).replace(new RegExp(Vu,"g"),E[0].data.name));v.push(Z),ae.set(k,Z)}else if(!It.includes(m.data.name)||T.some(K=>!It.includes(K.data.name))){let K=L.find(Ae=>Ae.name===m.data.name),Z=T.map(Ae=>L.find(Ne=>Ne.name===Ae.data.name));K&&Z.every(Boolean)&&g(K,Z,V,k)}else{O=N|0,b=a-d|0,Qt(`${m.data.name,T.map(K=>K.data.name)?.join(", ")} in ${k}`);return}}else{O=N|0,b=a-d|0,Qt(`${E.map(K=>K.data.name)?.join(", ")} in ${k}`);return}}else if(k!==qf){let $,K=v.find(Ne=>Ne.type===ot&&Ne.name===k);if(typeof k=="object"&&c.stack.has(k[0])){let Ne=k[k.length-2]||k[0],x=c.stack.get(Ne);if(x){let Q=L.find(q=>q.type===Ke&&q.name===x.name);Q&&(c.value.path=Q.path,$=Q.description.members.find(q=>q.type===ot&&q.name===k[k.length-1]))}}let Z=c.procedure.name===k?c.procedure:null,Ae=$||K||Z;if(Ae){let{description:Ne}=Ae,{inputs:x}=Ne,{value:Q}=c,{inputs:q}=Q;if(x.length!==q.length){O=N|0,b=a-d|0,ue(`Procedure '${k}' was provided with fewer or more than expect number of inputs. Please make sure you are passing the right number of inputs to the procedure.`);return}for(let te=0;te<x.length;te++){let fe=re(q[te]);if(fe){if(x[te].data.name!==fe.data.name){O=N|0,b=a-d|0,ue(`The procedure '${typeof k=="object"?k.join("."):k}' received an input of incorrect type at position ${te+1}. Expected: '${x[te].data.name}', but received: '${fe.data.name}'.`);return}if(x[te].data.mutable&&!fe.data.mutable){O=N|0,b=a-d|0,ue(`The procedure '${typeof k=="object"?k.join("."):k}' received an immutable input at position ${te+1} while it expects a mutable input. Expected: mutable '${x[te].data.name}', received: immutable '${fe.data.name}'.`);return}x[te].data.mutable&&fe.data.mutable}else{O=N|0,b=a-d|0,Qt(q[te]);return}}}else{O=N|0,b=a-d|0,Oo(k);return}}M();return}if(Ve(a,o,e,f)&&o[e]!=Je){let E=o.subarray(e,e+f|0),m=_(E);O=N|0,b=a-d|0,ve(m);return}let{procedure:n,stack:u}=c;r=ba,y(),c=Object.seal({procedure:n,stack:u,value:null}),y(),P=Re,r=Ce,l=!0;break}case ba:{let{value:t}=c;M();let{value:s}=c,{inputs:n}=s;s.path!==ke||t.type===_t?n.push(t):n.push(ge(t));let u=o[e];if(u===de){r=Ys;return}if(u===oe){r=Ys,l=!0;return}O=N|0,b=a-d|0;let E=o.subarray(e,e+f|0),m=_(E),T=Xe;w(`${_(de)} or ${_(oe)}`,m,T);break}case qn:{let t=o.subarray(e,e+f|0),s=_(t),n=L.find(E=>E.type===Yt&&E.name===s);if(n){let E=Object.seal({type:"literal",literal:null,name:n.name,path:n.path});c.value=E,r=Ra;return}let u=L.find(E=>E.type===Yt&&E.description.labels.find(m=>m.name===s));if(u){let E=Object.freeze({type:"literal",literal:s,name:u.name,path:u.path});c.value=E,M();return}O=N|0,b=a-d|0,pt(s);break}case Ra:{if(o[e]===He){r=Ca;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=rc;w(_(He),n,u);break}case Ca:{let t=o.subarray(e,e+f|0),s=_(t);if(L.find(u=>u.type===Yt&&u.name===c.value.name&&u.description.labels.find(E=>E.name===s))){c.value.literal=s,M();return}O=N|0,b=a-d|0,pt(s);break}case va:{let t=Object.seal({type:Ko,layout:null,data:null,value:null});c.value=t,r=Ua;break}case Ua:{if(o[e]===Le){r=ya;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=ts;w(_(Le),n,u);break}case ya:{let t=o.subarray(e,e+f|0),s=_(t);if(Ve(a,o,e,f)){O=N|0,b=a-d|0,ve(s);return}if(X(Ns,t)){r=eo,y(),c={...c,data:null},y(),P=Mt,r=At,l=!0;return}if(X(t,kt)||X(t,Ut)){r=eo,y(),c={...c,data:null},y(),P=Xt,r=lo,l=!0;return}if(X(t,Is)){O=N|0,b=a-d|0;let u=o.subarray(e,e+f|0),E=_(u);w("MAYBE Data",E,hs);return}let n=Ge(s);n&&(c.value.data=n),r=xn;break}case eo:{let{data:t}=c;M(),c.value.data=t,l=!0,r=xn;break}case xn:{if(o[e]===je){r=Ba;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=zt;w(_(je),n,u);break}case Ba:{if(o[e]===He){r=Da;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=rc;w(_(He),n,u);break}case Da:{let t=o.subarray(e,e+f|0),s=_(t);if(c.value.layout=s,X(t,qo)){r=to;return}if(X(t,xo)){r=Ma;return}O=N|0,b=a-d|0;let n=_(t),u=hs;w(`${_(xo)} or ${_(qo)}`,n,u);break}case Ma:{if(o[e]===Ee){r=Fa;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=$e;w(_(Ee),n,u);break}case Fa:{let{procedure:t,stack:s}=c;if(Ve(a,o,e,f)){let n=o.subarray(e,e+f|0),u=_(n);O=N|0,b=a-d|0,ve(u);return}r=ja,y(),c=Object.seal({procedure:t,stack:s,value:null}),y(),P=Re,r=Ce,l=!0;break}case ja:{let{value:t}=c;if(M(),c.value.value=ge(t),o[e]===oe){r=to;return}O=N|0,b=a-d|0;let n=o.subarray(e,e+f|0),u=_(n),E=Xe;w(_(oe),u,E);break}case to:{M(),l=!0;break}case Ka:{let t=Object.seal({type:un,value:null});c.value=t,r=Ha;break}case Ha:{if(o[e]===Ee){r=za;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=$e;w(_(Ee),n,u);break}case za:{let{procedure:t,stack:s}=c;if(Ve(a,o,e,f)){let n=o.subarray(e,e+f|0),u=_(n);O=N|0,b=a-d|0,ve(u);return}r=Xa,y(),c=Object.seal({procedure:t,stack:s,value:null}),y(),P=Re,r=Ce,l=!0;break}case Xa:{let{stack:t,value:s}=c;M();let n;if(s.type===ct)n=s.name;else if(s.type===rt)n=s.link;else if(s.type===St)n=s.value;else{O=N|0,b=a-d|0,ue("Non-movable type passed to move procedure. Please check types that can be moved and make sure your parameter's type is one of them.");return}let u=t.get(n);if(u&&t.set(n,{...u,moved:!0}),c.value.value=ge(s),o[e]===oe){r=Ja;return}O=N|0,b=a-d|0;let m=o.subarray(e,e+f|0),T=_(m),I=Xe;w(_(oe),T,I);break}case Ja:{M(),l=!0;break}case iu:{let t=Object.seal({type:ln,value:null});c.value=t,Ge(ut),r=fu;break}case fu:{if(o[e]===Ee){r=Eu;return}O=N|0,b=a-d|0;let s=o.subarray(e,e+f|0),n=_(s),u=$e;w(_(Ee),n,u);break}case Eu:{let{procedure:t,stack:s}=c;if(Ve(a,o,e,f)){let n=o.subarray(e,e+f|0),u=_(n);O=N|0,b=a-d|0,ve(u);return}r=_u,y(),c=Object.seal({procedure:t,stack:s,value:null}),y(),P=Re,r=Ce,l=!0;break}case _u:{let{stack:t,value:s}=c;M();let n,u=re(s);if(u.data.name===vt||u.data.name===Ye||u.data.layout===vt||u.data.layout===Ye||u.data.type===vt||u.data.type===Ye||(O=N|0,b=a-d|0,ue(`Provided type '${u.data.name}' cannot be used here as it's neither a string nor an array.`)),c.value.value=s,o[e]===oe){r=mu;return}O=N|0,b=a-d|0;let m=o.subarray(e,e+f|0),T=_(m),I=Xe;w(_(oe),T,I);break}case mu:{M(),l=!0;break}case Tu:{let t=Object.seal({type:Ct,name:null,path:null,inputs:[]});c.value=t,r=ao;break}case ao:{let{procedure:t,stack:s}=c;r=Nu,y(),c=Object.seal({procedure:t,stack:s,value:null}),y(),P=Re,r=Ce,l=!0;break}case Nu:{let{value:t}=c;M(),c.value.inputs.push(t),l=!0,r=du;break}case du:{let t=o.subarray(e,e+f|0);if(o[e]===oe){r=hu,M();return}if(bE.includes(t.length===1?t[0]:t)){r=Iu,l=!0;return}break}case Iu:{let t=o.subarray(e,e+f|0),s=_(t),n=xt[s],u=re(c.value.inputs[0]),E=n.find(m=>m.description&&Array.isArray(m.description.inputs)?m.description.inputs.length!==2?!1:m.description.inputs[0].data.name===u.data.name:!1);c.value.name=s,c.value.path=E?.path||ke,E&&v.push(E),r=ao;break}case hu:{M();break}}},Ul=(a,o,e,f)=>{switch(r){case qc:{let t=Object.seal({type:nt,path:[]}),s=Object.seal({type:Xf,source:t,alias:nt});c=Object.seal({import:s,source:t}),r=xc;break}case xc:{let t=o[e],{source:s}=c;if(t===pE&&o[e+1]===_n){s.type=ct,r=er,y(),c=[],y(),r=kn;return}if(Ve(a,o,e,f)){O=N|0,b=a-d|0,ve(name);return}s.type=Jf,r=gE,l=!0;break}case er:{let t=o[e],s=c;M();let{source:n}=c;n.path.push(s.join("")),t===_n&&(y(),c=[],y(),r=kn),t===ce&&(r=tr,l=!0);break}case kn:{let t=o[e];if(t===_n){M(),l=!0;return}if(t===ce){M(),l=!0;return}let s=o.subarray(e,e+f|0),n=_(s);c.push(n);return}case tr:{let t=s=>{let n=!0,u=null,E=null,m=fl(R);m.on(Zt,g=>{u=g}),m.on(ye,g=>{E=g});let T=new J({tabSize:4});if(T.on("token",(g,$,K,Z)=>{m.feed(g,$,K,Z)}),T.on("error",()=>{n=!1}),T.feed(s),T.done(),T.close(),m.done(),!n||E){console.error("Tokenizer or Parser error occurred.",E);return}if(!u){console.error("Invalid representation after parsing.");return}let{exports:I,data:k}=u;for(let g of I){let $=u[g.path]?.find(K=>K.name===g.name);$&&(g.path===fo&&(L.push($),Pe({name:$.name,path:$.path,type:De})),g.path===$u&&v.push($))}let V=k.filter(g=>g.type===Wf);L.unshift(...V)};if(U&&U.length>0){let s=U.find(n=>n.path===c.source.path.join("/"));if(s){let n=le(s.data);t(n)}else O=N|0,b=a-d|0,ue("NO FILES WERE FOUND: ",c.source.path)}else O=N|0,b=a-d|0,ue("NO FILES WERE FOUND: ",c.source.path);M();break}}},yl=(a,o)=>{switch(a){case Zt:{h.push(o);break}case ye:{S.push(o);break}}},y=()=>{let a=Object.freeze({item:c,indentation:Oe,situationGeneral:P,situationSection:r});p.push(a)},M=()=>{let a=p.pop();return c=a.item,Oe=a.indentation,P=a.situationGeneral,r=a.situationSection,a},qt=(a,o,e,f)=>{if(C)return;let t=()=>{G=!0,d=a|0,N=N+1};he=a+f|0;let s=o[e];if(s!==_E){if(s===ce&&G){t();return}for(G=!1,l=!0;l;)switch(l=!1,P){case Re:{Tl(a,o,e,f);break}case ac:{Nl(a,o,e,f);break}case ss:{Il(a,o,e,f);break}case ns:{dl(a,o,e,f);break}case uc:{hl(a,o,e,f);break}case Tn:{kl(a,o,e,f);break}case lc:{Pl(a,o,e,f);break}case ic:{Sl(a,o,e,f);break}case we:{Ll(a,o,e,f);break}case Mt:{Rl(a,o,e,f);break}case Ue:{vl(a,o,e,f);break}case Xt:{Cl(a,o,e,f);break}case fc:{Ul(a,o,e,f);break}default:throw pn}s===ce&&(Hu.default.diff(c,pe)&&t(),pe=JSON.parse(JSON.stringify(c)))}};return Object.freeze({done:()=>{if(qt(he,Vt,0,Vt.length),he=he+Vt.length|0,qt(he,$t,0,$t.length),he=he+$t.length|0,qt(he,Vt,0,Vt.length),he=he+Vt.length|0,D){i.emit(Zt,null);return}i.emit(Zt,se)},feed:qt,on:yl})},GE=Object.freeze({create:fl,...OE,...IE,...YE}),b_=GE;export{b_ as default};
/*! Bundled license information:

eventemitter2/lib/eventemitter2.js:
  (*!
   * EventEmitter2
   * https://github.com/hij1nx/EventEmitter2
   *
   * Copyright (c) 2013 hij1nx
   * Licensed under the MIT license.
   *)
*/
